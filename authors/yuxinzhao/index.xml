<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>YuxinZhao</title>
    <link>https://YuxinZhaozyx.github.io/authors/yuxinzhao/</link>
    <description>Recent content on YuxinZhao</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <copyright>Copyright &amp;copy; {year} YuxinZhao</copyright>
    <lastBuildDate>Tue, 23 Jul 2019 17:20:42 +0800</lastBuildDate>
    
	    <atom:link href="https://YuxinZhaozyx.github.io/authors/yuxinzhao/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>PyTorch Learning Note-6</title>
      <link>https://YuxinZhaozyx.github.io/post/pytorch-learning/note-6/</link>
      <pubDate>Tue, 23 Jul 2019 17:20:42 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/pytorch-learning/note-6/</guid>
      <description>

&lt;p&gt;PyTorch通过torch.utils.data对一般常用的数据加载进行了封装，可以很容易地实现多线程数据预读和批量加载。 并且torchvision已经预先实现了常用图像数据集，包括CIFAR-10，ImageNet、COCO、MNIST、LSUN等数据集，可通过torchvision.datasets方便地调用&lt;/p&gt;

&lt;h2 id=&#34;dataset&#34;&gt;Dataset&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Dataset&lt;/code&gt;是一个抽象类, 为了能够方便的读取，需要将要使用的数据包装为&lt;code&gt;Dataset&lt;/code&gt;类。 自定义的&lt;code&gt;Dataset&lt;/code&gt;需要继承它并且实现两个成员方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;__getitem__()&lt;/code&gt; 该方法定义用索引(&lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;len(self)&lt;/code&gt;)获取一条数据或一个样本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__len__()&lt;/code&gt; 该方法返回数据集的总长度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面我们使用kaggle上的一个竞赛&lt;a href=&#34;https://www.kaggle.com/c/bluebook-for-bulldozers/data&#34; target=&#34;_blank&#34;&gt;bluebook for bulldozers&lt;/a&gt;自定义一个数据集，为了方便介绍，我们使用里面的数据字典来做说明（因为条数少）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 定义一个数据集
class BulldozerDataset(Dataset):
    &amp;quot;&amp;quot;&amp;quot; 数据集演示 &amp;quot;&amp;quot;&amp;quot;
    def __init__(self, csv_file):
        &amp;quot;&amp;quot;&amp;quot; 实现初始化方法，在初始化的时候将数据载入 &amp;quot;&amp;quot;&amp;quot;
        self.dataframe = pd.read_csv(csv_file)

    def __len__(self):
        &amp;quot;&amp;quot;&amp;quot; 返回dataframe的长度 &amp;quot;&amp;quot;&amp;quot;
        return len(self.dataframe)

    def __getitem__(self, idx):
        &amp;quot;&amp;quot;&amp;quot; 根据 idx 返回一行数据 &amp;quot;&amp;quot;&amp;quot;
        return self.dataframe.iloc[idx].SalePrice
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，我们的数据集已经定义完成了，我们可以实例话一个对象访问他&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataset_demo= BulldozerDataset(&#39;median_benchmark.csv&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以直接使用如下命令查看数据集数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#实现了 __len__ 方法所以可以直接使用len获取数据总数
len(dataset_demo)
#用索引可以直接访问对应的数据, 对应 __getitem__ 方法
dataset_demo[0]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;11573
24000.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自定义的数据集已经创建好了，下面我们使用官方提供的数据载入器，读取数据&lt;/p&gt;

&lt;h2 id=&#34;dataloader&#34;&gt;Dataloader&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;DataLoader&lt;/code&gt;为我们提供了对&lt;code&gt;Dataset&lt;/code&gt;的读取操作，常用参数有：&lt;code&gt;batch_size&lt;/code&gt;(每个batch的大小), &lt;code&gt;shuffle&lt;/code&gt;(是否进行shuffle操作), &lt;code&gt;num_workers&lt;/code&gt;(加载数据的时候使用几个子进程)，下面做一个简单的操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataloader = torch.utils.data.DataLoader(dataset_demo, batch_size=10, shuffle=True, num_workers=0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DataLoader返回的是一个可迭代对象，我们可以使用迭代器分次获取数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;idata = iter(dataloader)
print(next(idata))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常见的用法是使用for循环对其进行遍历&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i, data in enumerate(dl):
    print(i,data)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;torchvision-包&#34;&gt;torchvision 包&lt;/h2&gt;

&lt;p&gt;torchvision 是PyTorch中专门用来处理图像的库，PyTorch官网的安装教程中最新的pip install torchvision 就是安装这个包。&lt;/p&gt;

&lt;h3 id=&#34;torchvision-datasets&#34;&gt;torchvision.datasets&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;torchvision.datasets&lt;/code&gt; 可以理解为PyTorch团队自定义的dataset，这些dataset帮我们提前处理好了很多的图片数据集，我们拿来就可以直接使用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MNIST&lt;/li&gt;
&lt;li&gt;COCO&lt;/li&gt;
&lt;li&gt;Captions&lt;/li&gt;
&lt;li&gt;Detection&lt;/li&gt;
&lt;li&gt;LSUN&lt;/li&gt;
&lt;li&gt;ImageFolder&lt;/li&gt;
&lt;li&gt;Imagenet-12&lt;/li&gt;
&lt;li&gt;CIFAR&lt;/li&gt;
&lt;li&gt;STL10&lt;/li&gt;
&lt;li&gt;SVHN&lt;/li&gt;
&lt;li&gt;PhotoTour&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import torchvision.datasets as datasets

trainset = datasets.MNIST(root=&#39;./data&#39;,  # 表示 MNIST 数据的加载的目录
                          train=True,     # 表示是否加载数据库的训练集，False的时候加载测试集
                          download=True,  # 表示是否自动下载 MNIST 数据集
                          transform=None) # 表示是否需要对数据进行预处理，None为不进行预处理
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;torchvision-models&#34;&gt;torchvision.models&lt;/h3&gt;

&lt;p&gt;torchvision不仅提供了常用图片数据集，还提供了训练好的模型，可以加载之后，直接使用，或者在进行迁移学习 torchvision.models模块的 子模块中包含以下模型结构。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AlexNet&lt;/li&gt;
&lt;li&gt;VGG&lt;/li&gt;
&lt;li&gt;ResNet&lt;/li&gt;
&lt;li&gt;SqueezeNet&lt;/li&gt;
&lt;li&gt;DenseNet&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#我们直接可以使用训练好的模型，当然这个与datasets相同，都是需要从服务器下载的
import torchvision.models as models

resnet18 = models.resnet18(pretrained=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;torchvision-transforms&#34;&gt;torchvision.transforms&lt;/h3&gt;

&lt;p&gt;transforms 模块提供了一般的图像转换操作类，用作数据处理和数据增强&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from torchvision import transforms as transforms

transform = transforms.Compose([
    transforms.RandomCrop(32, padding=4),  #先四周填充0，在把图像随机裁剪成32*32
    transforms.RandomHorizontalFlip(),  #图像一半的概率翻转，一半的概率不翻转
    transforms.RandomRotation((-45,45)), #随机旋转
    transforms.ToTensor(),
    transforms.Normalize((0.4914, 0.4822, 0.4465), (0.229, 0.224, 0.225)), #R,G,B每层的归一化用到的均值和方差 mean=[0.485, 0.456, 0.406],std=[0.229, 0.224, 0.225]
])
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>PyTorch Learning Note-5</title>
      <link>https://YuxinZhaozyx.github.io/post/pytorch-learning/note-5/</link>
      <pubDate>Tue, 23 Jul 2019 11:10:54 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/pytorch-learning/note-5/</guid>
      <description>

&lt;p&gt;本文将学习如何使用 &lt;code&gt;DataParallel&lt;/code&gt; 来使用多GPU。&lt;/p&gt;

&lt;p&gt;PyTorch非常容易就可以使用多GPU，用如下方式把一个模型放到GPU上：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;device = torch.device(&amp;quot;cuda:0&amp;quot;)
model.to(device)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后复制所有的张量到GPU上：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mytensor = my_tensor.to(device)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    只调用&lt;code&gt;my_tensor.to(device)&lt;/code&gt;并没有复制张量到GPU上，而是返回了一个copy。所以你需要把它赋值给一个新的张量并在GPU上使用这个张量。
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;在多GPU上执行前向和反向传播是自然而然的事。 但是&lt;strong&gt;PyTorch默认将只使用一个GPU&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;DataParallel&lt;/code&gt;可以轻易的让模型并行运行在多个GPU上。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;model = nn.DataParallel(model)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;导入模块和定义参数&#34;&gt;导入模块和定义参数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Parameters and DataLoaders
input_size = 5
output_size = 2

batch_size = 30
data_size = 100

# Device
device = torch.device(&amp;quot;cuda:0&amp;quot; if torch.cuda.is_available() else &amp;quot;cpu&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;虚拟数据集&#34;&gt;虚拟数据集&lt;/h2&gt;

&lt;p&gt;制作一个虚拟（随机）数据集， 你只需实现 &lt;code&gt;__getitem__&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class RandomDataset(Dataset):

    def __init__(self, size, length):
        self.len = length
        self.data = torch.randn(length, size)

    def __getitem__(self, index):
        return self.data[index]

    def __len__(self):
        return self.len


rand_loader = DataLoader(dataset=RandomDataset(input_size, data_size), batch_size=batch_size, shuffle=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;简单模型&#34;&gt;简单模型&lt;/h2&gt;

&lt;p&gt;作为演示，我们的模型只接受一个输入，执行一个线性操作，然后得到结果。 说明：&lt;code&gt;DataParallel&lt;/code&gt;能在任何模型（CNN，RNN，Capsule Net等）上使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Model(nn.Module):
    
    def __init__(self, input_size, output_size):
        super(Model, self).__init__()
        self.fc = nn.Linear(input_size, output_size)

    def forward(self, input):
        output = self.fc(input)
        print(&amp;quot;\t In Model: input size&amp;quot;, input.size(), &amp;quot;output size&amp;quot;, output.size())
        return output
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建一个模型和数据并行&#34;&gt;创建一个模型和数据并行&lt;/h2&gt;

&lt;p&gt;首先，我们需要创建一个模型实例和检测我们是否有多个GPU。 如果有多个GPU，使用&lt;code&gt;nn.DataParallel&lt;/code&gt;来包装我们的模型。 然后通过&lt;code&gt;model.to(device)&lt;/code&gt;把模型放到GPU上。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;model = Model(input_size, output_size)
if torch.cuda.device_count() &amp;gt; 1:
    print(&amp;quot;Let&#39;s use&amp;quot;, torch.cuda.device_count(), &amp;quot;GPUs!&amp;quot;)
    # dim = 0 [30, xxx] -&amp;gt; [10, ...], [10, ...], [10, ...] on 3 GPUs
    model = nn.DataParallel(model)

model.to(device)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;运行模型&#34;&gt;运行模型&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for data in rand_loader:
    input = data.to(device)
    output = model(input)
    print(&amp;quot;Outside: input size&amp;quot;, input.size(), &amp;quot;output_size&amp;quot;, output.size())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当没有或者只有一个GPU时，对30个输入和输出进行批处理，得到了期望的一样得到30个输入和输出，但是如果你有多个GPU，你得到如下的结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 GPUs&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Let&#39;s use 2 GPUs!
    In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2])
    In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2])
Outside: input size torch.Size([30, 5]) output_size torch.Size([30, 2])
    In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2])
    In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2])
Outside: input size torch.Size([30, 5]) output_size torch.Size([30, 2])
    In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2])
    In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2])
Outside: input size torch.Size([30, 5]) output_size torch.Size([30, 2])
    In Model: input size torch.Size([5, 5]) output size torch.Size([5, 2])
    In Model: input size torch.Size([5, 5]) output size torch.Size([5, 2])
Outside: input size torch.Size([10, 5]) output_size torch.Size([10, 2])
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>PyTorch Learning Note-4</title>
      <link>https://YuxinZhaozyx.github.io/post/pytorch-learning/note-4/</link>
      <pubDate>Tue, 23 Jul 2019 09:40:02 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/pytorch-learning/note-4/</guid>
      <description>

&lt;p&gt;一般情况下处理图像、文本、音频和视频数据时，可以使用标准的Python包来加载数据到一个numpy数组中。 然后把这个数组转换成 &lt;code&gt;torch.*Tensor&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;图像可以使用 Pillow, OpenCV&lt;/li&gt;
&lt;li&gt;音频可以使用 scipy, librosa&lt;/li&gt;
&lt;li&gt;文本可以使用原始Python和Cython来加载，或者使用 NLTK或 SpaCy 处理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特别的，对于图像任务，&lt;code&gt;torchvision&lt;/code&gt; 包 包含了处理一些基本图像数据集的方法。这些数据集包括 Imagenet, CIFAR10, MNIST 等。除了数据加载以外，&lt;code&gt;torchvision&lt;/code&gt; 还包含了图像转换器， &lt;code&gt;torchvision.datasets&lt;/code&gt; 和 &lt;code&gt;torch.utils.data.DataLoader&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;torchvision&lt;/code&gt;包不仅提供了巨大的便利，也避免了代码的重复。&lt;/p&gt;

&lt;p&gt;以下使用的案例中，将使用CIFAR10数据集，它有如下10个类别 ：‘airplane’, ‘automobile’, ‘bird’, ‘cat’, ‘deer’, ‘dog’, ‘frog’, ‘horse’, ‘ship’, ‘truck’。CIFAR-10的图像都是 3x32x32大小的，即，3颜色通道，32x32像素。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/4ed11e8caab93da7138bafcf8d14441abe097151/68747470733a2f2f7079746f7263682e6f72672f7475746f7269616c732f5f696d616765732f636966617231302e706e67&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;训练一个图像分类器&#34;&gt;训练一个图像分类器&lt;/h1&gt;

&lt;p&gt;依次按照下列顺序进行：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;torchvision&lt;/code&gt;加载和归一化CIFAR10训练集和测试集&lt;/li&gt;
&lt;li&gt;定义一个卷积神经网络&lt;/li&gt;
&lt;li&gt;定义损失函数&lt;/li&gt;
&lt;li&gt;在训练集上训练网络&lt;/li&gt;
&lt;li&gt;在测试集上测试网络&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;读取和归一化-cifar10&#34;&gt;读取和归一化 CIFAR10&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;torchvision&lt;/code&gt;可以非常容易地加载CIFAR10。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import torch
import torchvision
import torchvision.transforms as transforms 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;torchvision的输出是[0,1]的PILImage图像，我们把它转换为归一化范围为[-1, 1]的张量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;transform = transforms.Compose(
    [transforms.ToTensor(),
     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])

trainset = torchvision.datasets.CIFAR10(root=&#39;./data&#39;, train=True, download=True, transform=transform)
trainloader = torch.utils.data.DataLoader(trainset, batch_size=4, shuffle=True, num_workers=2)

testset = torchvision.datasets.CIFAR10(root=&#39;./data&#39;, train=False, download=True, transform=transform)
testloader = torch.utils.data.DataLoader(testset, batch_size=4, shuffle=False, num_workers=2)

classes = (&#39;plane&#39;, &#39;car&#39;, &#39;bird&#39;, &#39;cat&#39;, &#39;deer&#39;, &#39;dog&#39;, &#39;frog&#39;, &#39;horse&#39;, &#39;ship&#39;, &#39;truck&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;展示一些训练图像&#34;&gt;展示一些训练图像&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pyplot as plt 
import numpy as np 

# 展示图像的函数
def imshow(img):
    img = img / 2 + 0.5  # unnormalize
    npimg = img.numpy()
    plt.imshow(np.transpose(npimg, (1, 2, 0)))
    plt.show()

# 获取随机数据
dataiter = iter(trainloader)
images, labels = dataiter.next()

# 展示图像
imshow(torchvision.utils.make_grid(images))

# 显示图像标签
print(&amp;quot; &amp;quot;.join(&amp;quot;%5s&amp;quot; % classes[labels[j]] for j in range(4)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;image/1563855333962.png&#34; alt=&#34;1563855333962&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;truck horse   dog  frog
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;定义一个卷积神经网络&#34;&gt;定义一个卷积神经网络&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import torch.nn as nn
import torch.nn.functional as F 

class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        
        self.conv1 = nn.Conv2d(3, 6, 5) # 3 input channels, 6 output channels, 5x5 convolutional kernel
        self.pool = nn.MaxPool2d(2, 2)  # 池化层可以共用
        self.conv2 = nn.Conv2d(6, 16, 5)
        self.fc1 = nn.Linear(16 * 5 * 5, 120)
        self.fc2 = nn.Linear(120, 84)
        self.fc3 = nn.Linear(84, 10)

    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool(F.relu(self.conv2(x)))
        x = x.view(-1, 16 * 5 * 5)
        x = F.relu(self.fc1(x))
        x = F.relu(self.fc2(x))
        x = self.fc3(x)
        return x
    
net = Net()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;定义损失函数和优化器&#34;&gt;定义损失函数和优化器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import torch.optim as optim

criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;训练网络&#34;&gt;训练网络&lt;/h2&gt;

&lt;p&gt;我们只需在数据迭代器上循环，将数据输入给网络，并优化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for epoch in range(2):  # 多批次循环

    running_loss = 0.0
    for i, data in enumerate(trainloader, 0):
        # 获取输入
        inputs, labels = data

        # 梯度置0
        optimizer.zero_grad()

        # 正向传播，反向传播，优化
        outputs = net(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

        # 打印状态信息
        running_loss += loss.item()
        if i % 2000 == 1999: # 每2000批次打印一次
            print(&#39;[%d, %5d] loss: %.3f&#39; % (epoch + 1, i + 1, running_loss / 2000))
            running_loss = 0.0

print(&amp;quot;Finished Training&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;在测试集上测试网络&#34;&gt;在测试集上测试网络&lt;/h2&gt;

&lt;p&gt;我们在整个训练集上进行了2次训练，但是我们需要检查网络是否从数据集中学习到有用的东西。 通过预测神经网络输出的类别标签与实际情况标签进行对比来进行检测。 如果预测正确，我们把该样本添加到正确预测列表。 第一步，显示测试集中的图片并熟悉图片内容。然后用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataiter = iter(testloader)
images, labels = dataiter.next()

# 输出是10个标签的能量。 一个类别的能量越大，神经网络越认为它是这个类别。所以让我们得到最高能量的标签。
outputs = net(images) 
_, predicted = torch.max(outputs, 1) # (maxvalues, indices) is returned

# 显示图片
imshow(torchvision.utils.make_grid(images))
print(&#39;GroundTruth: &#39;, &#39; &#39;.join(&#39;%5s&#39; % classes[labels[j]] for j in range(4)))
print(&#39;Predicted:   &#39;, &#39; &#39;.join(&#39;%5s&#39; % classes[predicted[j]] for j in range(4)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;image/1563857966974.png&#34; alt=&#34;1563857966974&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;GroundTruth:    cat  ship  ship plane
Predicted:     bird plane plane   dog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来让看看网络在整个测试集上的结果如何。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;correct = 0
total = 0
with torch.no_grad():
    for data in testloader:
        images, labels = data
        outputs = net(images)
        _, predicted = torch.max(outputs.data, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

print(&#39;Accuracy of the network on the 10000 test images: %d %%&#39; % (100 * correct / total))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Accuracy of the network on the 10000 test images: 49 %
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在识别哪一类的时候好，哪一类不好呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class_correct = list(0. for i in range(10))
class_total = list(0. for i in range(10))
with torch.no_grad():
    for data in testloader:
        images, labels = data
        outputs = net(images)
        _, predicted = torch.max(outputs, 1)
        c = (predicted == labels).squeeze()
        for i in range(4):
            label = labels[i]
            class_correct[label] += c[i].item()
            class_total[label] += 1

for i in range(10):
    print(&#39;Accuracy of %5s : %2d %%&#39; % (classes[i], 100 * class_correct[i] / class_total[i]))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Accuracy of plane : 69 %
Accuracy of   car : 69 %
Accuracy of  bird : 15 %
Accuracy of   cat : 43 %
Accuracy of  deer : 44 %
Accuracy of   dog : 22 %
Accuracy of  frog : 72 %
Accuracy of horse : 58 %
Accuracy of  ship : 41 %
Accuracy of truck : 58 %
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;在gpu上训练&#34;&gt;在GPU上训练&lt;/h2&gt;

&lt;p&gt;把一个神经网络移动到GPU上训练就像把一个Tensor转换GPU上一样简单。并且这个操作会递归遍历有所模块，并将其参数和缓冲区转换为CUDA张量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;device = torch.device(&amp;quot;cuda:0&amp;quot; if torch.cuda.is_available() else &amp;quot;cpu&amp;quot;)

# 确认我们的电脑支持CUDA，然后显示CUDA信息
print(device)

# 将递归遍历所有模块并将模块的参数和缓冲区 转换成CUDA张量
net.to(device)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;记住: &lt;code&gt;inputs&lt;/code&gt; 和 &lt;code&gt;labels&lt;/code&gt; 也要转换。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;inputs, labels = inputs.to(device), labels.to(device)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>PyTorch Learning Note-3</title>
      <link>https://YuxinZhaozyx.github.io/post/pytorch-learning/note-3/</link>
      <pubDate>Mon, 22 Jul 2019 20:48:56 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/pytorch-learning/note-3/</guid>
      <description>

&lt;p&gt;使用torch.nn包来构建神经网络。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nn&lt;/code&gt;包依赖&lt;code&gt;autograd&lt;/code&gt;包来定义模型并求导。 一个&lt;code&gt;nn.Module&lt;/code&gt;包含各个层和一个&lt;code&gt;forward(input)&lt;/code&gt;方法，该方法返回&lt;code&gt;output&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image/68747470733a2f2f7079746f7263682e6f72672f7475746f7269616c732f5f696d616765732f6d6e6973742e706e67.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;它是一个简单的前馈神经网络，它接受一个输入，然后一层接着一层地传递，最后输出计算的结果。&lt;/p&gt;

&lt;p&gt;神经网络的典型训练过程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;定义包含一些可学习的参数(或者叫权重)神经网络模型；&lt;/li&gt;
&lt;li&gt;在数据集上迭代；&lt;/li&gt;
&lt;li&gt;通过神经网络处理输入；&lt;/li&gt;
&lt;li&gt;计算损失(输出结果和正确值的差值大小)；&lt;/li&gt;
&lt;li&gt;将梯度反向传播回网络的参数；&lt;/li&gt;
&lt;li&gt;更新网络的参数，主要使用如下简单的更新原则： &lt;code&gt;weight = weight - learning_rate * gradient&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;定义网络&#34;&gt;定义网络&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import torch
import torch.nn as nn
import torch.nn.functional as F 

class Net(nn.Module):

    def __init__(self):
        super(Net, self).__init__()

        # 1 input image channel
        # 6 output image channel
        # 5x5 square convolution kernel
        self.conv1 = nn.Conv2d(1, 6, 5)
        self.conv2 = nn.Conv2d(6, 16, 5)

        # an affine operation: y = Wx + b
        self.fc1 = nn.Linear(16 * 5 * 5, 120)
        self.fc2 = nn.Linear(120, 84)
        self.fc3 = nn.Linear(84, 10)

    def forward(self, x):
        # Max pooling over a (2, 2) window
        x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2))
        # if the size is a square you can only specify a single number
        x = F.max_pool2d(F.relu(self.conv2(x)), 2)

        x = x.view(-1, self.num_flat_features(x))
        x = F.relu(self.fc1(x))
        x = F.relu(self.fc2(x))
        x = self.fc3(x)
        return x

    def num_flat_features(self, x):
        size = x.size()[1:]  # all dimensions except the batch dimension
        
        num_features = 1
        for s in size:
            num_features *= s
        return num_features
    
net = Net()
print(net)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Net(
  (conv1): Conv2d(1, 6, kernel_size=(5, 5), stride=(1, 1))
  (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1))
  (fc1): Linear(in_features=400, out_features=120, bias=True)
  (fc2): Linear(in_features=120, out_features=84, bias=True)
  (fc3): Linear(in_features=84, out_features=10, bias=True)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;在模型中必须要定义 &lt;code&gt;forward&lt;/code&gt; 函数&lt;/strong&gt;，&lt;code&gt;backward&lt;/code&gt; 函数（用来计算梯度）会被&lt;code&gt;autograd&lt;/code&gt;自动创建。 可以在 &lt;code&gt;forward&lt;/code&gt; 函数中使用任何针对 Tensor 的操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;net.parameters()&lt;/code&gt;返回可被学习的参数（权重）列表和值&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;params = list(net.parameters())
print(len(params))
print(params[0].size())  # params[0] == net.conv1.weight
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;10
torch.Size([6, 1, 5, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;net.named_parameters&lt;/code&gt;可同时返回可学习的参数及名称。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for name,parameters in net.named_parameters():
    print(name,&#39;:&#39;,parameters.size())
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;conv1.weight : torch.Size([6, 1, 5, 5])
conv1.bias : torch.Size([6])
conv2.weight : torch.Size([16, 6, 5, 5])
conv2.bias : torch.Size([16])
fc1.weight : torch.Size([120, 400])
fc1.bias : torch.Size([120])
fc2.weight : torch.Size([10, 120])
fc2.bias : torch.Size([10])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试随机输入32×32。 注：这个网络（LeNet）期望的输入大小是32×32，如果使用MNIST数据集来训练这个网络，请把图片大小重新调整到32×32。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;input = torch.randn(1, 1, 32, 32)
out = net(input)
print(out)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor([[ 0.1052, -0.0361,  0.1122,  0.1072,  0.0887,  0.0477,
 0.0916, -0.0594,
         -0.1450,  0.0574]], grad_fn=&amp;lt;AddmmBackward&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将所有参数的梯度缓存清零，然后进行随机梯度的的反向传播：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;net.zero_grad()
out.backward(torch.randn(1, 10))
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;code&gt;torch.nn&lt;/code&gt; 只支持小批量输入。整个 &lt;code&gt;torch.nn&lt;/code&gt; 包都只支持小批量样本，而不支持单个样本。 例如，&lt;code&gt;nn.Conv2d&lt;/code&gt; 接受一个4维的张量， &lt;code&gt;每一维分别是sSamples * nChannels * Height * Width（样本数*通道数*高*宽）&lt;/code&gt;。 &lt;strong&gt;如果你有单个样本，只需使用 &lt;code&gt;input.unsqueeze(0)&lt;/code&gt; 来添加其它的维数&lt;/strong&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;我们回顾一下到目前为止用到的类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;回顾:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;torch.Tensor&lt;/code&gt;：一个用过自动调用 &lt;code&gt;backward()&lt;/code&gt;实现支持自动梯度计算的 &lt;em&gt;多维数组&lt;/em&gt; ， 并且保存关于这个向量的梯度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nn.Module&lt;/code&gt;：神经网络模块。封装参数、移动到GPU上运行、导出、加载等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nn.Parameter&lt;/code&gt;：一种变量，当把它赋值给一个&lt;code&gt;Module&lt;/code&gt;时，被 自动地注册为一个参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;autograd.Function&lt;/code&gt;：实现一个自动求导操作的前向和反向定义，每个变量操作至少创建一个函数节点，每一个&lt;code&gt;Tensor&lt;/code&gt;的操作都h会创建一个接到创建&lt;code&gt;Tensor&lt;/code&gt;和 编码其历史 的函数的&lt;code&gt;Function&lt;/code&gt;节点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;损失函数&#34;&gt;损失函数&lt;/h2&gt;

&lt;p&gt;一个损失函数接受一对 (output, target) 作为输入，计算一个值来估计网络的输出和目标值相差多少。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://pytorch.org/docs/nn&#34; target=&#34;_blank&#34;&gt;nn包&lt;/a&gt;中有很多不同的&lt;a href=&#34;https://pytorch.org/docs/nn.html#loss-functions&#34; target=&#34;_blank&#34;&gt;损失函数&lt;/a&gt;。 &lt;code&gt;nn.MSELoss&lt;/code&gt;是一个比较简单的损失函数，它计算输出和目标间的&lt;strong&gt;均方误差&lt;/strong&gt;， 例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;input = torch.randn(1, 1, 32, 32)
output = net(input)
target = torch.randn(10)  # 随机值作为样例
target = target.view(1, -1)  # 使target和output的shape相同

criterion = nn.MSELoss()
loss = criterion(output, target)
print(loss)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor(1.1509, grad_fn=&amp;lt;MseLossBackward&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常见损失函数&#34;&gt;常见损失函数&lt;/h3&gt;

&lt;h4 id=&#34;nn-l1loss&#34;&gt;&lt;code&gt;nn.L1Loss&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;$$
loss(x, y) =
\begin{cases}
\frac1n \sum \left| x_i - y_i \right|, &amp;amp; \text{if reduction=&amp;lsquo;mean&amp;rsquo;} \\&lt;br /&gt;
\sum \left| x_i - y_i \right|, &amp;amp; \text{if reduction=&amp;lsquo;sum&amp;rsquo;}
\end{cases}
$$&lt;/p&gt;

&lt;h4 id=&#34;nn-nllloss&#34;&gt;&lt;code&gt;nn.NLLLoss&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Negative Log Liklihood(NLL) Loss f 负对数似然损失函数&lt;/strong&gt;
$$
loss(x, class) = -x_{class}
$$&lt;/p&gt;

&lt;h4 id=&#34;nn-mseloss&#34;&gt;&lt;code&gt;nn.MSELoss&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Mean Squrare Error(MSE) Loss 均方损失函数&lt;/strong&gt;
$$
loss(x, y) = \frac1n \sum(x_i - y_i)^2
$$&lt;/p&gt;

&lt;h4 id=&#34;nn-crossentropyloss&#34;&gt;&lt;code&gt;nn.CrossEntropyLoss&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;多分类用的交叉熵损失函数，LogSoftMax和NLLLoss集成到一个类中，会调用nn.NLLLoss函数,可以理解为CrossEntropyLoss()=log_softmax() + NLLLoss()&lt;/p&gt;

&lt;p&gt;$$
loss(x, class) = -\log \frac{\exp(x_{class})}{\sum_j \exp(x_j)} = - x_{class} + \log \left(\sum_j \exp(x_j) \right)
$$&lt;/p&gt;

&lt;h4 id=&#34;nn-bceloss&#34;&gt;&lt;code&gt;nn.BCELoss&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;Binary Cross Entropy
$$
loss(x, t) = -\frac1n \sum_i \left(t_i *\log(x_i) + (1-t_i)*\log(1-x_i) \right)
$$&lt;/p&gt;

&lt;h2 id=&#34;反向传播&#34;&gt;反向传播&lt;/h2&gt;

&lt;p&gt;调用&lt;code&gt;loss.backward()&lt;/code&gt;获得反向传播的误差。&lt;/p&gt;

&lt;p&gt;但是在调用前需要清除已存在的梯度，否则梯度将被累加到已存在的梯度。&lt;/p&gt;

&lt;p&gt;现在，我们将调用&lt;code&gt;loss.backward()&lt;/code&gt;，并查看conv1层的偏差（bias）项在反向传播前后的梯度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;net.zero_grad()  # 清除梯度

print(&#39;conv1.bias.grad before backward&#39;)
print(net.conv1.bias.grad)

loss.backward()

print(&#39;conv1.bias.grad after backward&#39;)
print(net.conv1.bias.grad)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;conv1.bias.grad before backward
None
conv1.bias.grad after backward
tensor([ 0.0027, -0.0142,  0.0197,  0.0021, -0.0018,  0.0001])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;更新权重&#34;&gt;更新权重&lt;/h2&gt;

&lt;p&gt;在实践中最简单的权重更新规则是随机梯度下降（SGD）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; weight = weight - learning_rate * gradient
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以使用简单的Python代码实现这个规则：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;learning_rate = 0.01
for f in net.parameters():
    f.data.sub_(f.grad.data * learning_rate)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是当使用神经网络是想要使用各种不同的更新规则时，比如SGD、Nesterov-SGD、Adam、RMSPROP等，PyTorch中构建了一个包&lt;code&gt;torch.optim&lt;/code&gt;实现了所有的这些规则。 使用它们非常简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import torch.optim as optim

# create your optimizer
optimizer = optim.SGD(net.parameters(), lr=0.01)
criterion = nn.MSELoss()

# in your training loop
optimizer.zero_grad()   # zero the gradient buffers
output = net(input)
loss = criterion(output, target)
loss.backward()    # calculate gradients
optimizer.step()   # Does the update
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>PyTorch Learning Note-2</title>
      <link>https://YuxinZhaozyx.github.io/post/pytorch-learning/note-2/</link>
      <pubDate>Mon, 22 Jul 2019 19:20:28 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/pytorch-learning/note-2/</guid>
      <description>

&lt;h1 id=&#34;autograd-自动求导机制&#34;&gt;Autograd: 自动求导机制&lt;/h1&gt;

&lt;p&gt;PyTorch 中所有神经网络的核心是 &lt;code&gt;autograd&lt;/code&gt; 包。 我们先简单介绍一下这个包，然后训练第一个简单的神经网络。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;autograd&lt;/code&gt;包为张量上的所有操作提供了自动求导。 它是一个在运行时定义的框架，这意味着反向传播是根据你的代码来确定如何运行，并且每次迭代可以是不同的。&lt;/p&gt;

&lt;h2 id=&#34;张量-tensor&#34;&gt;张量 Tensor&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;torch.Tensor&lt;/code&gt;是这个包的核心类。如果设置 &lt;code&gt;.requires_grad&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt;，那么将会追踪所有对于该张量的操作。 当完成计算后通过调用 &lt;code&gt;.backward()&lt;/code&gt;，自动计算所有的梯度， 这个张量的所有梯度将会自动积累到 &lt;code&gt;.grad&lt;/code&gt; 属性。&lt;/p&gt;

&lt;p&gt;要阻止张量跟踪历史记录，可以调用&lt;code&gt;.detach()&lt;/code&gt;方法将其与计算历史记录分离，并禁止跟踪它将来的计算记录。&lt;/p&gt;

&lt;p&gt;为了防止跟踪历史记录（和使用内存），可以将代码块包装在&lt;code&gt;with torch.no_grad()：&lt;/code&gt;中。 在评估模型时特别有用，因为模型可能具有&lt;code&gt;requires_grad = True&lt;/code&gt;的可训练参数，但是我们不需要梯度计算。&lt;/p&gt;

&lt;p&gt;在自动梯度计算中还有另外一个重要的类&lt;code&gt;Function&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Tensor&lt;/code&gt; 和 &lt;code&gt;Function&lt;/code&gt;互相连接并生成一个非循环图，它表示和存储了完整的计算历史。 每个张量都有一个&lt;code&gt;.grad_fn&lt;/code&gt;属性，这个属性引用了一个创建了&lt;code&gt;Tensor&lt;/code&gt;的&lt;code&gt;Function&lt;/code&gt;（除非这个张量是用户手动创建的，即，这个张量的 &lt;code&gt;grad_fn&lt;/code&gt; 是 &lt;code&gt;None&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;如果需要计算导数，你可以在&lt;code&gt;Tensor&lt;/code&gt;上调用&lt;code&gt;.backward()&lt;/code&gt;。 如果&lt;code&gt;Tensor&lt;/code&gt;是一个标量（即它包含一个元素数据）则不需要为&lt;code&gt;backward()&lt;/code&gt;指定任何参数， 但是如果它有更多的元素，你需要指定一个&lt;code&gt;gradient&lt;/code&gt; 参数来匹配张量的形状。&lt;/p&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    在其他的文章中你可能会看到说将Tensor包裹到Variable中提供自动梯度计算，Variable 这个在0.41版中已经被标注为过期了，现在可以直接使用Tensor，官方文档在&lt;a href=&#34;https://pytorch.org/docs/stable/autograd.html#variable-deprecated&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;创建一个张量并设置 &lt;code&gt;requires_grad=True&lt;/code&gt; 用来追踪他的计算历史&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = torch.ones(2, 2, requires_grad=True)
print(x)

y = x + 2  # 对x进行操作
print(y)
print(&amp;quot;y.grad_fn: &amp;quot;, y.grad_fn)  # 结果y已经被计算出来了，所以，grad_fn已经被自动生成了

z = y * y * 3  # 对y进行操作
out = z.mean()
print(z)
print(out)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor([[1., 1.],
        [1., 1.]], requires_grad=True)
tensor([[3., 3.],
        [3., 3.]], grad_fn=&amp;lt;AddBackward0&amp;gt;)
y.grad_fn:  &amp;lt;AddBackward0 object at 0x00000202022DAE48&amp;gt;
tensor([[27., 27.],
        [27., 27.]], grad_fn=&amp;lt;MulBackward0&amp;gt;)
tensor(27., grad_fn=&amp;lt;MeanBackward0&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.requires_grad_( ... )&lt;/code&gt; 可以改变现有张量的 &lt;code&gt;requires_grad&lt;/code&gt;属性。 如果没有指定的话，默认输入的flag是 &lt;code&gt;False&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = torch.ones(2, 2)
a = (a * 3) / (a - 1)
print(a.requires_grad)
a.requires_grad_(True)
print(a.requires_grad)
b = (a * a).sum()
print(b.grad_fn)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;False
True
&amp;lt;SumBackward0 object at 0x0000028141CBADA0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;梯度&#34;&gt;梯度&lt;/h2&gt;

&lt;p&gt;反向传播 因为 &lt;code&gt;out&lt;/code&gt;是一个纯量（scalar），&lt;code&gt;out.backward()&lt;/code&gt; 等于&lt;code&gt;out.backward(torch.tensor(1))&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;out.backward()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;print gradients $\frac{d(out)}{dx}$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = torch.ones(2, 2, requires_grad=True)
y = x + 2  
z = y * y * 3  
out = z.mean()

out.backward()
print(x.grad)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor([[4.5000, 4.5000],
        [4.5000, 4.5000]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以用自动求导做更多操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = torch.randn(3, requires_grad=True)

y = x * 2
while y.data.norm() &amp;lt; 1000:
    y = y * 2

print(y)
gradients = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float)
y.backward(gradients)

print(x.grad)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor([-790.8533,  793.1236,  307.1018], grad_fn=&amp;lt;MulBackward0&amp;gt;)
tensor([5.1200e+01, 5.1200e+02, 5.1200e-02])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&lt;code&gt;.requires_grad=True&lt;/code&gt;但是你又不希望进行autograd的计算， 那么可以将变量包裹在 &lt;code&gt;with torch.no_grad()&lt;/code&gt;中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(x.requires_grad)
print((x ** 2).requires_grad)

with torch.no_grad():
    print(x.requires_grad)
    print((x ** 2).requires_grad)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;True
True
True
False
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;strong&gt;更多阅读：&lt;/strong&gt; autograd 和 Function 的&lt;a href=&#34;https://pytorch.org/docs/autograd&#34; target=&#34;_blank&#34;&gt;官方文档&lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;拓展autograd&#34;&gt;拓展Autograd&lt;/h2&gt;

&lt;p&gt;如果需要自定义autograd扩展新的功能，就需要扩展Function类。因为Function使用autograd来计算结果和梯度，并对操作历史进行编码。 在Function类中最主要的方法就是&lt;code&gt;forward()&lt;/code&gt;和&lt;code&gt;backward()&lt;/code&gt;他们分别代表了前向传播和反向传播。&lt;/p&gt;

&lt;p&gt;一个自定义的Function需要一下三个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__init__ (optional)：如果这个操作需要额外的参数则需要定义这个Function的构造函数，不需要的话可以忽略。

forward()：执行前向传播的计算代码

backward()：反向传播时梯度计算的代码。 参数的个数和forward返回值的个数一样，每个参数代表传回到此操作的梯度。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 引入Function便于扩展
from torch.autograd.function import Function

# 定义一个乘以常数的操作(输入参数是张量)
# 方法必须是静态方法，所以要加上@staticmethod 
class MulConstant(Function):
    
    @staticmethod 
    def forward(ctx, tensor, constant):
        # ctx 用来保存信息这里类似self，并且ctx的属性可以在backward中调用
        ctx.constant=constant
        return tensor *constant
    
    @staticmethod
    def backward(ctx, grad_output):
        # 返回的参数要与输入的参数一样.
        # 第一个输入为3x3的张量，第二个为一个常数
        # 常数的梯度必须是 None.
        return grad_output, None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义完我们的新操作后，我们来进行测试&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a=torch.rand(3,3,requires_grad=True)
b=MulConstant.apply(a,5)
print(&amp;quot;a:&amp;quot;+str(a))
print(&amp;quot;b:&amp;quot;+str(b)) # b为a的元素乘以5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;反向传播，返回值不是标量，所以&lt;code&gt;backward&lt;/code&gt;方法需要参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;b.backward(torch.ones_like(a))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>PyTorch Learning Note-1</title>
      <link>https://YuxinZhaozyx.github.io/post/pytorch-learning/note-1/</link>
      <pubDate>Mon, 22 Jul 2019 18:11:52 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/pytorch-learning/note-1/</guid>
      <description>

&lt;h2 id=&#34;pytorch-是什么&#34;&gt;PyTorch 是什么?&lt;/h2&gt;

&lt;p&gt;基于Python的科学计算包，服务于以下两种场景:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;作为NumPy的替代品，可以使用GPU的强大计算能力&lt;/li&gt;
&lt;li&gt;提供最大的灵活性和高速的深度学习研究平台&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tensor-张量&#34;&gt;Tensor 张量&lt;/h2&gt;

&lt;p&gt;Tensors与Numpy中的 ndarrays类似，但是在PyTorch中 Tensors 可以使用GPU进行计算.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from __future__ import print_function
import torch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;创建一个  5x5 的矩阵，但未初始化:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = torch.empty(5, 3)
print(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor([[9.5511e-39, 1.0102e-38, 4.6837e-39],
        [4.9592e-39, 5.0510e-39, 9.9184e-39],
        [9.0000e-39, 1.0561e-38, 1.0653e-38],
        [4.1327e-39, 8.9082e-39, 9.8265e-39],
        [9.4592e-39, 1.0561e-38, 1.0653e-38]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;创建一个随机初始化的矩阵:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = torch.rand(5, 3)
print(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor([[0.6004, 0.9095, 0.5525],
        [0.2870, 0.2680, 0.1937],
        [0.9153, 0.0150, 0.5165],
        [0.7875, 0.7397, 0.9305],
        [0.8575, 0.1453, 0.2655]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;创建一个0填充的矩阵，数据类型为&lt;code&gt;long&lt;/code&gt;:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = torch.zeros(5, 3, dtype=torch.long)
print(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor([[0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;创建tensor并使用现有数据初始化:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = torch.tensor([5.5, 3])
print(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor([5.5000, 3.0000])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;根据现有的张量创建张量&lt;/strong&gt;。 这些方法将重用输入张量的属性，例如， dtype，除非设置新的值进行覆盖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = torch.tensor([5.5, 3])
print(x)

x = x.new_ones(5, 3, dtype=torch.double)      # new_* 方法来创建对象
print(x)

x = torch.randn_like(x, dtype=torch.float)    # 覆盖 dtype!
print(x)                                      #  对象的size 是相同的，只是值和类型发生了变化
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor([5.5000, 3.0000])
tensor([[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]], dtype=torch.float64)
tensor([[-0.5648,  1.4639, -0.1247],
        [ 0.4187,  0.0255, -0.0938],
        [-1.2237,  0.3889,  0.9847],
        [-0.2423, -3.3706, -0.3511],
        [-1.1498, -1.1044,  0.4582]])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;获取-size&#34;&gt;获取 size&lt;/h2&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    使用&lt;code&gt;size&lt;/code&gt;方法与Numpy的&lt;code&gt;shape&lt;/code&gt;属性返回的相同，张量也支持&lt;code&gt;shape&lt;/code&gt;属性
  &lt;/div&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = torch.ones(5, 3)
print(x)

print(&amp;quot;x.size(): &amp;quot;, x.size())
print(&amp;quot;x.shape:  &amp;quot;, x.shape)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor([[1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.],
        [1., 1., 1.]])
x.size():  torch.Size([5, 3])
x.shape:   torch.Size([5, 3])
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;code&gt;torch.Size()&lt;/code&gt;返回值是&lt;code&gt;tuple&lt;/code&gt;类型，所以它支持&lt;code&gt;tuple&lt;/code&gt;类型的所有操作
  &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;基础类型&#34;&gt;基础类型&lt;/h2&gt;

&lt;h3 id=&#34;基本类型&#34;&gt;基本类型&lt;/h3&gt;

&lt;p&gt;Tensor的基本数据类型有五种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;32位浮点型：torch.FloatTensor。 (默认)&lt;/li&gt;
&lt;li&gt;64位整型：torch.LongTensor。&lt;/li&gt;
&lt;li&gt;32位整型：torch.IntTensor。&lt;/li&gt;
&lt;li&gt;16位整型：torch.ShortTensor。&lt;/li&gt;
&lt;li&gt;64位浮点型：torch.DoubleTensor。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除以上数字类型外，还有 byte和chart型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor = torch.tensor([3.1433223])  # tensor([3.1433])

long = tensor.long()  # tensor([3])
half = tensor.half()  # tensor([3.1426], dtype=torch.float16)
int_t = tensor.int()  # tensor([3], dtype=torch.int32)
flo = tensor.float()  # tensor([3.1433])
short = tensor.short()  # tensor([3], dtype=torch.int16)
ch = tensor.char()  # tensor([3], dtype=torch.int8)
bt = tensor.byte()  # tensor([3], dtype=torch.uint8)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;operation-操作&#34;&gt;Operation 操作&lt;/h2&gt;

&lt;h3 id=&#34;加法&#34;&gt;加法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = torch.rand(5, 3)
y = torch.rand(5, 3)

sum = x + y                 # 加法1，操作符
sum = torch.add(x, y)       # 加法2，函数
torch.add(x, y, out=sum)    # 加法3，提供输出张量sum作为参数
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;替换&#34;&gt;替换&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# add x to y
y.add_(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    任何 以&lt;code&gt;_&lt;/code&gt; 结尾的操作都会用结果替换原变量. 例如: &lt;code&gt;x.copy_(y)&lt;/code&gt;, &lt;code&gt;x.t_()&lt;/code&gt;, 都会改变 &lt;code&gt;x&lt;/code&gt;.
  &lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&#34;截取&#34;&gt;截取&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(x[:, 1])
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;view-reshape&#34;&gt;view / reshape&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;torch.view&lt;/code&gt; 可以改变张量的维度和大小，与numpy的reshape类似&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = torch.randn(4, 4)
y = x.view(16)
z = x.view(-1, 8)  #  size -1 从其他维度推断
print(x.size(), y.size(), z.size())
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;torch.Size([4, 4]) torch.Size([16]) torch.Size([2, 8])
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;只有一个元素的张量取值&#34;&gt;只有一个元素的张量取值&lt;/h3&gt;

&lt;p&gt;如果你有只有一个元素的张量，使用&lt;code&gt;.item()&lt;/code&gt;来得到Python数据类型的数值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = torch.randn(1)
print(x)
print(x.item())
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor([-0.2036])
-0.203627809882164
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    更多操作&lt;a href=&#34;https://pytorch.org/docs/stable/torch.html&#34; target=&#34;_blank&#34;&gt;点击此处&lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;numpy-转换&#34;&gt;Numpy 转换&lt;/h2&gt;

&lt;p&gt;Torch Tensor与NumPy数组&lt;strong&gt;共享底层内存地址&lt;/strong&gt;，修改一个会导致另一个的变化。&lt;/p&gt;

&lt;h3 id=&#34;torch-tensor-转换成-numpy数组&#34;&gt;Torch Tensor 转换成 NumPy数组&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = torch.ones(5)
print(a)

b = a.numpy()
print(b)

a.add_(1)
print(a)
print(b)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor([1., 1., 1., 1., 1.])
[1. 1. 1. 1. 1.]
tensor([2., 2., 2., 2., 2.])
[2. 2. 2. 2. 2.]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;numpy数组-转换成-torch-tensor&#34;&gt;NumPy数组 转换成 Torch Tensor&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = np.ones(5)
b = torch.from_numpy(a)
print(a)
print(b)

np.add(a, 1, out=a)
print(a)
print(b)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[1. 1. 1. 1. 1.]
tensor([1., 1., 1., 1., 1.], dtype=torch.float64)
[2. 2. 2. 2. 2.]
tensor([2., 2., 2., 2., 2.], dtype=torch.float64)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    所有的 &lt;code&gt;Tensor&lt;/code&gt; 类型默认都是基于CPU， &lt;code&gt;CharTensor&lt;/code&gt; 类型不支持到 NumPy 的转换.
  &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;cuda-张量&#34;&gt;CUDA 张量&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;.to&lt;/code&gt; 方法 可以将Tensor移动到任何设备中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = torch.rand(1)

# is_available 函数判断是否有cuda可以使用
# torch.device 将张量移动到指定的设备中
if torch.cuda.is_available():
    device = torch.device(&amp;quot;cuda&amp;quot;)          # a CUDA 设备对象
    y = torch.ones_like(x, device=device)  # 直接从GPU创建张量
    x = x.to(device)                       # 或者直接使用 .to(&amp;quot;cuda&amp;quot;) 将张量移动到cuda中
    z = x + y
    print(z)
    print(z.to(&amp;quot;cpu&amp;quot;, torch.double))       # .to 也会对变量的类型做更改
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor([1.2840], device=&#39;cuda:0&#39;)
tensor([1.2840], dtype=torch.float64)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般情况下可以使用&lt;code&gt;.cuda&lt;/code&gt;方法和 &lt;code&gt;.cpu&lt;/code&gt; 方法将tensor在cpu和gpu之间移动 （需要cuda设备支持）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;cpu_a = torch.rand(4, 3)
cpu_a.type()  # torch.FloatTensor

gpu_a = cpu_a.cuda()
gpu_a.type()  # torch.cuda.FloatTensor

cpu_b = gpu_a.cpu()
cpu_b.type()  # torch.FloatTensor
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建变量与结果变量&#34;&gt;创建变量与结果变量&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;.is_leaf&lt;/code&gt;：记录是否是叶子节点。通过这个属性来确定这个变量的类型 在官方文档中所说的“graph leaves”,“leaf variables”，都是指像&lt;code&gt;x&lt;/code&gt;,&lt;code&gt;y&lt;/code&gt;这样的手动创建的、而非运算得到的变量，这些变量成为创建变量。 像&lt;code&gt;z&lt;/code&gt;这样的，是通过计算后得到的结果称为结果变量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(&amp;quot;x.is_leaf=&amp;quot;+str(x.is_leaf))
print(&amp;quot;z.is_leaf=&amp;quot;+str(z.is_leaf))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x.is_leaf=True
z.is_leaf=False
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>PyTorch Learning</title>
      <link>https://YuxinZhaozyx.github.io/project/pytorch-learning/</link>
      <pubDate>Mon, 22 Jul 2019 17:37:53 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/project/pytorch-learning/</guid>
      <description>

&lt;p&gt;This project is to record my learning road of pytorch framework.&lt;/p&gt;

&lt;h2 id=&#34;tutorial&#34;&gt;Tutorial&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html&#34; target=&#34;_blank&#34;&gt;官方教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zergtant/pytorch-handbook&#34; target=&#34;_blank&#34;&gt;PyTorch中文手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Windows PATH 长度限制最多2047个字符</title>
      <link>https://YuxinZhaozyx.github.io/post/windows-path-limited-length/</link>
      <pubDate>Sat, 20 Jul 2019 09:53:59 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/windows-path-limited-length/</guid>
      <description>

&lt;p&gt;最近使用windows安装一些软件的过程中，出现了环境变量PATH最长限制2047个字符的问题。所幸我习惯下载软件的zip包，自己解压后再将其添加到环境变量中，因此才能及时发现这个问题。用安装包安装可能还不会提示这个问题，出情况也就比较难去定位问题了。&lt;/p&gt;

&lt;h2 id=&#34;problem-问题&#34;&gt;Problem 问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;环境变量PATH (或者是Path，windows的环境变量不区分大小写) 最大长度为2047个字符，要添加新的位置到环境变量中就超出了限制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-解决方法&#34;&gt;Solution 解决方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;用一个新的环境变量PATH2来拓展PATH&lt;/strong&gt;，具体步骤如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开 &lt;code&gt;计算机 &amp;gt;&amp;gt; 属性 &amp;gt;&amp;gt; 高级系统设置 &amp;gt;&amp;gt; 环境变量&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;系统变量&lt;/strong&gt;中找到 &lt;code&gt;PATH&lt;/code&gt; (不区分大小写)， 将其名称改成 &lt;code&gt;PATH2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;新建一环境变量 &lt;code&gt;PATH&lt;/code&gt;，在其中添加一个值&lt;code&gt;%PATH2%&lt;/code&gt; 用于将 &lt;code&gt;PATH2&lt;/code&gt; 包含进来。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完成。&lt;/p&gt;

&lt;p&gt;由于新的 &lt;code&gt;PATH&lt;/code&gt; 的只有 &lt;code&gt;%PATH2%&lt;/code&gt; 一个值，后续要添加到环境变量中的位置都可以添加到 &lt;code&gt;PATH&lt;/code&gt; 中，相当于扩容了 &lt;code&gt;PATH&lt;/code&gt;，而 &lt;code&gt;PATH2&lt;/code&gt; 是透明的，对以后的操作并不会有什么影响。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[论文笔记] R-C3D: Region Convolutional 3D Network for Temporal Activity Detection</title>
      <link>https://YuxinZhaozyx.github.io/paper-note/r-c3d-region-convolutional-3d-network-for-temporal-activity-detection/</link>
      <pubDate>Wed, 17 Jul 2019 18:44:03 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/paper-note/r-c3d-region-convolutional-3d-network-for-temporal-activity-detection/</guid>
      <description>

&lt;p&gt;作者提出了R-C3D模型用于连续视频的行为检测(Activity Detection in Continuous Videos)。连续视频的行为检测需要完成两个目标：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;识别出行为的类别&lt;/li&gt;
&lt;li&gt;定位行为发生的时间范围&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两个问题正是R-C3D着力解决的。&lt;/p&gt;

&lt;h3 id=&#34;术语缩写&#34;&gt;术语缩写&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;缩写&lt;/th&gt;
&lt;th&gt;全称&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;R-C3D&lt;/td&gt;
&lt;td&gt;Region Convolutional 3D Network&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RoI&lt;/td&gt;
&lt;td&gt;Region of Interest&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RPN&lt;/td&gt;
&lt;td&gt;Region Proposal Network&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;r-c3d-的特点&#34;&gt;R-C3D 的特点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;端到端的训练方式；&lt;/li&gt;
&lt;li&gt;可以检测出任意时长的行为；&lt;/li&gt;
&lt;li&gt;检测速度快，一次性能计算的帧仅受限于GPU内存；&lt;/li&gt;
&lt;li&gt;推广Faster-RCNN的Region Proposal Network到时域；&lt;/li&gt;
&lt;li&gt;推广Faster-RCNN的RoI Pooling算法到时域，提出3D RoI Pooling。&lt;/li&gt;
&lt;li&gt;有监督学习(特别之处是允许一个视频中包含多种行为，且行为的时间范围有重叠)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;r-c3d-的网络结构&#34;&gt;R-C3D 的网络结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;image/1563363180600.png&#34; alt=&#34;1563363180600&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image/R-C3D.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    上图为本人理解后绘制的网络结构图，如有错误，欢迎批评指正。
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;作者提出的 R-C3D 网络包含3个组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;a shared 3D ConvNet feature extractor&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a temporal proposal stage&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;an activity classification and refinement stage&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3d-convolutional-feature-hierarchies&#34;&gt;3D Convolutional Feature Hierarchies&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; sequence of RGB video frames with dimension $\mathbb{R}^{3 \times L \times H \times W}$.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The input to the model is of &lt;strong&gt;variable length&lt;/strong&gt; (&lt;strong&gt;$L$ can be arbitrary&lt;/strong&gt; and is only limited by memory)&lt;/li&gt;
&lt;li&gt;Adopt &lt;strong&gt;the convolutional layers (conv1a to conv5b) of C3D&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;本例中，$H=W=112$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt; a feature map $C_{conv5b} \in \mathbb{R}^{512 \times \frac{L}8 \times \frac{H}{16} \times \frac{W}{16} }$ (512 is the channel dimension of the layer conv5b) (activations)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;$C_{conv5b}$ activations are the shared input to the proposal and classification subnets&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;temporal-proposal-subnet&#34;&gt;Temporal Proposal Subnet&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;image/1563368283613.png&#34; alt=&#34;1563368283613&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Function:&lt;/strong&gt; predicts &lt;strong&gt;potential proposal segments with respect to anchor segments&lt;/strong&gt; and &lt;strong&gt;a binary label indicating whether the predicted proposal contains an activity or not&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The anchor segments are pre-defined multi-scale windows centered at $L/8$ uniformly distributed temporal locations.&lt;/li&gt;
&lt;li&gt;Each temporal locaiton specifies $K$ anchor segments, each at a different fixed scale. Thus, the total number of anchor segments is $(L/8) * K$ .&lt;/li&gt;
&lt;li&gt;a &lt;strong&gt;3D convolutional filter with kernel size $3 \times 3 \times 3$&lt;/strong&gt; on top of $C_{conv5b}$ to extend the temporal proposal subnet.&lt;/li&gt;
&lt;li&gt;a &lt;strong&gt;3D max-pooling filter with kernel size $1 \times \frac{H}{16} \times \frac{W}{16}$&lt;/strong&gt; to downsample the spatial dimensions (from $\frac{H}{16} \times \frac{W}{16}$ to $1 \times 1$) to a temporal only feature map $C_{tpn} \in \mathbb{R}^{512 \times \frac{L}8 \times 1 \times 1}$.&lt;/li&gt;
&lt;li&gt;The 512-dimensional feature vector at each temporal location ($512 \times 1 \times 1 \times 1$) in $C_{tpn}$ is used &lt;strong&gt;to predict&lt;/strong&gt; :

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;a relative offset $\{ \delta c_i, \delta l_i \}$ to the center location&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the length of each anchor segment $\{ c_i, l_i \},\, i \in \{ 1, \cdots, K \}$&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the binary scores for each proposal being an activity or background&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;two $1 \times 1 \times 1$ convolutional layers&lt;/strong&gt; on top of $C_{tpn}$ to predict proposal offsets and scores.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;training-temporal-proposal-subnet&#34;&gt;Training Temporal Proposal Subnet&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Positive Label:&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;if the anchor segment &lt;strong&gt;overlaps with some ground-truth activity with IoU &amp;gt; 0.7&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;or if the anchor segment has the &lt;strong&gt;highest IoU overlap with some ground-truth activity&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Negative Label:&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;if the anchor has &lt;strong&gt;IoU overlap lower than 0.3 with all ground-truth activities&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;All others are held out from training&lt;/li&gt;
&lt;li&gt;sample balanced batches with a &lt;strong&gt;positive/negative ratio of 1:1&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;activity-classification-subnet&#34;&gt;Activity Classification Subnet&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;image/1563371361436.png&#34; alt=&#34;1563371361436&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Functions:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;selecting proposal segments&lt;/strong&gt; from the previous stage.&lt;/li&gt;
&lt;li&gt;three-dimensional region of interest &lt;strong&gt;(3D RoI) pooling to extract fixed-size features for selected proposals&lt;/strong&gt;.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;activity classification and boundary regression&lt;/strong&gt; for the selected proposals based on the pooled features.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;greedy &lt;strong&gt;Non-Maximum Suppression (NMS, threshold=0.7)&lt;/strong&gt; to eliminate highly overlapping and low confidence proposals.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3d-roi-pooling&#34;&gt;3D RoI Pooling&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;对于一个 $l \times h \times w$ 的不定输入张量（每次输入的张量的尺寸可以不一样），3D RoI Pooling 将其规约到固定的大小 $l_s \times h_s \times w_s$ .

&lt;ul&gt;
&lt;li&gt;$l \times h \times w$ 先被分成 $l_s \times h_s \times w_s$ 个大小约为 $\frac{l}{l_s} \times \frac{h}{h_s} \times \frac{w}{w_s}$ 的小张量，每个张量内做max pooling 得到 $l_s \times h_s \times w_s$ 的张量。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在本例中，由于$H=W=112$，$C_{conv5b} \in \mathbb{R}^{512 \times \frac{L}8 \times 7 \times 7}$，将 $512 \times \frac{L}8 \times 7 \times 7$  的张量固定为 $512 \times 1 \times 4 \times 4$.&lt;/li&gt;
&lt;li&gt;The output of the 3D RoI pooling is fed to a series of &lt;strong&gt;two fully connected layers&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;3D RoI pooling 的两层 fully connected layers 之后是 classification layer 和 regression layer.

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;classification layer 和 regression layer 是两个独立的双层 fully connected layers, 它们的输入都是 3D RoI pooling 后 fully connected layers 的输出。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;training-classification-subnet&#34;&gt;Training Classification Subnet&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Positive Label:&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;if the proposal has the &lt;strong&gt;highest IoU&lt;/strong&gt; overlap with a ground-truth activity and &lt;strong&gt;IoU &amp;gt; 0.5&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Negative Label:&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;proposals with IoU overlap lower than 0.5 with all grouth-truth activities.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Positive : Negative = 1 : 3&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;optimization&#34;&gt;Optimization&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Loss Function:&lt;/strong&gt;
$$
Loss = \frac1{N_{cls}} \sum_i L_{cls}(a_i, a_i^*) + \lambda \frac1{N_{reg}} a_i^* L_{reg}(t_i, t_i^*)
$$&lt;/p&gt;

&lt;p&gt;where,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$L_{cls}$ is softmax loss function&lt;/li&gt;
&lt;li&gt;$L_{reg}$ is smooth L1 loss function&lt;/li&gt;
&lt;li&gt;$N_{cls}$ is batch size&lt;/li&gt;
&lt;li&gt;$N_{reg}$ is the number of anchor/proposal segments&lt;/li&gt;
&lt;li&gt;$\lambda$ is the loss trade-off parameter and is set to 1.&lt;/li&gt;
&lt;li&gt;$i$ is the anchor/proposal segments index in a batch&lt;/li&gt;
&lt;li&gt;$a_i$ is the predicted probability of the proposal or activities&lt;/li&gt;
&lt;li&gt;$a_i^*$ is the ground truth&lt;/li&gt;
&lt;li&gt;$t_i = \{ \delta \hat{ c_i} , \delta \hat{ l_i} \}$ represents predicted relative offset to anchor segments or proposals.&lt;/li&gt;
&lt;li&gt;$t_i^* = \{ \delta c_i , \delta l_i \}$ represents the coordinate transformation of ground truth segments to anchor segments or proposals.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$
\begin{cases}
\delta c_i = (c_i^* - c_i) / l_i \\&lt;br /&gt;
\delta l_i = \log (l_i^* / l_i)
\end{cases}
$$&lt;/p&gt;

&lt;p&gt;where $c_i$ and $l_i$ are the center location and the length of anchor segments or proposals while $c_i^*$ and $l_i^*$  denote the same for the ground truth activity segment.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The above loss function is applied for both the temporal proposal subnet and the activity classification subnet.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;In proposal subnet,&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;$L_{cls}$ predicts whether the proposal contains an activity or not.&lt;/li&gt;
&lt;li&gt;$L_{reg}$ optimizes the relative displacement between proposals and ground truths.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;In classification subnet,&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;$L_{cls}$ predicts the specific activity class for the proposal. (The number of classes are the number of activities + one for background)&lt;/li&gt;
&lt;li&gt;$L_{reg}$ optimizes the relative displacement between activities and ground truths.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;prediction&#34;&gt;Prediction&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;预测出$t_i$后需要逆变换把相对坐标变成绝对坐标。&lt;/li&gt;
&lt;li&gt;为了充分利用向量化实现的优势，用最后一帧去填充视频较短不足的部分。&lt;/li&gt;
&lt;li&gt;NMS at a lower threshold (0.1 less than the mAP evalution threshold) is appled to the predicted activities to get the final activity predictions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;experiments&#34;&gt;Experiments&lt;/h2&gt;

&lt;h3 id=&#34;experiments-on-thumos-14&#34;&gt;Experiments on THUMOS&amp;rsquo;14&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;divide 200 untrimmed videos from the validation set into 180 training and 20 held out videos to get the best hyperparameter setting.&lt;/li&gt;
&lt;li&gt;Since the GPU memory is limited, the authors first create a buffer of 768 frames at 25 fps which means approximately 30 seconds of video.&lt;/li&gt;
&lt;li&gt;The authors create the buffer by sliding from the beginning of the video to the end, denoted as the &amp;ldquo;one-way buffer&amp;rdquo;. An additional pass from the end of the video to the beginning is used to increase the amount of training data, denoted as &amp;ldquo;two-way buffer&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;initialize the 3D ConvNet part of our model with C3D weights trained on Sports-1M and finetuned on UCF101.&lt;/li&gt;
&lt;li&gt;allow all the layers of R-C3D to be trained on THUMOS&amp;rsquo;14 with a f&lt;strong&gt;ixed learning rate of 0.0001&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;K = 10, with scale values [2, 4, 5, 6, 8, 9, 10, 12, 14, 16]&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;experiments-on-activitynet&#34;&gt;Experiments on ActivityNet&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;sample frames at 3 fps&lt;/li&gt;
&lt;li&gt;input buffer: 768&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;K=20, with scale values [1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64]&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;experiments-on-charades&#34;&gt;Experiments on Charades&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;sample frames at 5 fps&lt;/li&gt;
&lt;li&gt;input buffer: 768&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;K=18, with scale values [1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48]&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>NMS / soft-NMS / softer-NMS</title>
      <link>https://YuxinZhaozyx.github.io/post/nms/</link>
      <pubDate>Wed, 17 Jul 2019 14:12:08 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/nms/</guid>
      <description>

&lt;p&gt;目标检测算法包含了三个要素：Backbone + Head + Postprocess，对于Postprocess部分，最早用的是NMS，后面出现了Soft NMS和Softer NMS，本文将分别解释它们的动机和原理。&lt;/p&gt;

&lt;h2 id=&#34;nms&#34;&gt;NMS&lt;/h2&gt;

&lt;p&gt;NMS，它的全称为“non-maximum supression”，中文名“非极大值抑制”。为什么要使用NMS呢？因为在目标检测任务中，不管是one-stage还是two-stage的算法，最终算法都会预测出多个proposals。在后处理部分中，需要对这些proposals做筛选。&lt;/p&gt;

&lt;h3 id=&#34;动机&#34;&gt;动机&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;优先选择分类score较高的proposal；&lt;/li&gt;
&lt;li&gt;跟分类score重叠较多的proposals，可以视为冗余的预测框；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;步骤&#34;&gt;步骤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;将算法预测出的所有proposals，按照不同的类别标签分组；&lt;/li&gt;
&lt;li&gt;对于每一个类别的所有proposals，记作$B$，筛选后的proposals集合记作$D$，执行如下操作，

&lt;ul&gt;
&lt;li&gt;a. 选择score最高的proposal，记作$M$，加入到$M$中；&lt;/li&gt;
&lt;li&gt;b. 计算剩余的proposals与$M$之间的&lt;a href=&#34;https://YuxinZhaozyx.github.io/post/what-is-iou&#34;&gt;IoU&lt;/a&gt;，若大于阈值$N_t$ ，则舍弃，否则保留；&lt;/li&gt;
&lt;li&gt;c. 若步骤b中得到的所有proposals为空，则跳回步骤b，否则执行步骤a。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;经过后处理之后，所有类别保留的有效proposals集合为 $S={D_1, D_2, …, D_c}$ ，其中$c$表示目标类别的数量；&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;伪代码&#34;&gt;伪代码&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;image/nms.png&#34; alt=&#34;nms&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;soft-nms&#34;&gt;Soft-NMS&lt;/h2&gt;

&lt;h3 id=&#34;动机-1&#34;&gt;动机&lt;/h3&gt;

&lt;p&gt;由上可见，NMS算法保留score最高的预测框，并将与当前预测框重叠较多的proposals视作冗余，显然，在实际的检测任务中，这种思路有明显的缺点，比如对于稠密物体检测，当同类的两个目标距离较近时，如果使用原生的NMS，就会导致其中一个目标不能被召回，为了提高这种情况下目标检测的召回率，Soft-NMS应运而生。对于Faster-RCNN在MS-COCO数据集上的结果，将NMS改成Soft-NMS，mAP提升了1.1%。&lt;/p&gt;

&lt;h3 id=&#34;算法思想&#34;&gt;算法思想&lt;/h3&gt;

&lt;p&gt;Soft-NMS，原文的标题为&lt;a href=&#34;https://arxiv.org/pdf/1704.04503.pdf&#34; target=&#34;_blank&#34;&gt;“Improving Object Detection With One Line of Code”&lt;/a&gt;。NMS采用“一刀切”的思想，将重叠较多的proposals全部视作冗余，而Soft-NMS，采用了“迂回”战术，它认为重叠较多的proposals也有可能包含有效目标，只不过重叠区域越大可能性越小。参见下图，NMS会将绿色框的score置0，而Soft-NMS会将绿色框的score由0.8下降到0.4，显然Soft-NMS更加合理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image/1563347147055.png&#34; alt=&#34;1563347147055&#34; /&gt;&lt;/p&gt;

&lt;p&gt;那么问题来了，怎么建立IoU和score之间的联系呢，文章中给出的公式如下:&lt;/p&gt;

&lt;p&gt;$$
s_i = s_i e^{-\frac{\text{iou}(M, b_i)^2}{\sigma}}, \forall b_i \notin D
$$&lt;/p&gt;

&lt;p&gt;其中$D$表示所有保留的有效框集合, $b_i$表示待过滤的第$i$个预测框，$s_i$为第$i$个预测框对应的分类score。这里使用了高斯函数作为惩罚项，当$iou=0$时，分类score不变，当$0&amp;lt;iou&amp;lt;1$时，分类score会做衰减。以上图为例，绿色框$b_i$和红色框$M$的iou大于0，经过Soft-NMS后该绿色框的分类score由0.8衰减到0.4，可以推断出，如果图中有第2个绿色框，且其与红色框的重叠区域更大时，那么这个新的绿色框的分类score可能由0.8衰减到0.01。&lt;/p&gt;

&lt;h3 id=&#34;步骤-1&#34;&gt;步骤&lt;/h3&gt;

&lt;h4 id=&#34;伪代码-1&#34;&gt;伪代码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;image/1563347916824.png&#34; alt=&#34;1563347916824&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;softer-nms&#34;&gt;Softer-NMS&lt;/h2&gt;

&lt;h3 id=&#34;动机-2&#34;&gt;动机&lt;/h3&gt;

&lt;h4 id=&#34;现有方法的问题&#34;&gt;现有方法的问题&lt;/h4&gt;

&lt;p&gt;作者使用VGG-16 faster R-CNN测试了MS-COCO数据集中的图片，论文中贴了两张检测失败的代表图片，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image/1563348045749.png&#34; alt=&#34;1563348045749&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;左图存在的问题：&lt;/strong&gt;检测出来的2个proposals，沿着y坐标轴方向的定位均不准确；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;检测算法预测出来的proposals的坐标不一定准确；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;右图存在的问题：&lt;/strong&gt;检测出来的2个proposals，右边的框分类score较高，但是却沿着x坐标轴方向的定位不准确；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;分类score高不一定定位score高，也即classification confidence和 localization confidence不具有一致性。&lt;/p&gt;

&lt;h4 id=&#34;本文解决方法&#34;&gt;本文解决方法&lt;/h4&gt;

&lt;p&gt;针对上面的问题，
1. 既然proposals的坐标不准确，那么即便NMS也无能为力了，所以需要重新设计坐标回归的方式)；
2. 既然分类score高不一定定位score高，那么NMS和Soft-NMS的做法（只基于分类score对proposals做排序）是不准确的，所以需要同时预测出检测框的定位score。&lt;/p&gt;

&lt;h3 id=&#34;算法&#34;&gt;算法&lt;/h3&gt;

&lt;p&gt;Softer-NMS的算法框架如下图，可以看出，它跟fast R-CNN是非常相似的，区别在于回归任务中多了一个Box std分支，这里需要解释一下，比如预测出的bounding box的坐标为$x_1, y_1, x_2, y_2$，该分支会预测出每个坐标的标准差，显然，当坐标的标准差越小时，表明预测得到的坐标值越可信，也即Box std分支用于表征定位任务的置信度。&lt;/p&gt;







&lt;figure&gt;

&lt;img src=&#34;image/1563348994861.png&#34; alt=&#34;fast R-CNN&#34; &gt;



&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  
  &lt;p&gt;
    fast R-CNN
    
    
    
  &lt;/p&gt; 
&lt;/figcaption&gt;

&lt;/figure&gt;








&lt;figure&gt;

&lt;img src=&#34;image/1563349684043.png&#34; alt=&#34;faster-NMS&#34; &gt;



&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  
  &lt;p&gt;
    faster-NMS
    
    
    
  &lt;/p&gt; 
&lt;/figcaption&gt;

&lt;/figure&gt;


&lt;h4 id=&#34;定位任务&#34;&gt;定位任务&lt;/h4&gt;

&lt;p&gt;在fast R-CNN中，作者使用的是均方误差函数作为定位损失，总的目的是让定位出的坐标点尽可能逼近groundtruth box。本文中为了在定位坐标同时输出定位score，使用了高斯函数建模坐标点的位置分布，公式如下，&lt;/p&gt;

&lt;p&gt;$$
P_\Theta(x) = \frac1{2\pi \sigma^2} e^{-\frac{(x-x_e)^2}{2\sigma^2}}
$$&lt;/p&gt;

&lt;p&gt;其中，$x_e$为预测的box位置，$\sigma$表示box位置的标准差，衡量了box位置的不确定性。因为groundtruth位置是确定的，所以groundtruth box的坐标为标准差为0的高斯分布，也即Dirac delta函数，公式如下，&lt;/p&gt;

&lt;p&gt;$$
P_D(x) = \delta (x-x_g)
$$&lt;/p&gt;

&lt;p&gt;其中，$x_g$ 为groundtruth box的坐标。&lt;/p&gt;

&lt;h4 id=&#34;定位损失&#34;&gt;定位损失&lt;/h4&gt;

&lt;p&gt;回归任务的目的是让预测框尽可能逼近真实框，也即$P_\theta(x)$和$P_D(x)$为同一分布，衡量概率分布的相似性，自然而然会想到KL散度，关于KL散度的概念，大家可以参见维基百科，值得一提的是，KL散度本身具有不对称性，通常，在实际应用中为了使用对称性，使用的是KL散度的变形形式，但本文中没有这么做。对公式做化简后，最终的简化形式如下，&lt;/p&gt;

&lt;p&gt;$$
L_{reg} = \alpha \left( \left( x_g - x_e \right) - \frac12 \right) - \frac12 \log \left( \alpha + \epsilon \right)
$$&lt;/p&gt;

&lt;h4 id=&#34;后处理&#34;&gt;后处理&lt;/h4&gt;

&lt;p&gt;经过上面的网络部分，Class分支会输出类别score，Box分支会输出box的4个坐标和这4个坐标对应的标准差（定位score），符号表示如下，&lt;/p&gt;

&lt;p&gt;$$
\{ x1_i, y1_i, x2_i, y2_i, s_i, \sigma_{x1, i}, \sigma_{y1, i}, \sigma_{x2, i}, \sigma_{y2, i} \}
$$&lt;/p&gt;

&lt;p&gt;基于这些信息，新的后处理算法如下图，&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image/1563351203720.png&#34; alt=&#34;1563351203720&#34; /&gt;&lt;/p&gt;

&lt;p&gt;显然，softer-NMS基于回归出的定位confidence，对所有与$M$的IoU超过阈值$N_t$的proposals，使用加权平均更新其位置坐标，从而达到提高定位精度的目的。因为softer-NMS关注的是单个框的定位精度，而NMS和soft-NMS关注的是单个框的冗余性，显然关注点不同，所以softer-NMS可以和soft-NMS组合使用，此时效果更佳。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;NMS：&lt;/strong&gt;只适用于图片中目标比较稀疏的场景，即目标之间的间距较大；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;soft-NMS：&lt;/strong&gt;可以部分解决出现稠密目标的情况；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;softer-NMS：&lt;/strong&gt;该后处理方法采用&amp;rdquo;bagging&amp;rdquo;的思想，通过后处理提高定位精度，可以和soft-NMS组合使用。&lt;/p&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://blog.csdn.net/diligent_321/article/details/85859462&#34; target=&#34;_blank&#34;&gt;目标检测后处理：从nms到softer nms&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] &lt;a href=&#34;https://arxiv.org/pdf/1704.04503.pdf&#34; target=&#34;_blank&#34;&gt;Improving Object Detection With One Line of Code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] &lt;a href=&#34;https://arxiv.org/pdf/1809.08545.pdf&#34; target=&#34;_blank&#34;&gt;Bounding Box Regression with Uncertainty for Accurate Object Detection&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo Academic 自定义表格样式</title>
      <link>https://YuxinZhaozyx.github.io/post/table-style-of-hugo-academic/</link>
      <pubDate>Tue, 16 Jul 2019 16:39:48 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/table-style-of-hugo-academic/</guid>
      <description>&lt;p&gt;Hugo Academic主题自带的表格样式个人感觉不是特别美观，我更喜欢GitHub的表格样式，因此我花了点时间将Hugo Academic主题的表格样式改成GitHub的样式。&lt;/p&gt;

&lt;p&gt;在hugo建立的根目录下创建目录&lt;code&gt;assets/css/&lt;/code&gt;，再在新创建的目录下创建&lt;code&gt;custom.css&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd &amp;lt;your-hugo-website&amp;gt;
$ mkdir -p assets/css/
$ vi assets/css/custom.css
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;custom.css&lt;/code&gt;中添加以下样式代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;table {
    display: block;
    overflow: auto;
    width: 100%;
}
table tr {
    background-color: #fff;
    border-top: 1px solid #c6cbd1;
}
table tr:nth-child(even) {
    background-color: #f6f8fa; 
}
table tr:nth-child(odd)  {
    background-color: #fff; 
}
table&amp;gt;tbody&amp;gt;tr:nth-child(odd)&amp;gt;td, table&amp;gt;tbody&amp;gt;tr:nth-child(odd)&amp;gt;th {
    background-color: #fff;
}
table&amp;gt;thead&amp;gt;tr&amp;gt;th, table&amp;gt;tbody&amp;gt;tr&amp;gt;th, table&amp;gt;tfoot&amp;gt;tr&amp;gt;th, table&amp;gt;thead&amp;gt;tr&amp;gt;td, table&amp;gt;tbody&amp;gt;tr&amp;gt;td, table&amp;gt;tfoot&amp;gt;tr&amp;gt;td {
    padding: 6px 13px;
}
table th {
    font-weight: 600;
}
table th, td  {
    vertical-align: middle !important;
    text-align: center;
    border: 1px solid #dfe2e5;
    padding: 6px 13px;
}
table img {
    background-color: transparent;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将&lt;code&gt;config/_default/params.toml&lt;/code&gt;中的&lt;code&gt;plugins_css&lt;/code&gt;设置为&lt;code&gt;[&amp;quot;custom&amp;quot;]&lt;/code&gt;，即&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;plugins_css = [&amp;quot;custom&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表格样式修改完成。&lt;/p&gt;

&lt;p&gt;该表格样式会将内容水平和垂直居中，并且单双行不同色。&lt;/p&gt;

&lt;p&gt;附带表格样式的效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image/1563267815215.png&#34; alt=&#34;1563267815215&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PR/ROC曲线及其相关性能评价指标</title>
      <link>https://YuxinZhaozyx.github.io/post/pr-roc/</link>
      <pubDate>Mon, 15 Jul 2019 21:05:58 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/pr-roc/</guid>
      <description>

&lt;p&gt;在分类模型的评价标准中，PR曲线和ROC曲线被广泛应用于模型的性能评估。本文对PR曲线和ROC曲线及其相关的性能指标AUC, EER, AP, mAP, F1-measure进行介绍。&lt;/p&gt;

&lt;h2 id=&#34;混淆矩阵-confusion-matrix&#34;&gt;混淆矩阵 Confusion Matrix&lt;/h2&gt;

&lt;table align=&#34;center&#34; style= &#34;vertical-align: middle;&#34;&gt;
    &lt;tr&gt;
        &lt;th colspan=&#34;2&#34; rowspan=&#34;2&#34;&gt;&lt;/td&gt;
        &lt;th colspan=&#34;2&#34;&gt;Truth&lt;/td&gt;
        &lt;th rowspan=&#34;2&#34;&gt; $\sum$ &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;1&lt;/td&gt;
        &lt;th&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th rowspan=&#34;2&#34;&gt; Estimate &lt;/td&gt;
        &lt;th&gt; 1&lt;/td&gt;
        &lt;td&gt; TP &lt;/td&gt;
        &lt;td&gt; FP &lt;/td&gt;
        &lt;td&gt; TP+FP &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt; 0 &lt;/td&gt;
        &lt;td&gt; FN &lt;/td&gt;
        &lt;td&gt; TN &lt;/td&gt;
        &lt;td&gt; FN+TN &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th colspan=&#34;2&#34;&gt; $\sum$ &lt;/td&gt;
        &lt;td&gt; TP+FN &lt;/td&gt;
        &lt;td&gt; FP+TN &lt;/td&gt;
        &lt;td&gt; TP+TN+FP+FN &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;真正例 (True Positive, TP): 预测值和真实值都为1&lt;/li&gt;
&lt;li&gt;假正例 (False Positive, FP): 预测值为1，真实值都为0&lt;/li&gt;
&lt;li&gt;真反例 (True Negative, TN): 预测值和真实值都为0&lt;/li&gt;
&lt;li&gt;假反例 (False Negative, FN): 预测值为0，真实值都为1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由这四个指标衍生出的指标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查准率/准确率:                       $ \text{Precision} = \frac{TP}{TP+FP} $&lt;/li&gt;
&lt;li&gt;查全率/召回率:                       $\text{Recall} = \frac{TP}{TP+FN}$&lt;/li&gt;
&lt;li&gt;真阳率(True Positive Rate): $\text{TPR} = \frac{TP}{TP+FN}$&lt;/li&gt;
&lt;li&gt;假阳率(False Positive Rate): $\text{FPR} = \frac{FP}{FP+TN}$&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;roc曲线&#34;&gt;ROC曲线&lt;/h2&gt;

&lt;h3 id=&#34;roc定义&#34;&gt;ROC定义&lt;/h3&gt;

&lt;p&gt;ROC曲线(Receiver Operating Characteristic Curve, 受试者工作特征曲线)是比较分类模型好坏的可视化工具。&lt;/p&gt;

&lt;p&gt;以FPR为x轴，TPR为y轴绘制图。如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image/ROC.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;roc曲线的衍生指标&#34;&gt;ROC曲线的衍生指标&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;EER(equal error rate): TPR=FPR时的值。&lt;/li&gt;
&lt;li&gt;AUC(area under curve): ROC曲线下的面积&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;pr曲线&#34;&gt;PR曲线&lt;/h2&gt;

&lt;h3 id=&#34;pr定义&#34;&gt;PR定义&lt;/h3&gt;

&lt;p&gt;PR曲线中P是Precision, R是Recall。&lt;/p&gt;

&lt;p&gt;以Recall为x轴，Precision为y轴。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image/38381443447279.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;假设一次Object Detection的结果为：&lt;/strong&gt;（对于目标检测任务，当预测框与真实框&lt;a href=&#34;https://YuxinZhaozyx.github.io/post/what-is-iou&#34;&gt;IoU&lt;/a&gt;大于一定阈值时标记为TP；当预测框与真实框IoU小于一定阈值时标记为FP；一个真实框没有一个任何预测框与其重叠的为FN）
&lt;img src=&#34;image/samples_1_v2.png&#34; alt=&#34;img&#34; /&gt;
&lt;img src=&#34;image/table_1_v2.png&#34; alt=&#34;img&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对其confidence进行排序:&lt;/strong&gt;
&lt;img src=&#34;image/table_2_v2.png&#34; alt=&#34;img&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据上表的顺序绘制PR曲线：&lt;/strong&gt;
&lt;img src=&#34;image/precision_recall_example_1_v2.png&#34; alt=&#34;img&#34; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至此我们得到了一张PR图。&lt;/p&gt;

&lt;h3 id=&#34;pr图的衍生指标&#34;&gt;PR图的衍生指标&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;AP (Average Precision)&lt;/li&gt;
&lt;li&gt;mAP (mean Average Precision)&lt;/li&gt;
&lt;li&gt;F1-measure 综合评价指标&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面给出AP, mAP和F-measure的计算方法&lt;/p&gt;

&lt;h4 id=&#34;计算ap&#34;&gt;计算AP&lt;/h4&gt;

&lt;p&gt;AP 是针对某一类别进行计算的。&lt;/p&gt;

&lt;p&gt;下面我们先从图的角度来理解AP。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在2010年前，AP的计算方法是用11点插值法(11-point interpolation)&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;分别取 recall = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0] 十一个点插值，对每一个插值recall取 recall&amp;rsquo; &amp;gt;= recall 的点中precision最大的值作为该插值recall对应的precision。&lt;/p&gt;

&lt;p&gt;计算公式为:
$$
P_{\text{interpolation}} (r) = \max_{r&amp;rsquo; \ge r}\left(P(r&amp;rsquo;)\right)
$$&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image/11-pointInterpolation.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;计算这11个插值recall对应precision的均值即是AP。
$$
\begin{align}
AP &amp;amp;= \frac1{11} \sum_{r \in \{0,0.1,&amp;hellip;,1\}} P_{\text{interpolation}} (r) \\&lt;br /&gt;
&amp;amp;= \frac1{11} \left( 1 + 0.6666 + 0.4285 + 0.4285 + 0.4285 + 0 + 0 + 0 + 0 + 0 + 0  \right) \\&lt;br /&gt;
&amp;amp;= 26.84\%
\end{align}
$$
&lt;strong&gt;2010年后，AP的计算方法不再使用11点插值法，而是考虑所有的点&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;对所有Recall值，将Recall大于等于该Recall值的所有点中的最大precision作为该recall值对应的precision。公式仍是
$$
P_{\text{interpolation}} (r) = \max_{r&amp;rsquo; \ge r}\left(P(r&amp;rsquo;)\right)
$$
不同点在于AP的计算公式:
$$
AP = \int_0^1 P_{\text{interpolation}}(r) \, dr
$$
可以画出图帮助理解：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image/interpolated_precision_v2.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image/interpolated_precision-AUC_v2.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;按照上面的计算公式，则AP为：
$$
\begin{align}
A1 &amp;amp;= (0.0666 - 0) \times 1 = 0.0666 \\&lt;br /&gt;
A2 &amp;amp;= (0.1333-0.0666) \times 0.6666 = 0.04446222 \\&lt;br /&gt;
A3 &amp;amp;= (0.4-0.1333) \times 0.4285 = 0.11428095 \\&lt;br /&gt;
A4 &amp;amp;= (0.4666 - 0.4) \times 0.3043 = 0.02026638 \\&lt;br /&gt;
\\&lt;br /&gt;
AP &amp;amp;= A1+A2+A3+A4 \\&lt;br /&gt;
&amp;amp;= 0.0666 + 0.04446222 + 0.11428095 + 0.02026638 \\&lt;br /&gt;
&amp;amp;= 0.24560955 \\&lt;br /&gt;
&amp;amp;= 24.56\%
\end{align}
$$
以后的AP计算我会以2010年后的版本为准。&lt;/p&gt;

&lt;p&gt;接下来我将演示&lt;strong&gt;用表格来计算AP&lt;/strong&gt;，而不使用绘图的方式：&lt;/p&gt;

&lt;p&gt;按Confidence置信度来降序做出表格:&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Detection&lt;/th&gt;
        &lt;th&gt;Precision&lt;/th&gt;
        &lt;th&gt;Recall&lt;/th&gt;
        &lt;th&gt;Max Precision for Any Recall $r&#39; \ge r$&lt;/th&gt;
        &lt;th&gt;Average Precision&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;R&lt;/td&gt;
        &lt;td&gt;1&lt;/td&gt;
        &lt;td rowspan=&#34;2&#34;&gt;0.0666&lt;/td&gt;
        &lt;td rowspan=&#34;2&#34;&gt;1&lt;/td&gt;
        &lt;td rowspan=&#34;24&#34;&gt;24.56%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Y&lt;/td&gt;
        &lt;td&gt;0.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;J&lt;/td&gt;
        &lt;td&gt;0.6666&lt;/td&gt;
        &lt;td rowspan=&#34;7&#34;&gt;0.1333&lt;/td&gt;
        &lt;td rowspan=&#34;7&#34;&gt;0.6666&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;A&lt;/td&gt;
        &lt;td&gt;0.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;U&lt;/td&gt;
        &lt;td&gt;0.4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;C&lt;/td&gt;
        &lt;td&gt;0.3333&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;M&lt;/td&gt;
        &lt;td&gt;0.2857&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;F&lt;/td&gt;
        &lt;td&gt;0.25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;D&lt;/td&gt;
        &lt;td&gt;0.2222&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;B&lt;/td&gt;
        &lt;td&gt;0.3&lt;/td&gt;
        &lt;td rowspan=&#34;2&#34;&gt;0.2&lt;/td&gt;
        &lt;td rowspan=&#34;13&#34;&gt;0.4285&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;H&lt;/td&gt;
        &lt;td&gt;0.2727&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;P&lt;/td&gt;
        &lt;td&gt;0.3333&lt;/td&gt;
        &lt;td&gt;0.2666&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;E&lt;/td&gt;
        &lt;td&gt;0.3846&lt;/td&gt;
        &lt;td&gt;0.3333&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;X&lt;/td&gt;
        &lt;td&gt;0.4285&lt;/td&gt;
        &lt;td rowspan=&#34;9&#34;&gt;0.4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;N&lt;/td&gt;
        &lt;td&gt;0.4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;T&lt;/td&gt;
        &lt;td&gt;0.375&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;K&lt;/td&gt;
        &lt;td&gt;0.3529&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Q&lt;/td&gt;
        &lt;td&gt;0.3333&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;V&lt;/td&gt;
        &lt;td&gt;0.3157&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;I&lt;/td&gt;
        &lt;td&gt;0.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;L&lt;/td&gt;
        &lt;td&gt;0.2857&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;S&lt;/td&gt;
        &lt;td&gt;0.2727&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;G&lt;/td&gt;
        &lt;td&gt;0.3043&lt;/td&gt;
        &lt;td rowspan=&#34;2&#34;&gt;0.4666&lt;/td&gt;
        &lt;td rowspan=&#34;2&#34;&gt;0.3043&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;O&lt;/td&gt;
        &lt;td&gt;0.2916&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;计算方法和原理同上，但画出表格可以直接计算AP:
$$
\begin{align}
AP &amp;amp;= 1 \times 0.0666 + 0.6666 \times (0.1333-0.0666) + 0.4285 \times(0.4-0.1333) + 0.3043 \times(0.4666 - 0.4) \\&lt;br /&gt;
&amp;amp;= 0.24560955
\end{align}
$$&lt;/p&gt;

&lt;h4 id=&#34;计算map&#34;&gt;计算mAP&lt;/h4&gt;

&lt;p&gt;mAP的全程是mean Average Precision，即是所有AP的均值。因为AP只是正对一类的准确率进行评估，而在多类别检测/分类任务中就需要一个指标来对整个多分类任务的性能进行评估，这就是mAP。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;计算公式&lt;/strong&gt;:
$$
mAP = \frac{\sum_c AP_c}{N_{class}}
$$&lt;/p&gt;

&lt;h4 id=&#34;计算f1-measure综合评价指标&#34;&gt;计算F1-measure综合评价指标&lt;/h4&gt;

&lt;p&gt;F-measure又称F-Score，是Precision和Recall的加权调和平均，常用于评价分类模型的好坏。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;计算公式&lt;/strong&gt;:
$$
F_\alpha = \frac{(\alpha^2+1)\text{Precision}\times\text{Recall}}{\alpha^2 \text{Precision} + \text{Recall}}
$$&lt;/p&gt;

&lt;p&gt;常见的&lt;strong&gt;F$_1$-measure&lt;/strong&gt;即为F-measure中$\alpha=1$的特例:
$$
F_1 = \frac{2 \times \text{Precision}\times\text{Recall}}{\text{Precision} + \text{Recall}}
$$&lt;/p&gt;

&lt;p&gt;该公式的另外一种形式可以帮助记忆:
$$
\frac2{F_1} = \frac1{\text{Precision}} + \frac1{\text{Recall}}
$$&lt;/p&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://github.com/rafaelpadilla/Object-Detection-Metrics&#34; target=&#34;_blank&#34;&gt;rafaelpadilla/Object-Detection-Metrics&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] &lt;a href=&#34;https://www.zhihu.com/question/53405779&#34; target=&#34;_blank&#34;&gt;目标检测中的mAP是什么含义?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] &lt;a href=&#34;http://blog.sina.com.cn/s/blog_9db078090102whzw.html&#34; target=&#34;_blank&#34;&gt;多标签图像分类任务的评价方法-mAP&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>What is IoU?</title>
      <link>https://YuxinZhaozyx.github.io/post/what-is-iou/</link>
      <pubDate>Mon, 15 Jul 2019 20:20:32 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/what-is-iou/</guid>
      <description>&lt;p&gt;在目标检测任务中常常用IoU来计算预测窗口与真实窗口的交叠率。本文介绍IoU的概念。&lt;/p&gt;

&lt;p&gt;IoU (Intersection over Union, 交并比) 是两个窗口的交集与并集面积之比。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;区域 Region-1 与 Region-2 的交集如上图黄色区域&lt;/li&gt;
&lt;li&gt;区域 Region-1 与 Region-2 的并集如上图绿色区域&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;IoU计算公式&lt;/strong&gt;:
$$
IoU = \frac{\text{Region-1} \cap \text{Region-2}}{\text{Region-1} \cup \text{Region-2}}
$$&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>What is RoI Pooling?</title>
      <link>https://YuxinZhaozyx.github.io/post/what-is-roi-pooling/</link>
      <pubDate>Mon, 15 Jul 2019 11:52:13 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/what-is-roi-pooling/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://YuxinZhaozyx.github.io/post/what-is-roi/&#34;&gt;上文&lt;/a&gt;讲了什么是RoI(Region of Interest, 感兴趣区域)，本文讲述RoI Pooling的概念。&lt;/p&gt;

&lt;h3 id=&#34;roi-pooling-的作用&#34;&gt;RoI Pooling 的作用&lt;/h3&gt;

&lt;p&gt;RoI Pooling是Pooling(池化)的一种，而且是针对RoI的池化。它的作用是&lt;strong&gt;输入尺寸不固定的特征图，输出尺寸固定的特征图&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;roi-pooling-的输入&#34;&gt;RoI Pooling 的输入&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;特征图 feature map&lt;/strong&gt;：由原图像通过CNN计算得到的特征图&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;感兴趣区域 RoI&lt;/strong&gt;: 许多候选框，形状为$1 \times 5 \times 1$ (4 个坐标[x,y,w,h] + 索引[index])&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;strong&gt;RoI的坐标的参考系是原图(CNN的输入)&lt;/strong&gt;，而不是feature map。
  &lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&#34;roi-pooling-的输出&#34;&gt;RoI Pooling 的输出&lt;/h3&gt;

&lt;p&gt;输出batch个张量，其中batch的值等于RoI的个数，张量大小为(channel, w, h)， w和h人为指定。RoI Pooling的过程就是将一个个尺寸不同的RoI都映射成大小固定的(w, h)的RoI。&lt;/p&gt;

&lt;h2 id=&#34;图解-roi-pooling&#34;&gt;图解 RoI Pooling&lt;/h2&gt;

&lt;p&gt;考虑一个 $8 \times 8$ 大小的feature map，一个RoI，以及输出大小为 $2 \times 2$.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;输入固定大小的feature map&lt;/strong&gt;
&lt;img src=&#34;image/input-feature-map.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;region proposal 投影后的位置&lt;/strong&gt;
&lt;img src=&#34;image/region-proposal.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将其划分为 $(2 \times 2)$ 个sections (因为输出大小为$2 \times 2$)&lt;/strong&gt;
&lt;img src=&#34;image/max-pooling-sections.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对每个section做max pooling，可以得到:&lt;/strong&gt;
&lt;img src=&#34;image/roi-pooling-result.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;参考引用&#34;&gt;参考引用&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://deepsense.ai/region-of-interest-pooling-explained/&#34; target=&#34;_blank&#34;&gt;Region of interest pooling explained&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] &lt;a href=&#34;https://blog.csdn.net/lanran2/article/details/60143861&#34; target=&#34;_blank&#34;&gt;ROI Pooling层解析&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>What is RoI?</title>
      <link>https://YuxinZhaozyx.github.io/post/what-is-roi/</link>
      <pubDate>Mon, 15 Jul 2019 11:07:26 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/what-is-roi/</guid>
      <description>

&lt;h2 id=&#34;roi概念&#34;&gt;RoI概念&lt;/h2&gt;

&lt;p&gt;RoI的全称是Region of Interest，中文名称是&amp;rdquo;感兴趣区域&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;RoI是从图像中选择的一个图像区域，这个区域是你进行图像分析的重点。圈出这块区域可以得到一个子图像(subimage)，之后就可以在这个区域内使用进行进一步处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;目的：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;减少处理时间&lt;/li&gt;
&lt;li&gt;增加精度&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[论文笔记] Faster R-CNN: Towards Real-Time Object Detection With Region Proposal Networks</title>
      <link>https://YuxinZhaozyx.github.io/paper-note/faster-r-cnn-towards-real-time-object-detection-with-region-proposal-networks/</link>
      <pubDate>Sun, 14 Jul 2019 13:40:12 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/paper-note/faster-r-cnn-towards-real-time-object-detection-with-region-proposal-networks/</guid>
      <description>

&lt;p&gt;Faster R-CNN在Fast R-CNN的基础上做改进，提出用RPN（Region Proposal Network, 一种全卷积神经网络）代替Selective Search，降低检测耗时。Faster R-CNN由RPN和Fast R-CNN构成，RPN和Fast R-CNN共享卷积计算得到的特征图，以此降低计算量，使得Faster R-CNN可以在单GPU上以5fps的速度运行，且精度达到SOTA。&lt;/p&gt;

&lt;h3 id=&#34;术语缩写&#34;&gt;术语缩写&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;缩写&lt;/th&gt;
&lt;th&gt;全称&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;R-CNN&lt;/td&gt;
&lt;td&gt;Region Convolution Neural Network&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RPN&lt;/td&gt;
&lt;td&gt;Region Proposal Network&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;FCN&lt;/td&gt;
&lt;td&gt;Fully Convolutional Network&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SS&lt;/td&gt;
&lt;td&gt;Selective Search&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZF&lt;/td&gt;
&lt;td&gt;Zeiler and Fergus model&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;IoU&lt;/td&gt;
&lt;td&gt;Intersection-over-Union&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RoI&lt;/td&gt;
&lt;td&gt;Region of Interest&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;faster-r-cnn&#34;&gt;Faster R-CNN&lt;/h2&gt;







&lt;figure&gt;

&lt;img src=&#34;image/1563085747876.png&#34; &gt;



&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
  &lt;h4&gt;Faster R-CNN is a single, unified network for object detection. The RPN module serves as the &amp;lsquo;attention&amp;rsquo; of the unified network.&lt;/h4&gt;
  
&lt;/figcaption&gt;

&lt;/figure&gt;


&lt;p&gt;Faster R-CNN 由以下两个部分组成:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Deep fully convolutional network that proposes regions&lt;/li&gt;
&lt;li&gt;Fast R-CNN detector that uses the proposed regions&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    The RPN module tells the Fast R-CNN module where to look.
  &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;region-proposal-network&#34;&gt;Region Proposal Network&lt;/h2&gt;







&lt;figure&gt;

&lt;img src=&#34;image/1563086507733.png&#34; &gt;



&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
  &lt;h4&gt;Region Proposal Network&lt;/h4&gt;
  
&lt;/figcaption&gt;

&lt;/figure&gt;


&lt;p&gt;A Region Proposal Network (RPN) takes an image (of any size) as input and outputs a set of rectangular object proposals, each with an objectness score.&lt;/p&gt;

&lt;p&gt;The authors model this process with a &lt;strong&gt;fully convolutional network&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;To generate region proposals, the authors &lt;strong&gt;slide a small network($n \times n$ spatial window, $n=3$) over the convolutional feature map&lt;/strong&gt; output by the last shared convolution layer.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Each sliding window is mapped to a lower-dimensional feature (256-d for ZF and 512-d for VGG, with ReLU following).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This feature is &lt;strong&gt;fed into two sibling fully-connected layers&lt;/strong&gt; &amp;ndash; a &lt;strong&gt;box-regression layer&lt;/strong&gt; ($reg$) and a &lt;strong&gt;box-classification layer&lt;/strong&gt; ($cls$). This architecture is naturally implemented with and $n \times n$ convolutional layer followed by two sibling $1 \times 1$ convolutional layers (for $reg$ and $cls$ respectively).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;anchor&#34;&gt;Anchor&lt;/h3&gt;

&lt;p&gt;the number of maximum possible proposals for each location is denoted as $k$.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$reg$ layer has $4k$ outputs $(x, y, w, h)$ encoding the coordinates of $k$ boxes&lt;/li&gt;
&lt;li&gt;$cls$ layer has $2k$ outputs scores that estimate probability of object or not object for each proposal. (implemented as a two-class softmax layer)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The $k$ proposals are parameterized relative to $k$ reference boxes, which we call &lt;strong&gt;anchors&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An anchor is centered at the sliding window in question, and is associated  with &lt;strong&gt;a scale and aspect ratio&lt;/strong&gt; (宽高比).&lt;/li&gt;
&lt;li&gt;For a convolutional feature map of a size $W \times H $ , there are $WHk$ anchors in total.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;use 3 scales with box areas of $128^2$, $256^2$, $512^2$ pixels, and 3 aspect ratios of 1:1, 1:2, 2:1.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image/1563093098483.png&#34; alt=&#34;1563093098483&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;multi-scale-anchors-as-regression-reference&#34;&gt;Multi-Scale Anchors as Regression Reference&lt;/h4&gt;







&lt;figure&gt;

&lt;img src=&#34;image/1563088410857.png&#34; &gt;



&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; class=&#34;numbered&#34;&gt;
  &lt;h4&gt;Different schemes for addressing multiple scales and sizes.&lt;/h4&gt;
  
&lt;/figcaption&gt;

&lt;/figure&gt;


&lt;p&gt;作者采取b)和c)变化窗口形状和大小的方法，而不使用a)变换图片大小的方法。&lt;/p&gt;

&lt;h3 id=&#34;lost-function&#34;&gt;Lost Function&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Positive anchor&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the anchor/anchors with the highest Intersection-over-Union(IoU) overlap with a ground-truth box (作者采用).&lt;/li&gt;
&lt;li&gt;an anchor that has an IoU overlap &amp;gt; 0.7 with any grouth-truth box (作者不采用).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Negative anchor&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;non-positive anchor if its IoU &amp;lt; 0.3 for all grouth-truth boxes.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;lost-function-for-an-image&#34;&gt;lost  function for an image&lt;/h4&gt;

&lt;p&gt;$$
L(\{p_i\}, \{t_i\}) = \frac1{N_{cls}} \sum_i{L_{cls}} (p_i, p_i^*) + \lambda \frac{1}{N_{reg}} \sum_i {L_{reg}(t_i, t_i^*)}
$$&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$L_{cls}$ is log loss over two classes (object $vs.$ not object)&lt;/li&gt;
&lt;li&gt;$L_{reg}(t_i, t_i^*) = R(t_i - t_i^*)$ where $R$ is the robust loss function (smooth $L_1$)&lt;/li&gt;
&lt;li&gt;$N_{cls}$ is the mini-batch size (i.e., $N_{cls}=256$)&lt;/li&gt;
&lt;li&gt;$N_{reg}$ is the number of anchor locations (i.e., $N_{reg} \approx 2400$)&lt;/li&gt;
&lt;li&gt;$\lambda = 10$ and thus both $cls$ and $reg$ terms are roughly equally weighted.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    The normalization as above is not required and could be simplified.
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;$$
\begin{align}
&amp;amp;t_x = (x-x_a)/w_a, &amp;amp; t_y = (y-y_a)/h_a, \\&lt;br /&gt;
&amp;amp;t_w = \log(w/w_a), &amp;amp; t_h = log(h/h_a),  \\&lt;br /&gt;
&amp;amp;t^*_x = (x-x^*_a)/w_a, &amp;amp; t^*_y = (y^*-y_a)/h_a, \\&lt;br /&gt;
&amp;amp;t^*_w = \log(w^*/w_a), &amp;amp; t^*_h = log(h^*/h_a),  \\&lt;br /&gt;
\end{align}
$$&lt;/p&gt;

&lt;h4 id=&#34;training-rpns&#34;&gt;Training RPNs&lt;/h4&gt;

&lt;p&gt;The RPN can be trained &lt;strong&gt;end-to-end&lt;/strong&gt; by back-propagation and &lt;strong&gt;stochastic gradient descent (SGD)&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一张图片包含多个正样本和负样本(正样本少于负样本)&lt;/li&gt;
&lt;li&gt;随机采样256个样本用于计算loss of a mini-batch&lt;/li&gt;
&lt;li&gt;初始化: Gaussian distribution (mean=0, standard deviation=0.01)&lt;/li&gt;
&lt;li&gt;momentum: 0.9,   weight decay: 0.0005&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sharing-features-for-rpn-and-fast-r-cnn&#34;&gt;Sharing Features for RPN and Fast R-CNN&lt;/h2&gt;

&lt;h3 id=&#34;4-step-alternating-training&#34;&gt;4 - Step Alternating Training&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Train the RPN as described previously.&lt;/li&gt;
&lt;li&gt;Train a separated detection network (ImageNet-pre-trained) by Fast R-CNN using the proposals generated by step-1 RPN.&lt;/li&gt;
&lt;li&gt;Use the detector network to initialize RPN training, but fix the shared convolutional layers and only fine-tune the layers unique to RPN.&lt;/li&gt;
&lt;li&gt;keeping the shared convolutional layers fixed, fine-tune the unique layers of Fast R-CNN.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Hugo Academic Icon配置</title>
      <link>https://YuxinZhaozyx.github.io/post/icons-of-hugo-academic/</link>
      <pubDate>Fri, 12 Jul 2019 11:45:33 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/icons-of-hugo-academic/</guid>
      <description>

&lt;p&gt;Academic主题可以使用&lt;a href=&#34;https://fontawesome.com/icons?d=gallery&#34; target=&#34;_blank&#34;&gt;Font Awesome&lt;/a&gt;和&lt;a href=&#34;https://jpswalsh.github.io/academicons/&#34; target=&#34;_blank&#34;&gt;Academicons&lt;/a&gt;的各种图标。但是Academic本身支持的版本不一定是最新的，部分图标因此不会显示。因此本文将介绍如何更换成最新的、速度更快的源。&lt;/p&gt;

&lt;h2 id=&#34;icon包简要介绍&#34;&gt;icon包简要介绍&lt;/h2&gt;

&lt;p&gt;icon包&lt;code&gt;fab&lt;/code&gt;包括以下&lt;strong&gt;品牌&lt;/strong&gt;图标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;twitter，weixin，weibo，linkedin，github，facebook，pinterest，twitch，youtube，instagram，soundcloud&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://fontawesome.com/icons?d=gallery&amp;amp;s=brands&#34; target=&#34;_blank&#34;&gt;查看所有图标&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;icon包&lt;code&gt;fas&lt;/code&gt;和&lt;code&gt;far&lt;/code&gt;包括以下&lt;strong&gt;常规&lt;/strong&gt;图标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;传真，信封（电子邮件），评论（论坛）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://fontawesome.com/icons?d=gallery&amp;amp;s=regular,solid&#34; target=&#34;_blank&#34;&gt;查看所有图标&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;icon包&lt;code&gt;ai&lt;/code&gt;包括以下&lt;strong&gt;学术&lt;/strong&gt;图标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cv，google-scholar，arxiv，orcid，researchgate，mendeley&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jpswalsh.github.io/academicons/&#34; target=&#34;_blank&#34;&gt;查看所有图标&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;在hugo-academic中使用图标&#34;&gt;在Hugo-Academic中使用图标&lt;/h2&gt;

&lt;p&gt;以python图标为例，在&lt;a href=&#34;https://fontawesome.com/icons?d=gallery&amp;amp;q=python&#34; target=&#34;_blank&#34;&gt;Font Awesome&lt;/a&gt;中找到python的编号为“fab fa-python&amp;rdquo;。&lt;/p&gt;

&lt;h3 id=&#34;在skills面板中使用图标&#34;&gt;在skills面板中使用图标：&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;/content/home/skills.md&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[feature]]
    icon=&amp;quot;python&amp;quot;
    icon_pack=&amp;quot;fab&amp;quot;
    name=&amp;quot;Python&amp;quot;
    description=&amp;quot;80%&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;在about面板中使用图标&#34;&gt;在about面板中使用图标：&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;/content/authors/&amp;lt;author-name&amp;gt;/_index.md&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;social:
- icon: python
  icon_pack: fab
  link: &amp;quot;...&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    注意: &lt;code&gt;icon&lt;/code&gt;的值不是完整的编号，要去除&lt;code&gt;fa-&lt;/code&gt;前缀。
  &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;更换hugo-academic主题使用的font-awesome源&#34;&gt;更换Hugo-Academic主题使用的Font Awesome源&lt;/h2&gt;

&lt;p&gt;我们将使用Font Awesome的最新版本5.9.0(截至至2019年7月10日)来代替Academic默认使用的5.6.0版本。&lt;/p&gt;

&lt;p&gt;我使用&lt;a href=&#34;https://cdnjs.com/libraries/font-awesome&#34; target=&#34;_blank&#34;&gt;cdnjs&lt;/a&gt;提供的CDN源，点击&lt;a href=&#34;https://cdnjs.com/libraries/font-awesome&#34; target=&#34;_blank&#34;&gt;此处&lt;/a&gt;查看当前最新版本。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image/cdnjs-font-awesome.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;分别复制url和sri。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image/cdnjs-font-awesome-copy.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;修改到&lt;code&gt;themes/academic/data/assets.toml&lt;/code&gt;中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[css.fontAwesome]
  version = &amp;quot;5.9.0&amp;quot;
  sri = &amp;quot;sha256-PF6MatZtiJ8/c9O9HQ8uSUXr++R9KBYu4gbNG5511WE=&amp;quot;
  url = &amp;quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/%s/css/all.css&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新完成。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo博客集成Gitalk评论模块</title>
      <link>https://YuxinZhaozyx.github.io/post/gitalk-in-hugo/</link>
      <pubDate>Tue, 09 Jul 2019 16:40:32 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/gitalk-in-hugo/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&#34;https://YuxinZhaozyx.github.io/post/gitment-in-hugo&#34;&gt;先前的文章&lt;/a&gt;中，我使用Gitment来作为我的博客的评论模块，但使用一段时间后发现了Gitment的一些缺点，针对这些缺点，我找到了比Gitment功能上更完善的Gitalk。&lt;/p&gt;

&lt;h2 id=&#34;我为什么选择gitalk&#34;&gt;我为什么选择Gitalk?&lt;/h2&gt;

&lt;p&gt;在这之前我先说一下我为什么弃坑Gitment，Gitment本身的想法很好，使用github的issue来存储评论，避免了使用第三方的服务而第三方停止提供服务的风险(比如多说和网易云跟帖)。但它也有以下缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不兼容移动端&lt;/li&gt;
&lt;li&gt;不支持多语言&lt;/li&gt;
&lt;li&gt;不支持免打扰模式&lt;/li&gt;
&lt;li&gt;不支持快捷键提交&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述问题中对我来说最重要并最终让我决定更换评论模块的是Gitment不兼容移动端的缺点。&lt;/p&gt;

&lt;p&gt;而Gitalk没有以上的缺点。&lt;/p&gt;

&lt;h2 id=&#34;gitalk评论模块介绍&#34;&gt;Gitalk评论模块介绍&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gitalk/gitalk&#34; target=&#34;_blank&#34;&gt;项目地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitalk.github.io/&#34; target=&#34;_blank&#34;&gt;官方示例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;特性&#34;&gt;特性&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用 GitHub 登录&lt;/li&gt;
&lt;li&gt;支持多语言 [en, zh-CN, zh-TW, es-ES, fr, ru]&lt;/li&gt;
&lt;li&gt;支持个人或组织&lt;/li&gt;
&lt;li&gt;免干扰模式（设置 &lt;code&gt;distractionFreeMode&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 开启）&lt;/li&gt;
&lt;li&gt;快捷键提交评论 （&lt;code&gt;ctrl + enter&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;支持移动端&lt;/li&gt;
&lt;li&gt;自动初始化评论&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;基本使用&#34;&gt;基本使用&lt;/h2&gt;

&lt;h3 id=&#34;注册oauth-application&#34;&gt;注册OAuth Application&lt;/h3&gt;

&lt;p&gt;需要先在github上注册一个OAuth Application，&lt;a href=&#34;https://github.com/settings/applications/new&#34; target=&#34;_blank&#34;&gt;点击此处&lt;/a&gt;注册。&lt;/p&gt;

&lt;p&gt;Callback URL 填写评论页面对应的域名，如&lt;code&gt;https://YuxinZhaozyx.github.io&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    其他内容可以随便写，但Callback URL一定要填写正确。
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;注册成功后会得到一个Client ID和Client Secret，这将被用于之后的用户登录认证。&lt;/p&gt;

&lt;h3 id=&#34;引入gitalk&#34;&gt;引入Gitalk&lt;/h3&gt;

&lt;p&gt;将以下代码添加到你的页面：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;section id=&amp;quot;comments&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;gitalkContainer&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&amp;quot;&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
        var gitalk = new Gitalk({
            clientID: &#39;GitHub Application Client ID&#39;,
            clientSecret: &#39;GitHub Application Client Secret&#39;,
            repo: &#39;GitHub repo&#39;,
            owner: &#39;GitHub repo owner&#39;,
            admin: [&#39;GitHub repo owner and collaborators, only these guys can initialize github issues&#39;],
            id: location.pathname,      // Ensure uniqueness and length less than 50
            distractionFreeMode: false  // Facebook-like distraction free mode
        });
        gitalk.render(&#39;gitalkContainer&#39;);
    &amp;lt;/script&amp;gt;
&amp;lt;/section&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    &lt;code&gt;id&lt;/code&gt;的长度要限制在50个字符内，但也不可为空字符串。
  &lt;/div&gt;
&lt;/div&gt;

&lt;h4 id=&#34;参数说明&#34;&gt;参数说明&lt;/h4&gt;

&lt;p&gt;&lt;style type=&#34;text/css&#34;&gt;
    table.tableizer-table {
        font-size: 12px;
        table-layout: fixed;
        width: 100%;
        border-collapse: collapse;
    }
&lt;/style&gt;
&lt;table class=&#34;tableizer-table&#34;&gt;
&lt;thead&gt;
    &lt;tr class=&#34;tableizer-firstrow&#34;&gt;
        &lt;th&gt;参数&lt;/th&gt;
        &lt;th&gt;类型&lt;/th&gt;
        &lt;th&gt;可选&lt;/th&gt;
        &lt;th&gt;说明&lt;/th&gt;
        &lt;th&gt;默认值&lt;/th&gt;
    &lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;clientID&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;no&lt;/td&gt;
        &lt;td&gt;GitHub Application Client ID&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;null&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;clientSecret&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;no&lt;/td&gt;
        &lt;td&gt;GitHub Application Client Secret&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;null&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;repo&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;no&lt;/td&gt;
        &lt;td&gt;存放评论的gitHub仓库&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;null&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;owner&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;no&lt;/td&gt;
        &lt;td&gt;存放评论的gitHub仓库的所有者&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;null&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;admin&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;Array&lt;/td&gt;
        &lt;td&gt;no&lt;/td&gt;
        &lt;td&gt;允许初始化评论的用户（repo的所有者和合作者）&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;[ owner ]&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;id&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;yes&lt;/td&gt;
        &lt;td&gt;页面的唯一标识，长度必须小于50&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;location.href&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;number&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;yes&lt;/td&gt;
        &lt;td&gt;页面的issueID标识，若未定义number属性则使用id进行定位&lt;/td&gt;
        &lt;td&gt;-1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;Array&lt;/td&gt;
        &lt;td&gt;yes&lt;/td&gt;
        &lt;td&gt;GitHub issue的标签&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;[&#39;Gitalk&#39;]&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;title&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;yes&lt;/td&gt;
        &lt;td&gt;GitHub issue的标题&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;document.title&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;body&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;yes&lt;/td&gt;
        &lt;td&gt;GitHub issue的内容&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;location.href + header.meta[description]&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;language&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;yes&lt;/td&gt;
        &lt;td&gt;语言，支持[en, zh-CN, zh-TW]&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;navigator.language || navigator.userLanguage&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;perPage&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;Number&lt;/td&gt;
        &lt;td&gt;yes&lt;/td&gt;
        &lt;td&gt;每次加载的评论数，最多100&lt;/td&gt;
        &lt;td&gt;10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;distractionFreeMode&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;Boolean&lt;/td&gt;
        &lt;td&gt;yes&lt;/td&gt;
        &lt;td&gt;类似Facebook评论框的全屏遮罩效果.&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;pagerDirection&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;yes&lt;/td&gt;
        &lt;td&gt;评论排序方式， &lt;code&gt;last&lt;/code&gt;为按评论创建时间倒叙，&lt;code&gt;first&lt;/code&gt;为按创建时间正序。&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;&#39;last&#39;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;createIssueManually&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;Boolean&lt;/td&gt;
        &lt;td&gt;yes&lt;/td&gt;
        &lt;td width=50% nowrap&gt;如果当前页面没有相应的 issue 且登录的用户属于 admin，则会自动创建 issue。如果设置为 true，则显示一个初始化页面，创建 issue 需要点击 init 按钮。&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;proxy&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;String&lt;/td&gt;
        &lt;td&gt;yes&lt;/td&gt;
        &lt;td&gt;GitHub oauth请求到反向代理，为了支持CORS&lt;/td&gt;
        &lt;td nowrap&gt;&lt;a href=&#34;https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token&#34; target=&#34;_blank&#34;&gt;https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;flipMoveOptions&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;Object&lt;/td&gt;
        &lt;td&gt;yes&lt;/td&gt;
        &lt;td&gt;评论的参考动画&lt;/td&gt;
        &lt;td&gt;
            &lt;code&gt;
            { &lt;br&gt;
            &amp;emsp; staggerDelayBy: 150, &lt;br&gt;
            &amp;emsp; appearAnimation: &amp;lsquo;accordionVertical&amp;rsquo;, &lt;br&gt;
            &amp;emsp; enterAnimation: &amp;lsquo;accordionVertical&amp;rsquo;, &lt;br&gt;
            &amp;emsp; leaveAnimation: &amp;lsquo;accordionVertical&amp;rsquo;, &lt;br&gt;
            }
            &lt;/code&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td nowrap&gt;&lt;code&gt;enableHotKey&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;Boolean&lt;/td&gt;
        &lt;td&gt;yes&lt;/td&gt;
        &lt;td&gt;启用快捷键(cmd|ctrl + enter) 提交评论&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;h3 id=&#34;初始化评论&#34;&gt;初始化评论&lt;/h3&gt;

&lt;p&gt;Gitalk不需要像Gitment一样点初始化按钮初始化(除非将&lt;code&gt;createIssueManually&lt;/code&gt;选项设置为&lt;code&gt;true&lt;/code&gt;)，只需要&lt;code&gt;admin&lt;/code&gt;中的任何一名管理员登录账号即可自动初始化。&lt;/p&gt;

&lt;h2 id=&#34;gitalk在hugo-academic主题下的配置&#34;&gt;Gitalk在Hugo Academic主题下的配置&lt;/h2&gt;

&lt;p&gt;在hugo建立的根目录下创建目录&lt;code&gt;layouts/partials/&lt;/code&gt;，再在新创建的目录下创建&lt;code&gt;comments.html&lt;/code&gt;用于覆盖Academic主题的&lt;code&gt;comments.html&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd &amp;lt;your-hugo-website-root&amp;gt;
$ mkdir -p layouts/partials/
$ vi layouts/partials/comments.html
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    注意是在hugo建立的根目录而不是修改&lt;code&gt;themes/academic/&lt;/code&gt;主题下的文件。
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;在&lt;code&gt;layouts/partials/comments.html&lt;/code&gt;中输入以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ if eq .Site.Params.gitalk.on true }}
&amp;lt;section id=&amp;quot;comments&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;gitalkContainer&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&amp;quot;&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;script&amp;gt;
        var gitalk = new Gitalk({
            clientID: {{ .Site.Params.gitalk.clientID }},
            clientSecret: {{ .Site.Params.gitalk.clientSecret }},
            repo: {{ .Site.Params.gitalk.repo }},
            owner: {{ .Site.Params.gitalk.owner }},
            admin: {{ .Site.Params.gitalk.admin }},
            id: &#39;{{ .Params.Date }}&#39;,      // Ensure uniqueness and length less than 50
            labels: {{ .Site.Params.gitalk.labels }},
            distractionFreeMode: {{ .Site.Params.gitalk.distractionFreeMode }},  // Facebook-like distraction free mode
            pagerDirection: {{ .Site.Params.gitalk.pagerDirection }},
            createIssueManually: {{ .Site.Params.gitalk.createIssueManually }},
            enableHotKey: {{ .Site.Params.gitalk.enableHotKey }},
            flipMoveOptions: {
                staggerDelayBy: {{ .Site.Params.gitalk.flipMoveOptions.staggerDelayBy }},
                appearAnimation: {{ .Site.Params.gitalk.flipMoveOptions.appearAnimation }},
                enterAnimation: {{ .Site.Params.gitalk.flipMoveOptions.enterAnimation }},
                leaveAnimation: {{ .Site.Params.gitalk.flipMoveOptions.leaveAnimation }},
            },
        });
        gitalk.render(&#39;gitalkContainer&#39;);
    &amp;lt;/script&amp;gt;
&amp;lt;/section&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;config/_default/params.toml&lt;/code&gt;末尾添加以下配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# Config comments of gitalk
[gitalk]
  on = true
  clientID = &amp;quot;ec5806c0144b70a1b32e&amp;quot;
  clientSecret = &amp;quot;aadae41a3747ffa5b36fd0e13c7e84026db07e0c&amp;quot;
  repo  = &amp;quot;YuxinZhaozyx.github.io&amp;quot;
  owner = &amp;quot;YuxinZhaozyx&amp;quot;
  admin = [&amp;quot;YuxinZhaozyx&amp;quot;]
  labels = [&amp;quot;Comments&amp;quot;]  # default to [&amp;quot;Gitalk&amp;quot;]
  distractionFreeMode = false
  pagerDirection = &#39;last&#39; # set to &#39;last&#39; or &#39;first&#39;
  createIssueManually = false
  enableHotKey = true  # cmd | ctrl + enter to commit comment
  [gitalk.flipMoveOptions]
    staggerDelayBy = 150
    appearAnimation = &#39;elevator&#39;
    enterAnimation = &#39;elevator&#39;
    leaveAnimation = &#39;elevator&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，评论功能配置完成。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>git merge命令提示Already up to date</title>
      <link>https://YuxinZhaozyx.github.io/post/git-merge-already-up-to-date/</link>
      <pubDate>Tue, 09 Jul 2019 14:45:33 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/git-merge-already-up-to-date/</guid>
      <description>

&lt;p&gt;假定我有两个分支&lt;code&gt;master&lt;/code&gt;和&lt;code&gt;dev&lt;/code&gt;。当前处在&lt;code&gt;dev&lt;/code&gt;分支。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git merge master
Already up to date.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cause-of-errors-错误原因&#34;&gt;Cause of Errors 错误原因&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Already up to date&lt;/code&gt;意味着已经是最新的了，即&lt;code&gt;dev&lt;/code&gt;是在&lt;code&gt;master&lt;/code&gt;的基础上修改的，而&lt;code&gt;master&lt;/code&gt;自分出&lt;code&gt;dev&lt;/code&gt;分支后就没修改过，因此&lt;code&gt;dev&lt;/code&gt;分支是最新的，不需要于&lt;code&gt;master&lt;/code&gt;合并，因为合并完的仓库和当前的&lt;code&gt;dev&lt;/code&gt;分支是一模一样的。&lt;/p&gt;

&lt;p&gt;其git分支图如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;                 E -- F -- G(dev)
                /
A -- B -- C -- D(master)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其等同于:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;A -- B -- C -- D(master) -- E -- F -- G(dev)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们想要做的合并实际上是将&lt;code&gt;master&lt;/code&gt;指向&lt;code&gt;dev&lt;/code&gt;而已。&lt;/p&gt;

&lt;h2 id=&#34;solution-解决方法&#34;&gt;Solution 解决方法&lt;/h2&gt;

&lt;p&gt;多提交一个空的&lt;code&gt;commit&lt;/code&gt;，使两条分支叉开，再合并。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;                 E -- F -- G(dev)
                /
A -- B -- C -- D -- H(master)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;                 E -- F -- G(dev)
                /           \
A -- B -- C -- D -- H ------ I(master)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上图中&lt;code&gt;H&lt;/code&gt;是一个不做任何修改的提交，其作用是将&lt;code&gt;master&lt;/code&gt;和&lt;code&gt;dev&lt;/code&gt;分到两个叉开的分支上，使得&lt;code&gt;master&lt;/code&gt;不再是&lt;code&gt;dev&lt;/code&gt;的父节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;具体命令:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 移动到master分支下
$ git checkout master
# 在master提交一个空内容
$ git commit --allow-empty -m &amp;quot;ready for merging&amp;quot;
# 合并master和dev分支
$ git merge dev
# 移除dev指针(可选)
$ git branch --delete dev
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Hugo博客集成Gitment评论模块</title>
      <link>https://YuxinZhaozyx.github.io/post/gitment-in-hugo/</link>
      <pubDate>Fri, 05 Jul 2019 17:20:59 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/gitment-in-hugo/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;我使用的Hugo主题Academic自带Disqus评论模块支持，但由于国内无法访问Disqus，因此我开始寻找其他评论模块，最终选择了Gitment评论模块。&lt;/p&gt;

&lt;h2 id=&#34;我为什么选择gitment&#34;&gt;我为什么选择Gitment？&lt;/h2&gt;

&lt;p&gt;在选择之前我们先看一下有哪些选项可以选择。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Disqus&lt;/strong&gt;:  国外使用较多的评论组件，但国内需要代理才能访问。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;多说&lt;/strong&gt;:  国内最多用户使用的评论系统，但已于2017年6月停止提供服务。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;网易云跟帖&lt;/strong&gt;:  网易提供的评论系统，但也于2017月8月停止提供服务。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;畅言&lt;/strong&gt;:  搜狐提供的评论组件，功能丰富，体验优异；但必须进行域名备案。只要域名备过案就可以通过审核，简单问题复杂化。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Gitment&lt;/strong&gt;:   国人&lt;a href=&#34;https://imsun.net/&#34; target=&#34;_blank&#34;&gt;I&amp;rsquo;m Sun&lt;/a&gt;编写的开源评论模块，创新性地将评论放置在github的issue中，作者目前已不再维护。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;CommentHub&lt;/strong&gt;:  受Gitment启发也是将评论存储在github issue中的评论系统，解决Gitment会在前端暴露Client ID和Client Secret可能造成的安全问题，改进成在后端服务处理业务和存储证书，通过iframe实现评论功能。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;已停止服务的多说、网易云跟帖和国内无法访问的Disqus无法使用，故排除在选择范围之外。畅言由于需要备案，步骤繁琐不想用。剩下的Gitment和ComementHub实际上很像，CommentHub看上去会更安全一些，因为它不会像Gitment一样暴露Client ID和Client Secret，但其实即便别人获取了我们的Client ID和Client Secret，没有我的github账号依然无法使用，而且只能在我指定的网址才能用，故Gitment还是比较安全的。&lt;/p&gt;

&lt;p&gt;最终我在两者中选择了Gitment (因为CommentHub有点难看)。&lt;/p&gt;

&lt;h2 id=&#34;gitment评论模块介绍&#34;&gt;Gitment评论模块介绍&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Gitment is a comment system based on GitHub Issues, which can be used in the frontend without any server-side implementation.&lt;/p&gt;

&lt;p&gt;Gitment 是一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/imsun/gitment&#34; target=&#34;_blank&#34;&gt;项目地址&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://imsun.github.io/gitment/&#34; target=&#34;_blank&#34;&gt;官方示例&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;基本使用&#34;&gt;基本使用&lt;/h2&gt;

&lt;h3 id=&#34;1-注册oauth-application&#34;&gt;1. 注册OAuth Application&lt;/h3&gt;

&lt;p&gt;需要先在github上注册一个OAuth Application，&lt;a href=&#34;https://github.com/settings/applications/new&#34; target=&#34;_blank&#34;&gt;点击此处&lt;/a&gt;注册。&lt;/p&gt;

&lt;p&gt;Callback URL 填写评论页面对应的域名，如&lt;code&gt;https://YuxinZhaozyx.github.io&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    其他内容可以随便写，但Callback URL一定要填写正确。
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;注册成功后会得到一个Client ID和Client Secret，这将被用于之后的用户登录认证。&lt;/p&gt;

&lt;h3 id=&#34;2-引入gitment&#34;&gt;2. 引入Gitment&lt;/h3&gt;

&lt;p&gt;将以下代码添加到你的页面：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;container&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://imsun.github.io/gitment/style/default.css&amp;quot;&amp;gt;
&amp;lt;script src=&amp;quot;https://imsun.github.io/gitment/dist/gitment.browser.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
var gitment = new Gitment({
  id: &#39;页面 ID&#39;, // 可选。默认为 location.href
  owner: &#39;你的 GitHub ID&#39;,
  repo: &#39;存储评论的 repo&#39;,
  oauth: {
    client_id: &#39;你的 client ID&#39;,
    client_secret: &#39;你的 client secret&#39;,
  },
})
gitment.render(&#39;container&#39;)
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    &lt;code&gt;id&lt;/code&gt;的长度要限制在50个字符内，但也不可为空字符串。详情见&lt;a href=&#34;#问题汇总&#34;&gt;此处&lt;/a&gt;。
  &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;上述代码为gitment作者的示例代码，但作者已停止维护，网址已不可用，可用以下代码代替。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://www.wenjunjiang.win/css/gitment.css&amp;quot;&amp;gt;
&amp;lt;script src=&amp;quot;https://www.wenjunjiang.win/js/gitment.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css&amp;quot;&amp;gt;
&amp;lt;script src=&amp;quot;https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目前来看后者更稳定一点。&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;以上方式会使用最新版本的Gitment，若希望引用确定版本的Gitment，需要使用npm进行安装。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ npm install --save gitment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用操作详见&lt;a href=&#34;https://github.com/imsun/gitment#options&#34; target=&#34;_blank&#34;&gt;Gitment Option&lt;/a&gt;。&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&#34;3-初始化评论&#34;&gt;3. 初始化评论&lt;/h3&gt;

&lt;p&gt;页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。&lt;/p&gt;

&lt;p&gt;之后其他用户即可在该页面发表评论。&lt;/p&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    要先&lt;strong&gt;登录&lt;/strong&gt;才能初始化，未登录初始化前可能会显示&lt;code&gt;Error: Comments Not initialized&lt;/code&gt;错误，属正常现象。
  &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;问题汇总&#34;&gt;问题汇总&lt;/h2&gt;

&lt;h3 id=&#34;1-error-not-found&#34;&gt;1. &lt;code&gt;Error: Not Found&lt;/code&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;owner或者repo配置错误，注意名字和参考名字的大小写。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注意不可设置 &lt;code&gt;id : &amp;quot;&amp;quot;&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-error-comments-not-initialized&#34;&gt;2. &lt;code&gt;Error: Comments Not initialized&lt;/code&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;还没有登录，登录之后初始化就可以了。&lt;/li&gt;
&lt;li&gt;注册OAuth Application时Authorization Callback URL指定地址错误。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-error-validation-failed&#34;&gt;3. &lt;code&gt;Error: Validation Failed&lt;/code&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt;太长，导致初始化失败。解决方案见问题4。

&lt;ul&gt;
&lt;li&gt;id`的长度要限制在50个字符内，但也不可为空字符串&lt;/li&gt;
&lt;li&gt;github issue的标签label有长度限制，label的最大长度为50个字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt;的作用是唯一标识每一篇文章。&lt;/li&gt;
&lt;li&gt;在gitment创建的issue里，每个issue有两个label，其中一个是&lt;code&gt;gitment&lt;/code&gt;，另一个是&lt;code&gt;id&lt;/code&gt;指定的值。因此&lt;code&gt;id&lt;/code&gt;受到label的限制。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-在一篇文章下看到另一篇文章的issue&#34;&gt;4. 在一篇文章下看到另一篇文章的issue&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;两篇文章的&lt;code&gt;id&lt;/code&gt;重复&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;解决方案&#34;&gt;解决方案&lt;/h4&gt;

&lt;p&gt;将文章的&lt;code&gt;id&lt;/code&gt;设置为文章的创建时间，即可保证&lt;code&gt;id&lt;/code&gt;长度不超过50个字符且文章评论不重复。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  id: {{ .Params.Date }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    不要复制前面的某一篇论文而忘记修改时间，否则评论还是会交错的。
  &lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;gitment的汉化版本&#34;&gt;Gitment的汉化版本&lt;/h2&gt;

&lt;p&gt;只需到模板里将原来定义CSS和JS的那两行改成：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://billts.site/extra_css/gitment.css&amp;quot;&amp;gt;
&amp;lt;script src=&amp;quot;https://billts.site/js/gitment.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;gitment在hugo-academic主题下的配置&#34;&gt;Gitment在Hugo Academic主题下的配置&lt;/h2&gt;

&lt;p&gt;在hugo建立的根目录下创建目录&lt;code&gt;layouts/partials/&lt;/code&gt;，再在新创建的目录下创建&lt;code&gt;comments.html&lt;/code&gt;用于覆盖Academic主题的&lt;code&gt;comments.html&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd &amp;lt;your-hugo-website-root&amp;gt;
$ mkdir -p layouts/partials/
$ vi layouts/partials/comments.html
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    注意是在hugo建立的根目录而不是修改&lt;code&gt;themes/academic/&lt;/code&gt;主题下的文件。
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;在&lt;code&gt;layouts/partials/comments.html&lt;/code&gt;中输入以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ if .Site.Params.gitment.language }}
&amp;lt;section id=&amp;quot;comments&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;gitmentContainer&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    {{ if eq .Site.Params.gitment.language &amp;quot;zh&amp;quot; }}
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://billts.site/extra_css/gitment.css&amp;quot;&amp;gt;
    &amp;lt;script src=&amp;quot;https://billts.site/js/gitment.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    {{ else }}
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css&amp;quot;&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    {{ end }}

    &amp;lt;script&amp;gt;
        var gitment = new Gitment({
            id: &#39;{{ .Params.Date }}&#39;,
            owner: {{ .Site.Params.gitment.owner }},
            repo: {{ .Site.Params.gitment.repo }},
            oauth: {
                client_id: {{ .Site.Params.gitment.clientID }},
                client_secret: {{ .Site.Params.gitment.clientSecret }},
            },
        });
        gitment.render(&#39;gitmentContainer&#39;);
    &amp;lt;/script&amp;gt;
&amp;lt;/section&amp;gt;

{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;config/_default/params.toml&lt;/code&gt;末尾添加以下配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# Config comments of gitment
[gitment]
  language = &amp;quot;en&amp;quot; # set &amp;quot;&amp;quot; to disable comment, &amp;quot;zh&amp;quot; to Chinese, &amp;quot;en&amp;quot; to English
  owner = &amp;quot;&amp;lt;your-github-name&amp;gt;&amp;quot;
  repo  = &amp;quot;&amp;lt;the-repo-to-store-comments&amp;gt;&amp;quot;
  clientID = &amp;quot;&amp;lt;your-client-ID&amp;gt;&amp;quot;
  clientSecret = &amp;quot;&amp;lt;your-client-secret&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，评论功能配置完成。&lt;/p&gt;

&lt;h2 id=&#34;参考引用&#34;&gt;参考引用&lt;/h2&gt;

&lt;p&gt;[1]  &lt;a href=&#34;https://imsun.net/posts/gitment-introduction/&#34; target=&#34;_blank&#34;&gt;Gitment：使用 GitHub Issues 搭建评论系统 &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2]  &lt;a href=&#34;https://ihtcboy.com/2018/02/25/2018-02-25_Gitment评论功能接入踩坑教程/&#34; target=&#34;_blank&#34;&gt;Gitment评论功能接入踩坑教程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3]  &lt;a href=&#34;https://github.com/imsun/gitment/issues/95&#34; target=&#34;_blank&#34;&gt;Error: Comments Not Initialized # 95&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[4]  &lt;a href=&#34;https://github.com/imsun/gitment/issues/116&#34; target=&#34;_blank&#34;&gt;Validation Failed ID长度问题建议 #116&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[5]  &lt;a href=&#34;https://github.com/imsun/gitment/issues/170&#34; target=&#34;_blank&#34;&gt;[object ProgressEvent] #170&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[6]  &lt;a href=&#34;https://github.com/imsun/gitment/issues/102&#34; target=&#34;_blank&#34;&gt;网站无法访问了？ #102&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GoMicroBookshop项目开发笔记-1</title>
      <link>https://YuxinZhaozyx.github.io/post/gomicrobookshop-project/dev-note-1/</link>
      <pubDate>Thu, 04 Jul 2019 23:23:03 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/gomicrobookshop-project/dev-note-1/</guid>
      <description>

&lt;h2 id=&#34;第一章-用户服务&#34;&gt;第一章 用户服务&lt;/h2&gt;

&lt;p&gt;本章节我们实现用户服务，用户服务分为两层，web层（user-web）与服务层（user-srv），前者提供http接口，后者向web提供RPC服务。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;user-web 以下简称&lt;strong&gt;web&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;user-srv 以下简称&lt;strong&gt;service&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;web&lt;/strong&gt;服务主要向用户提供如下接口&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;登录与token颁发&lt;/li&gt;
&lt;li&gt;鉴权&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们不提供注册接口，一来增加不必要的代码量，我们的核心还是介绍如何使用Micro组件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;server&lt;/strong&gt;服务主要向所有内部服务提供用户查询接口：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;根据userName用户名查询用户&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在开发应用之前，我们要先定义好命名空间。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;服务&lt;/th&gt;
&lt;th&gt;命名空间&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;接入层API&lt;/td&gt;
&lt;td&gt;mu.micro.book.web&lt;/td&gt;
&lt;td&gt;负责代理所有&lt;strong&gt;mu.micro.book.web&lt;/strong&gt;下游的web应用，比如&lt;strong&gt;mu.micro.book.web.user&lt;/strong&gt;等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;用户web&lt;/td&gt;
&lt;td&gt;mu.micro.book.web.user&lt;/td&gt;
&lt;td&gt;接收API下放的路由为/user请求&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;用户服务&lt;/td&gt;
&lt;td&gt;mu.micro.book.srv.user&lt;/td&gt;
&lt;td&gt;对架构内应用提供user查询服务&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/YuxinZhaozyx/GoMicroBookshop/raw/master/image/part1_framework_namespace.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;user-srv&#34;&gt;user-srv&lt;/h3&gt;

&lt;p&gt;user-srv的各组件如下表所示&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;启动顺序&lt;/th&gt;
&lt;th&gt;组件&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;basic&lt;/td&gt;
&lt;td&gt;初始化配置与解析配置文件，初始化数据库等基础组件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;model&lt;/td&gt;
&lt;td&gt;模型层，提供业务数据&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;handler&lt;/td&gt;
&lt;td&gt;接入层，提供对外接口，并向model层调用请求数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Micro有提供代码生成器指令&lt;a href=&#34;https://github.com/micro-in-cn/all-in-one/tree/master/middle-practices/micro-new&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;new&lt;/strong&gt;&lt;/a&gt;，它可以新建服务模板代码，把基本所需的目录结构建好，省去大家挖坑的时间。&lt;/p&gt;

&lt;h4 id=&#34;新建模板&#34;&gt;新建模板&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;micro new --namespace=mu.micro.book --type=srv --alias=user github.com/YuxinZhaozyx/GoMicroBookshop/user-srv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模板生成在&lt;strong&gt;user-srv&lt;/strong&gt;目录，其结构如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── main.go
├── plugin.go
├── handler
│   └── user.go
├── subscriber
│   └── user.go
├── proto/user
│   └── user.proto
├── Dockerfile
├── Makefile
└── README.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── main.go
├── plugin.go
├── basic
│   └── config               * 配置类
│   │   └── config.go        * 初始化配置类
│   │   └── consul.go        * consul配置结构体
│   │   └── mysql.go         * mysql配置结构体
│   │   └── profiles.go      * 配置文件树辅助类
│   └── db                   * 数据库相关
│   │    └── db.go           * 初始化数据库
│   │    └── mysql.go        * mysql数据库相关
│   └── basic.go             * 初始化基础组件
├── conf                     * 配置文件目录
├── handler
│   └── user.go              * 将名称改为user
├── model                    * 增加模型层，用于与数据库交换数据
│   └── user                 * 用户模型类
│   │   └── user.go          * 初始化用户模型类
│   │   └── user_get.go      * 封装获取用户数据类业务
│   └── model.go             * 初始化模型层
├── proto/user    
│   └── user.proto           * 将名称改为user
├── Dockerfile
├── Makefile
└── README.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;目录解释：basic, model, conf&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;basic, model 目录与micro无关，只是为了实现MVC架构。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;basic&lt;/strong&gt; 负责初始化基础组件，比如数据库、配置等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;model&lt;/strong&gt; 负责封装业务逻辑&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;conf&lt;/strong&gt; 配置文件目录，现在我们还没用配置中心，暂先用文件的方式&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;定义user原型&#34;&gt;定义User原型&lt;/h4&gt;

&lt;p&gt;在user.proto中定义User原型，暂且定义以下字段，足够登录，显示用户基本信息、异常信息即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;syntax = &amp;quot;proto3&amp;quot;;

package mu.micro.book.srv.user;

service User {
    rpc QueryUserByName(Request) returns (Response) {}
}

message user {
    int64 id = 1;
    string name = 2;
    string pwd = 3;
    uint64 createTime = 4;
    uint64 updateTime = 5;
}

message Error {
    int32 code = 1;
    string detail = 2;
}

message Request {
    string userID = 1;
    string userName = 2;
    string userPwd = 3;
}

message Response {
    bool success = 1;
    Error error = 2;
    user user = 3;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面定义了User服务的基本原型结构，包含用户&lt;strong&gt;User&lt;/strong&gt;，请求&lt;strong&gt;Request&lt;/strong&gt;与响应结构&lt;strong&gt;Response&lt;/strong&gt;，还定义了查询用户的方法&lt;strong&gt;QueryUserByName&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;下面我们生成类型与服务方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;protoc --proto_path=. --go_out=. --micro_out=. proto/user/user.proto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后会生成 proto/user/user.micro.go 和 proto/user/user.pb.go 两个文件。&lt;/p&gt;

&lt;h4 id=&#34;数据库与配置&#34;&gt;数据库与配置&lt;/h4&gt;

&lt;h5 id=&#34;创建user表&#34;&gt;创建User表&lt;/h5&gt;

&lt;p&gt;选用MySQL作为数据库，以下是建表语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE DATABASE `micro_book_mall` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_bin */;
USE `micro_book_mall`;

CREATE TABLE `user`
(
    `id`           int(10) unsigned                                              NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,
    `user_id`      int(10) unsigned                                                       DEFAULT NULL COMMENT &#39;用户id&#39;,
    `user_name`    varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci  NOT NULL COMMENT &#39;用户名&#39;,
    `pwd`          varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#39;密码&#39;,
    `created_time` timestamp(3)                                                  NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `updated_time` timestamp(3)                                                  NOT NULL DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3),
    PRIMARY KEY (`id`),
    UNIQUE KEY `user_user_name_uindex` (`user_name`),
    UNIQUE KEY `user_user_id_uindex` (`user_id`)
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_bin COMMENT =&#39;用户表&#39;;

INSERT INTO user (user_id, user_name, pwd) VALUE (10001, &#39;micro&#39;, &#39;1234&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;基本组件配置&#34;&gt;基本组件配置&lt;/h5&gt;

&lt;p&gt;基础组件(basic)目前主要的功能是初始化配置与数据库。它的入口代码(basic/basic.go)是一个&lt;strong&gt;Init&lt;/strong&gt;初始化方法，负责初始化其下所有组件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package basic

import (
    &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/basic/config&amp;quot;
    &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/basic/db&amp;quot;
)

func Init() {
    config.Init()
    db.Init()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;配置config&#34;&gt;配置config&lt;/h5&gt;

&lt;p&gt;加载配置我们会使用到&lt;a href=&#34;https://github.com/micro/go-micro/config&#34; target=&#34;_blank&#34;&gt;go-config&lt;/a&gt;里面的本地文件配置。相关示例可以参考&lt;a href=&#34;https://github.com/micro-in-cn/all-in-one/tree/master/basic-practices/micro-config&#34; target=&#34;_blank&#34;&gt;go-config示例&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;配置文件在 conf/ 文件夹下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;application.yml         # 根配置文件
application-db.yml      # 数据库配置文件
application-consul.yml  # consul服务发现配置文件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根配置文件application.yml如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app:
  profiles:
    include: consul, db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起名为&lt;strong&gt;application.yml&lt;/strong&gt;是参考了Spring-boot风格。我们把consul和db配置分到独立的文件中。&lt;/p&gt;

&lt;p&gt;通过解析&lt;code&gt;app.profiles.include&lt;/code&gt;来加载指定的配置文件。当然也可以全部写在&lt;strong&gt;application.yml&lt;/strong&gt;中，只是我觉得挤在一起的配置不优雅。&lt;/p&gt;

&lt;p&gt;初始化配置的过程大致如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;顺序&lt;/th&gt;
&lt;th&gt;过程&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;加载application.yml&lt;/td&gt;
&lt;td&gt;读取conf目录下application.yml文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;解析profiles属性&lt;/td&gt;
&lt;td&gt;如果有该属性则找到include值，该值就是指定需要引入的conf下的配置文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;解析include&lt;/td&gt;
&lt;td&gt;解析出include配置【值】，并组合成文件名，文件名规则为[application-值.yml]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;读取include声明文件&lt;/td&gt;
&lt;td&gt;读取配置文件值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;解析配置&lt;/td&gt;
&lt;td&gt;将配置文件中的值解析到配置对象中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以下是它的核心代码(basic/config/config.go)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Init 初始化配置
func Init() {
    m.Lock()
    defer m.Unlock()

    if inited {
        log.Logf(&amp;quot;[Init] 配置已经初始化过&amp;quot;)
        return
    }

    // 加载yml配置
    // 先加载基础配置
    appPath, _ := filepath.Abs(filepath.Dir(filepath.Join(&amp;quot;.&amp;quot;+sp, sp)))

    pt := filepath.Join(appPath, &amp;quot;conf&amp;quot;)
    os.Chdir(appPath)

    // 找到application.yml文件
    if err = config.Load(file.NewSource(file.WithPath(pt + sp + &amp;quot;application.yml&amp;quot;))); err != nil {
        panic(err)
    }

    // 找到需要引入的新配置文件
    if err = config.Get(defaultRootPath, &amp;quot;profiles&amp;quot;).Scan(&amp;amp;profiles); err != nil {
        panic(err)
    }

    log.Logf(&amp;quot;[Init] 加载配置文件：path: %s, %+v\n&amp;quot;, pt+sp+&amp;quot;application.yml&amp;quot;, profiles)

    // 开始导入新文件
    if len(profiles.GetInclude()) &amp;gt; 0 {
        include := strings.Split(profiles.GetInclude(), &amp;quot;,&amp;quot;)

        sources := make([]source.Source, len(include))
        for i := 0; i &amp;lt; len(include); i++ {
            filePath := pt + string(filepath.Separator) + defaultConfigFilePrefix + strings.TrimSpace(include[i]) + &amp;quot;.yml&amp;quot;

            log.Logf(&amp;quot;[Init] 加载配置文件：path: %s\n&amp;quot;, filePath)

            sources[i] = file.NewSource(file.WithPath(filePath))
        }

        // 加载include的文件
        if err = config.Load(sources...); err != nil {
            panic(err)
        }
    }

    // 赋值
    config.Get(defaultRootPath, &amp;quot;consul&amp;quot;).Scan(&amp;amp;consulConfig)
    config.Get(defaultRootPath, &amp;quot;mysql&amp;quot;).Scan(&amp;amp;mysqlConfig)

    // 标记已经初始化
    inited = true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们目前定义了三个配置结构，它们在basic的&lt;a href=&#34;https://github.com/YuxinZhaozyx/GoMicroBookshop/blob/master/user-srv/basic/config&#34; target=&#34;_blank&#34;&gt;config&lt;/a&gt;目录下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/YuxinZhaozyx/GoMicroBookshop/blob/master/user-srv/basic/config/profiles.go&#34; target=&#34;_blank&#34;&gt;profiles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/YuxinZhaozyx/GoMicroBookshop/blob/master/user-srv/basic/config/consul.go&#34; target=&#34;_blank&#34;&gt;consul&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/YuxinZhaozyx/GoMicroBookshop/blob/master/user-srv/basic/config/mysql.go&#34; target=&#34;_blank&#34;&gt;mysql&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// defaultProfiles 属性配置文件
type defaultProfiles struct {
Include string `json:&amp;quot;include&amp;quot;`
}

// defaultConsulConfig 默认consul 配置
type defaultConsulConfig struct {
Enabled bool   `json:&amp;quot;enabled&amp;quot;`
Host    string `json:&amp;quot;host&amp;quot;`
Port    int    `json:&amp;quot;port&amp;quot;`
}

// defaultMysqlConfig mysql 配置
type defaultMysqlConfig struct {
URL               string `json:&amp;quot;url&amp;quot;`
Enable            bool   `json:&amp;quot;enabled&amp;quot;`
MaxIdleConnection int    `json:&amp;quot;maxIdleConnection&amp;quot;`
MaxOpenConnection int    `json:&amp;quot;maxOpenConnection&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;数据库初始化&#34;&gt;数据库初始化&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;// user-srv/basic/db/db.go
package db

import (
    &amp;quot;database/sql&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;sync&amp;quot;

    &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/basic/config&amp;quot;
    &amp;quot;github.com/micro/go-micro/util/log&amp;quot;
)

var (
    inited bool
    mysqlDB *sql.DB
    m sync.RWMutex
)

// Init 初始化数据库
func Init() {
    m.Lock()
    defer m.Unlock()

    var err error
    
    if inited{
        err = fmt.Errorf(&amp;quot;[Init] db 已经初始化过了&amp;quot;)
        log.Logf(err.Error())
        return
    }

    // 如果配置声明使用mysql
    if config.GetMysqlConfig().GetEnabled(){
        initMysql()
    }

    inited = true
}

// GetDB 获取数据库
func GetDB() *sql.DB {
    return mysqlDB
}
// user-srv/basic/db/mysql.go
package db

import (
    &amp;quot;database/sql&amp;quot;

    &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/basic/config&amp;quot;
    &amp;quot;github.com/micro/go-micro/util/log&amp;quot;
    
    _ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;
)

func initMysql() {
    var err error

    // 创建连接
    mysqlDB, err = sql.Open(&amp;quot;mysql&amp;quot;, config.GetMysqlConfig().GetURL())
    if err != nil {
        log.Fatal(err)
        panic(err)
    }

    // 最大连接数
    mysqlDB.SetMaxOpenConns(config.GetMysqlConfig().GetMaxOpenConnection())

    // 最大闲置数
    mysqlDB.SetMaxIdleConns(config.GetMysqlConfig().GetMaxIdleConnection())

    // 激活链接
    if err = mysqlDB.Ping(); err != nil {
        log.Fatal(err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;用户模型服务&#34;&gt;用户模型服务&lt;/h4&gt;

&lt;p&gt;/user-srv/model/user/user.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package user

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;sync&amp;quot;

    proto &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/proto/user&amp;quot;
)

var (
    s *service
    m sync.RWMutex
)

// service 服务
type service struct {
}

// Service 用户服务类
type Service interface {
    // QueryUserByName 根据用户名获取用户
    QueryUserByName(userName string) (ret *proto.User, err error)
}

// GetService 获取服务类
func GetService() (Service, error) {
    if s == nil {
        return nil, fmt.Errorf(&amp;quot;[GetService] GetService 未初始化&amp;quot;)
    }
    return s, nil
}

// Init 初始化用户服务层
func Init() {
    m.Lock()
    defer m.Unlock()

    if s != nil {
        return
    }

    s = &amp;amp;service{}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/user-srv/model/user/user_get.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package user

import (
    &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/basic/db&amp;quot;
    proto &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/proto/user&amp;quot;
    &amp;quot;github.com/micro/go-micro/util/log&amp;quot;
)

func (s *service) QueryUserByName(userName string) (ret *proto.User, err error) {
    queryString := `SELECT user_id, user_name, pwd FROM user WHERE user_name = ?`

    // 获取数据库
    o := db.GetDB()

    ret = &amp;amp;proto.User{}

    // 查询
    err = o.QueryRow(queryString, userName).Scan(&amp;amp;ret.Id, &amp;amp;ret.Name, &amp;amp;ret.Pwd)
    if err != nil {
        log.Logf(&amp;quot;[QueryUserByName] 查询数据失败， err: %s&amp;quot;, err)
        return
    }
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/user-srv/model/model.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package model

import &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/model/user&amp;quot;

// Init 初始化模型层
func Init() {
    user.Init()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;handler&#34;&gt;Handler&lt;/h4&gt;

&lt;p&gt;/user-srv/handler/user.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package handler

import (
    &amp;quot;context&amp;quot;

    &amp;quot;github.com/micro/go-micro/util/log&amp;quot;

    model &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/model/user&amp;quot;
    proto &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/proto/user&amp;quot;
)

type Service struct{}

var (
    userService model.Service
)

// Init 初始化handler
func Init() {
    var err error
    userService, err = model.GetService()
    if err != nil {
        log.Fatal(&amp;quot;[Init] 初始化Handler错误&amp;quot;)
        return
    }
}

// QueryUserByName 通过参数中的名字返回用户
func (e *Service) QueryUserByName(ctx context.Context, req *proto.Request, rsp *proto.Response) error {
    user, err := userService.QueryUserByName(req.UserName)
    if err != nil {
        rsp.Success = false
        rsp.Error = &amp;amp;proto.Error{
            Code:   500,
            Detail: err.Error(),
        }

        return err
    }

    rsp.User = user
    rsp.Success = true
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;handler直接调用模型层方法获取数据并回传给rsp结构。&lt;/p&gt;

&lt;h4 id=&#34;main&#34;&gt;main&lt;/h4&gt;

&lt;p&gt;main.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;time&amp;quot;

    &amp;quot;github.com/micro/cli&amp;quot;
    &amp;quot;github.com/micro/go-micro&amp;quot;
    &amp;quot;github.com/micro/go-micro/registry&amp;quot;
    &amp;quot;github.com/micro/go-micro/registry/consul&amp;quot;
    &amp;quot;github.com/micro/go-micro/util/log&amp;quot;

    &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/basic&amp;quot;
    &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/basic/config&amp;quot;
    &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/handler&amp;quot;
    &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/model&amp;quot;

    user &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/proto/user&amp;quot;
)

func main() {

    // 初始化配置、数据库等信息
    basic.Init()

    // 使用consul注册
    micReg := consul.NewRegistry(registryOptions)

    // New Service 新建服务
    service := micro.NewService(
        micro.Name(&amp;quot;mu.micro.book.srv.user&amp;quot;),
        micro.Registry(micReg),
        micro.Version(&amp;quot;latest&amp;quot;),
    )

    // Initialise service 初始化服务
    service.Init(
        micro.Action(func(c *cli.Context) {
            // 初始化模型层
            model.Init()
            // 初始化handler
            handler.Init()
        }),
    )

    // Register Handler 注册服务
    user.RegisterUserHandler(service.Server(), new(handler.Service))

    // Run service 启动服务
    if err := service.Run(); err != nil {
        log.Fatal(err)
    }
}

func registryOptions(ops *registry.Options) {
    consulCfg := config.GetConsulConfig()
    ops.Timeout = time.Second * 5
    ops.Addrs = []string{fmt.Sprintf(&amp;quot;%s:%d&amp;quot;, consulCfg.GetHost(), consulCfg.GetPort())}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码中我们默认使用consul作为注册中心，被在Action中初始化基础组件与模型层。&lt;/p&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    因为handler依赖model，所以初始化handler要在初始化模型层之后执行。
  &lt;/div&gt;
&lt;/div&gt;

&lt;h4 id=&#34;启动&#34;&gt;启动&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;启动consul&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;consul agent -dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;启动user-srv&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go run main.go plugin.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2019/06/29 22:26:48 [Init] 加载配置文件：path: e:\go\src\github.com\YuxinZhaozyx\GoMicroBookshop\user-srv\conf\application.yml, {Include:consul, db}
2019/06/29 22:26:48 [Init] 加载配置文件：path: e:\go\src\github.com\YuxinZhaozyx\GoMicroBookshop\user-srv\conf\application-consul.yml
2019/06/29 22:26:48 [Init] 加载配置文件：path: e:\go\src\github.com\YuxinZhaozyx\GoMicroBookshop\user-srv\conf\application-db.yml
2019/06/29 22:26:48 Transport [http] Listening on [::]:56789
2019/06/29 22:26:48 Broker [http] Connected to [::]:56790
2019/06/29 22:26:48 Registry [consul] Registering node: mu.micro.book.srv.user-f51e60e1-cebf-4599-874c-8230d3113300
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;测试&#34;&gt;测试&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;micro --registry=consul call mu.micro.book.srv.user User.QueryUserByName &amp;quot;{\&amp;quot;userName\&amp;quot;: \&amp;quot;micro\&amp;quot;}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
        &amp;quot;success&amp;quot;: true,
        &amp;quot;user&amp;quot;: {
                &amp;quot;id&amp;quot;: 10001,
                &amp;quot;name&amp;quot;: &amp;quot;micro&amp;quot;,
                &amp;quot;pwd&amp;quot;: &amp;quot;1234&amp;quot;
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;user-srv服务搭建完成。&lt;/p&gt;

&lt;h3 id=&#34;user-web&#34;&gt;user-web&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;web&lt;/strong&gt;服务负责暴露接口给用户，用户请求登录，&lt;strong&gt;web&lt;/strong&gt;通过用户名&lt;strong&gt;userName&lt;/strong&gt;向&lt;strong&gt;service&lt;/strong&gt;获取用户信息，再比对密码，正确则登录成功，反之返回错误。&lt;/p&gt;

&lt;p&gt;请求链如下图&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/micro-in-cn/tutorials/blob/master/microservice-in-micro/docs/part1_user_login_process.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://github.com/YuxinZhaozyx/GoMicroBookshop/raw/master/image/part1_user_login_process.png&#34; alt=&#34;img&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;新建模板-1&#34;&gt;新建模板&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;micro new --namespace=mu.micro.book --type=web --alias=user github.com/YuxinZhaozyx/GoMicroBookshop/user-web
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;目录树&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;生成的目录树&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── main.go
├── plugin.go
├── handler
│   └── handler.go
├── html
│   └── index.html
├── Dockerfile
├── Makefile
└── README.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改后：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── main.go
├── plugin.go
├── basic
│   └── config
│   │   └── config.go
│   │   └── consul.go
│   │   └── profiles.go
│   └── basic.go
├── conf
│   └── application.yml
│   └── application-consul.yml
├── handler
│   └── handler.go
├── Dockerfile
├── Makefile
└── README.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go-web是一个很简单的web开发库，它不像其它go语言的web框架有那么多工具集，它核心在两个方面&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;让程序支持http请求&lt;/li&gt;
&lt;li&gt;天生属于Micro生态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;它不需要额外的代码就可以注册到Micro生态中，和其它类型的服务一样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;web&lt;/strong&gt;核心有三个地方&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/YuxinZhaozyx/GoMicroBookshop/blob/master/user-web/basic/config/config.go&#34; target=&#34;_blank&#34;&gt;config.go&lt;/a&gt; 负责加载配置&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/YuxinZhaozyx/GoMicroBookshop/blob/master/user-web/handler/handler.go&#34; target=&#34;_blank&#34;&gt;handler.go&lt;/a&gt; 负责处理请求&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/YuxinZhaozyx/GoMicroBookshop/blob/master/user-web/main.go&#34; target=&#34;_blank&#34;&gt;main.go&lt;/a&gt; 程序运行入口&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;config&#34;&gt;config&lt;/h4&gt;

&lt;p&gt;设置类似user-srv的设置，但去除mysql的配置。&lt;/p&gt;

&lt;p&gt;user-web/basic/config/config.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package config

import (
    &amp;quot;os&amp;quot;
    &amp;quot;path/filepath&amp;quot;
    &amp;quot;strings&amp;quot;
    &amp;quot;sync&amp;quot;

    &amp;quot;github.com/micro/go-micro/config&amp;quot;
    &amp;quot;github.com/micro/go-micro/config/source&amp;quot;
    &amp;quot;github.com/micro/go-micro/config/source/file&amp;quot;
    &amp;quot;github.com/micro/go-micro/util/log&amp;quot;
)

var (
    err error
)

var (
    defaultRootPath         = &amp;quot;app&amp;quot;
    defaultConfigFilePrefix = &amp;quot;application-&amp;quot;
    consulConfig            defaultConsulConfig
    profiles                defaultProfiles
    m                       sync.RWMutex
    inited                  bool
)

// Init 初始化配置
func Init() {
    m.Lock()
    defer m.Unlock()

    if inited {
        log.Logf(&amp;quot;[Init] 配置已经初始化过&amp;quot;)
        return
    }

    // 加载yml配置
    // 先加载基础配置
    appPath, _ := filepath.Abs(filepath.Dir(filepath.Join(&amp;quot;./&amp;quot;, string(filepath.Separator))))

    pt := filepath.Join(appPath, &amp;quot;conf&amp;quot;)
    os.Chdir(appPath)

    // 找到application.yml文件
    if err = config.Load(file.NewSource(file.WithPath(pt + &amp;quot;/application.yml&amp;quot;))); err != nil {
        panic(err)
    }

    // 找到需要引入的新配置文件
    if err = config.Get(defaultRootPath, &amp;quot;profiles&amp;quot;).Scan(&amp;amp;profiles); err != nil {
        panic(err)
    }

    log.Logf(&amp;quot;[Init] 加载配置文件：path: %s, %+v\n&amp;quot;, pt+&amp;quot;/application.yml&amp;quot;, profiles)

    // 开始导入新文件
    if len(profiles.GetInclude()) &amp;gt; 0 {
        include := strings.Split(profiles.GetInclude(), &amp;quot;,&amp;quot;)

        sources := make([]source.Source, len(include))
        for i := 0; i &amp;lt; len(include); i++ {
            filePath := pt + string(filepath.Separator) + defaultConfigFilePrefix + strings.TrimSpace(include[i]) + &amp;quot;.yml&amp;quot;

            log.Logf(&amp;quot;[Init] 加载配置文件：path: %s\n&amp;quot;, filePath)

            sources[i] = file.NewSource(file.WithPath(filePath))
        }

        // 加载include的文件
        if err = config.Load(sources...); err != nil {
            panic(err)
        }
    }

    // 赋值
    config.Get(defaultRootPath, &amp;quot;consul&amp;quot;).Scan(&amp;amp;consulConfig)

    // 标记已经初始化
    inited = true
}

// GetConsulConfig 获取Consul配置
func GetConsulConfig() (ret ConsulConfig) {
    return consulConfig
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;user-web/basic/config/consul.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package config

// ConsulConfig consul 配置
type ConsulConfig interface {
    GetEnabled() bool
    GetPort() int
    GetHost() string
}

// defaultConsulConfig 默认consul 配置
type defaultConsulConfig struct {
    Enabled bool   `json:&amp;quot;enabled&amp;quot;`
    Host    string `json:&amp;quot;host&amp;quot;`
    Port    int    `json:&amp;quot;port&amp;quot;`
}

// GetPort consul 端口
func (c defaultConsulConfig) GetPort() int {
    return c.Port
}

// GetEnabled consul 激活
func (c defaultConsulConfig) GetEnabled() bool {
    return c.Enabled
}

// GetHost consul 主机地址
func (c defaultConsulConfig) GetHost() string {
    return c.Host
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;user-web/basic/config/profiles.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package config

// Profiles 属性配置文件
type Profiles interface {
    GetInclude() string
}

// defaultProfiles 属性配置文件
type defaultProfiles struct {
    Include string `json:&amp;quot;include&amp;quot;`
}

// Include 包含的配置文件
// 名称前缀为&amp;quot;application-&amp;quot;，格式为yml，如：&amp;quot;application-xxx.yml&amp;quot;
// 多个文件名以逗号隔开，并省略掉前缀&amp;quot;application-&amp;quot;，如：dn, jpush, mysql
func (p defaultProfiles) GetInclude() string {
    return p.Include
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;handler-1&#34;&gt;handler&lt;/h4&gt;

&lt;p&gt;user-web/handler/handler.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package handler

import (
    &amp;quot;context&amp;quot;
    &amp;quot;encoding/json&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;time&amp;quot;

    user &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/proto/user&amp;quot;
    &amp;quot;github.com/micro/go-micro/client&amp;quot;
    &amp;quot;github.com/micro/go-micro/util/log&amp;quot;
)

var (
    serviceClient user.UserService
)

// Error 错误结构体
type Error struct {
    Code   string `json:&amp;quot;code&amp;quot;`
    Detail string `json:&amp;quot;detail&amp;quot;`
}

func Init() {
    serviceClient = user.NewUserService(&amp;quot;mu.micro.book.srv.user&amp;quot;, client.DefaultClient)
}

// Login 登录入口
func Login(w http.ResponseWriter, r *http.Request) {
    // 只接受POST请求
    if r.Method != &amp;quot;POST&amp;quot; {
        log.Logf(&amp;quot;非法请求&amp;quot;)
        http.Error(w, &amp;quot;非法请求&amp;quot;, 400)
        return
    }

    r.ParseForm()

    // 调用后台服务
    rsp, err := serviceClient.QueryUserByName(context.TODO(), &amp;amp;user.Request{
        UserName: r.Form.Get(&amp;quot;userName&amp;quot;),
    })
    if err != nil {
        http.Error(w, err.Error(), 500)
        return
    }

    // 返回结果
    response := map[string]interface{}{
        &amp;quot;ref&amp;quot;: time.Now().UnixNano(),
    }

    if rsp.User.Pwd == r.Form.Get(&amp;quot;pwd&amp;quot;) {
        response[&amp;quot;success&amp;quot;] = rsp.Success

        // 干掉密码返回
        rsp.User.Pwd = &amp;quot;&amp;quot;
        response[&amp;quot;data&amp;quot;] = rsp.User
    } else {
        response[&amp;quot;success&amp;quot;] = false
        response[&amp;quot;error&amp;quot;] = &amp;amp;Error{
            Detail: &amp;quot;密码错误&amp;quot;,
        }
    }

    w.Header().Add(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json; charset=utf-8&amp;quot;)

    // encode and write the response as json 返回json结构
    if err := json.NewEncoder(w).Encode(response); err != nil {
        http.Error(w, err.Error(), 500)
        return
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;main-1&#34;&gt;main&lt;/h4&gt;

&lt;p&gt;user-web/main.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;time&amp;quot;

    &amp;quot;github.com/micro/go-micro/util/log&amp;quot;

    &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-web/basic&amp;quot;
    &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-web/basic/config&amp;quot;
    &amp;quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-web/handler&amp;quot;
    &amp;quot;github.com/micro/cli&amp;quot;
    &amp;quot;github.com/micro/go-micro/registry&amp;quot;
    &amp;quot;github.com/micro/go-micro/registry/consul&amp;quot;
    &amp;quot;github.com/micro/go-micro/web&amp;quot;
)

func main() {
    // 初始化配置
    basic.Init()

    // 使用consul注册
    micReg := consul.NewRegistry(registryOptions)

    // create new web service 创建新服务
    service := web.NewService(
        web.Name(&amp;quot;mu.micro.book.web.user&amp;quot;),
        web.Version(&amp;quot;latest&amp;quot;),
        web.Registry(micReg),
        web.Address(&amp;quot;:8088&amp;quot;),
    )

    // initialise service 初始化服务
    if err := service.Init(
        web.Action(func(c *cli.Context) {
            // 初始化handler
            handler.Init()
        }),
    ); err != nil {
        log.Fatal(err)
    }

    // register call handler 注册登录接口
    service.HandleFunc(&amp;quot;/user/login&amp;quot;, handler.Login)

    // run service 运行服务
    if err := service.Run(); err != nil {
        log.Fatal(err)
    }
}

func registryOptions(ops *registry.Options) {
    consulCfg := config.GetConsulConfig()
    ops.Timeout = time.Second * 5
    ops.Addrs = []string{fmt.Sprintf(&amp;quot;%s:%d&amp;quot;, consulCfg.GetHost(), consulCfg.GetPort())}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;handler里定义了错误结构体&lt;strong&gt;Error&lt;/strong&gt;、&lt;strong&gt;Init&lt;/strong&gt;、&lt;strong&gt;Login&lt;/strong&gt;方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Init&lt;/strong&gt; 用来初始化handler需要用到的服务客户端&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Login&lt;/strong&gt; 处理登录请求&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Login&lt;/strong&gt;在解析完参数后，通过RPC调用&lt;strong&gt;service&lt;/strong&gt;的&lt;strong&gt;QueryUserByName&lt;/strong&gt;方法。查出的结果后再进行密码匹配。&lt;/p&gt;

&lt;p&gt;匹配成功后便返回用户信息。&lt;/p&gt;

&lt;h4 id=&#34;启动-1&#34;&gt;启动&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;启动consul&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;consul agent -dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;运行api&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;micro --registry=consul --api_namespace=mu.micro.book.web  api --handler=web
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;运行user-srv&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd user-srv
go run main.go plugin.go 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;运行user-web&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd user-web
go run main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;测试-1&#34;&gt;测试&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl --request POST --url http://127.0.0.1:8088/user/login --header &amp;quot;Content-Type:application/x-www-form-urlencoded&amp;quot; --data &amp;quot;userName=micro&amp;amp;pwd=1234&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;错误输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&amp;quot;id&amp;quot;:&amp;quot;go.micro.client&amp;quot;,&amp;quot;code&amp;quot;:500,&amp;quot;detail&amp;quot;:&amp;quot;connection error: dial tcp: address fdf5:da13:de04::e58:59504: too many colons in address&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;Internal Server Error&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go-micro暂不支持ipv6，待解决。&lt;/p&gt;

&lt;p&gt;正确输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&amp;quot;data&amp;quot;:{&amp;quot;id&amp;quot;:10001,&amp;quot;name&amp;quot;:&amp;quot;micro&amp;quot;},&amp;quot;ref&amp;quot;:1561869942897349500,&amp;quot;success&amp;quot;:true}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;隔日重启后各服务分配到的是ipv4而不是ipv6地址，程序正常执行，未找到原因，待解决。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GoMicroBookshop项目开发笔记-0</title>
      <link>https://YuxinZhaozyx.github.io/post/gomicrobookshop-project/dev-note-0/</link>
      <pubDate>Thu, 04 Jul 2019 23:02:54 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/gomicrobookshop-project/dev-note-0/</guid>
      <description>

&lt;h1 id=&#34;项目简介&#34;&gt;项目简介&lt;/h1&gt;

&lt;h2 id=&#34;业务模块&#34;&gt;业务模块&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户&lt;/strong&gt;，users&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;库存&lt;/strong&gt;，inventory&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;权限&lt;/strong&gt;，auth&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;订单&lt;/strong&gt;，orders&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支付&lt;/strong&gt;，payment&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;服务抽象结构&#34;&gt;服务抽象结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/YuxinZhaozyx/GoMicroBookshop/raw/master/image/design.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用户、订单、支付服务都会有对外暴露接口，故而它们各自有web层。web层app之间不会互相调用，它们只会与非web层的应用交互。&lt;/p&gt;

&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Golang环境 &lt;a href=&#34;https://golang.google.cn/&#34; target=&#34;_blank&#34;&gt;安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;gRPC &lt;a href=&#34;https://grpc.io/docs/quickstart/go.html&#34; target=&#34;_blank&#34;&gt;安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Consul&lt;/li&gt;
&lt;li&gt;Micro&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;## 安装go-micro
go get github.com/micro/go-micro

## 安装micro
go get github.com/micro/micro
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;mysql&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还有其它一些会用到的库或组件，但不是基础依赖，需要时再安装。&lt;/p&gt;

&lt;h2 id=&#34;涉及技术与库&#34;&gt;涉及技术与库&lt;/h2&gt;

&lt;p&gt;Golang，gRPC，Mysql，Redis，Docker，K8s，Go-micro/Micro&lt;/p&gt;

&lt;h2 id=&#34;搭建平台&#34;&gt;搭建平台&lt;/h2&gt;

&lt;p&gt;win10&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>$\LaTeX$ Math Symbols</title>
      <link>https://YuxinZhaozyx.github.io/post/latex-math-symbols/</link>
      <pubDate>Thu, 04 Jul 2019 20:04:20 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/post/latex-math-symbols/</guid>
      <description>

&lt;p&gt;Summary of LaTeX Math Symbols&lt;/p&gt;

&lt;p&gt;$\LaTeX$数学符号汇总&lt;/p&gt;

&lt;h2 id=&#34;function-symbol-and-special-characters-函数-符号及特殊字符&#34;&gt;Function, symbol and special characters 函数、符号及特殊字符&lt;/h2&gt;

&lt;h3 id=&#34;tone-声调&#34;&gt;Tone 声调&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Syntax 语法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Effect 效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\bar{x}&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\bar{x}$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\acute{\eta}&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\acute{\eta}$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\check{\alpha}&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\check{\alpha}$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\grave{\eta}&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\grave{\eta}$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\breve{a}&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\breve{a}$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\ddot{y}&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\ddot{y}$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\dot{x}&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\dot{x}$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\hat{\alpha}&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\hat{\alpha}$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\tilde{\iota}&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\tilde{\iota} $$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;function-函数&#34;&gt;Function 函数&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Syntax 语法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Effect 效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\sin\theta&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\sin\theta$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\cos\theta&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\cos\theta$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\tan\theta&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\tan\theta$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\arcsin\frac{L}{r}&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\arcsin\frac{L}{r}$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\arccos\frac{T}{r}&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\arccos\frac{T}{r}$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\arctan\frac{L}{T}&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\arctan\frac{L}{T}$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\sinh g&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\sinh g$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\cosh h&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\cosh h$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\tanh i&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\tanh i$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\operatorname{sh}j&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\operatorname{sh}j$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\operatorname{argsh}k&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\operatorname{argsh}k$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\operatorname{ch}h&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\operatorname{ch}h$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\operatorname{argch}l&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\operatorname{argch}l$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\operatorname{th}i&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\operatorname{th}i$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\operatorname{argth}m&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\operatorname{argth}m$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;k&#39;(x)=\lim_{\Delta x\to 0}\frac{k(x)-k(x-\Delta x)}{\Deltax}&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$k&amp;rsquo;(x)=\lim_{\Delta x\to 0}\frac{k(x)-k(x-\Delta x)}{\Delta}$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\limsup S&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\limsup S$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\liminf I&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\liminf I$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\max H&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\max H$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\min L&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\min L$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\inf s&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\inf s$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\sup t&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\sup t$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\exp t&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\exp t$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\ln X&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\ln X$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\lg X&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\lg X$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\log X&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\log X$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\log_\alpha X&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\log_\alpha X$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\ker x&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\ker x$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\deg x&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\deg x$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\gcd(T,U,V,W,X)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\gcd(T,U,V,W,X)$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\Pr x&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\Pr x$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\det x&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\det x$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\hom x&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\hom x$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\arg x&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\arg x$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\dim x&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\dim x$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\lim_{t\to n}T&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\lim_{t\to n}T$$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;congruent-同余&#34;&gt;Congruent 同余&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Syntax 语法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Effect 效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\pmod{m}&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\pmod{m}$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;a \bmod b&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$a \bmod b$$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;differential-微分&#34;&gt;Differential 微分&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Syntax 语法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Effect 效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\nabla&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\nabla$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\partial x&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\partial x$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\mathrm{d}x&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\mathrm{d}x$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\dot x&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\dot x$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\ddot x&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\ddot x$$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;set-集合&#34;&gt;Set 集合&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Syntax 语法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Effect 效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\forall&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\forall$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\exists&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\exists$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\emptyset&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\emptyset$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\varnothing&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\varnothing$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\ni&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\ni$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\not\in&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\not\in$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\notin&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\notin$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\subset&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\subset$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\supset&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\supset$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\supseteq&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\supseteq$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\cap&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\cap$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\bigcap&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\bigcap$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\bigcap&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\bigcap$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\biguplus&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\biguplus$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\sqsubset&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\sqsubset$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\sqsubseteq&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\sqsubseteq$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\sqsupseteq&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\sqsupseteq$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\sqcap&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\sqcap$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\sqcup&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\sqcup$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\bigsqcup&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\bigsqcup$$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;logic-逻辑&#34;&gt;Logic 逻辑&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Syntax 语法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Effect 效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;p&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$p$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\land&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\land$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\wedge&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\wedge$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\bigwedge&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\bigwedge$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\bar{q} \to p&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\bar{q} \to p$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\lor&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\lor$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\vee&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\vee$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\bigvee&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\bigvee$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\lnot&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\lnot$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\neg q&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\neg q$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\setminus&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\setminus$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\smallsetminus&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\smallsetminus$$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;radication-开方&#34;&gt;Radication  开方&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Syntax 语法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Effect 效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\sqrt{3}&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\sqrt{3}$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\sqrt[n]{3}&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\sqrt[n]{3}$$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;relation-关系&#34;&gt;Relation 关系&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Syntax 语法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Effect 效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\Delta ABC\sim\Delta XYZ&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\Delta ABC\sim\Delta XYZ$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\sqrt{3}\approx1.732050808\ldots&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\sqrt{3}\approx1.732050808\ldots$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\simeq&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\simeq$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\cong&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\cong$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\dot=&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\dot=$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\ggg&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\ggg$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\gg&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\gg$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$&amp;gt;$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\ge&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\ge$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\geqq&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\geqq$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$=$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\leq&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\leq$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\leqq&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\leqq$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$&amp;lt;$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\ll&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\ll$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\lll&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\lll$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;(x-y)^2\equiv(-x+y)^2\equiv x^2-2xy+y^2&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$(x-y)^2\equiv(-x+y)^2\equiv x^2-2xy+y^2$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;x\not\equiv N&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$x\not\equiv N$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;x\ne A&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$x\ne A$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;x\neq C&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$x\neq C$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;t\propto v&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$t\propto v$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\pm&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\pm$$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;\mp&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;$$\mp$$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    To be continue   未完待续
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>GoMicroBookshop</title>
      <link>https://YuxinZhaozyx.github.io/project/gomicrobookshop/</link>
      <pubDate>Thu, 04 Jul 2019 12:27:03 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/project/gomicrobookshop/</guid>
      <description>

&lt;p&gt;A bookshop project for my go-micro and micro service learning.&lt;/p&gt;

&lt;p&gt;本项目依据项目 &lt;a href=&#34;https://github.com/micro-in-cn/tutorials/tree/master/microservice-in-micro&#34; target=&#34;_blank&#34;&gt;microservice-in-cn&lt;/a&gt; 学习&lt;a href=&#34;https://github.com/micro/micro&#34; target=&#34;_blank&#34;&gt;micro&lt;/a&gt;工具链以及微服务。&lt;/p&gt;

&lt;h1 id=&#34;项目简介&#34;&gt;项目简介&lt;/h1&gt;

&lt;p&gt;本项目为一个网上书店。&lt;/p&gt;

&lt;h2 id=&#34;业务模块&#34;&gt;业务模块&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户&lt;/strong&gt;，users&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;库存&lt;/strong&gt;，inventory&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;权限&lt;/strong&gt;，auth&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;订单&lt;/strong&gt;，orders&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支付&lt;/strong&gt;，payment&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;服务抽象结构&#34;&gt;服务抽象结构&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/YuxinZhaozyx/GoMicroBookshop/blob/master/image/design.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;image/design.png&#34; alt=&#34;img&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;用户、订单、支付服务都会有对外暴露接口，故而它们各自有web层。web层app之间不会互相调用，它们只会与非web层的应用交互。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://YuxinZhaozyx.github.io/authors/yuxinzhao/</link>
      <pubDate>Tue, 23 Jul 2019 17:20:42 +0800</pubDate>
      
      <guid>https://YuxinZhaozyx.github.io/authors/yuxinzhao/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m a college student of software engineering at the South China University of Technology. My research interests include artificial intelligence, micro service and engineering.&lt;/p&gt;

&lt;p&gt;我是华南理工大学软件工程专业的一名大学生。我的研究兴趣包括人工智能、微服务和软件工程。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
