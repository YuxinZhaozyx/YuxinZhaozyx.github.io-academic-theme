[{"authors":["yuxinzhao"],"categories":null,"content":"I\u0026rsquo;m a college student of software engineering at the South China University of Technology. My research interests include artificial intelligence, micro service and engineering.\n我是华南理工大学软件工程专业的一名大学生。我的研究兴趣包括人工智能、微服务和软件工程。\n","date":1563851454,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1563851454,"objectID":"486f8643cd7bf1ce56e100a3e5ef15e9","permalink":"https://YuxinZhaozyx.github.io/authors/yuxinzhao/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/yuxinzhao/","section":"authors","summary":"I\u0026rsquo;m a college student of software engineering at the South China University of Technology. My research interests include artificial intelligence, micro service and engineering. 我是华南理工大学软件工程专业的一名大学生。我的研究兴趣包括人工智能、微服务和软件工程。","tags":null,"title":"Yuxin Zhao 赵煜新","type":"authors"},{"authors":["admin"],"categories":null,"content":"Nelson Bighetti is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed neque elit, tristique placerat feugiat ac, facilisis vitae arcu. Proin eget egestas augue. Praesent ut sem nec arcu pellentesque aliquet. Duis dapibus diam vel metus tempus vulputate.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://YuxinZhaozyx.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Nelson Bighetti is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed neque elit, tristique placerat feugiat ac, facilisis vitae arcu. Proin eget egestas augue. Praesent ut sem nec arcu pellentesque aliquet.","tags":null,"title":"Nelson Bighetti","type":"authors"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["deep-learning"],"content":" 本文将学习如何使用 DataParallel 来使用多GPU。\nPyTorch非常容易就可以使用多GPU，用如下方式把一个模型放到GPU上：\ndevice = torch.device(\u0026quot;cuda:0\u0026quot;) model.to(device)  然后复制所有的张量到GPU上：\nmytensor = my_tensor.to(device)   只调用my_tensor.to(device)并没有复制张量到GPU上，而是返回了一个copy。所以你需要把它赋值给一个新的张量并在GPU上使用这个张量。   在多GPU上执行前向和反向传播是自然而然的事。 但是PyTorch默认将只使用一个GPU。\n使用DataParallel可以轻易的让模型并行运行在多个GPU上。\nmodel = nn.DataParallel(model)  导入模块和定义参数 # Parameters and DataLoaders input_size = 5 output_size = 2 batch_size = 30 data_size = 100 # Device device = torch.device(\u0026quot;cuda:0\u0026quot; if torch.cuda.is_available() else \u0026quot;cpu\u0026quot;)  虚拟数据集 制作一个虚拟（随机）数据集， 你只需实现 __getitem__\nclass RandomDataset(Dataset): def __init__(self, size, length): self.len = length self.data = torch.randn(length, size) def __getitem__(self, index): return self.data[index] def __len__(self): return self.len rand_loader = DataLoader(dataset=RandomDataset(input_size, data_size), batch_size=batch_size, shuffle=True)  简单模型 作为演示，我们的模型只接受一个输入，执行一个线性操作，然后得到结果。 说明：DataParallel能在任何模型（CNN，RNN，Capsule Net等）上使用。\nclass Model(nn.Module): def __init__(self, input_size, output_size): super(Model, self).__init__() self.fc = nn.Linear(input_size, output_size) def forward(self, input): output = self.fc(input) print(\u0026quot;\\t In Model: input size\u0026quot;, input.size(), \u0026quot;output size\u0026quot;, output.size()) return output  创建一个模型和数据并行 首先，我们需要创建一个模型实例和检测我们是否有多个GPU。 如果有多个GPU，使用nn.DataParallel来包装我们的模型。 然后通过model.to(device)把模型放到GPU上。\nmodel = Model(input_size, output_size) if torch.cuda.device_count() \u0026gt; 1: print(\u0026quot;Let's use\u0026quot;, torch.cuda.device_count(), \u0026quot;GPUs!\u0026quot;) # dim = 0 [30, xxx] -\u0026gt; [10, ...], [10, ...], [10, ...] on 3 GPUs model = nn.DataParallel(model) model.to(device)  运行模型 for data in rand_loader: input = data.to(device) output = model(input) print(\u0026quot;Outside: input size\u0026quot;, input.size(), \u0026quot;output_size\u0026quot;, output.size())  当没有或者只有一个GPU时，对30个输入和输出进行批处理，得到了期望的一样得到30个输入和输出，但是如果你有多个GPU，你得到如下的结果。\n2 GPUs\nLet's use 2 GPUs! In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2]) In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2]) Outside: input size torch.Size([30, 5]) output_size torch.Size([30, 2]) In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2]) In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2]) Outside: input size torch.Size([30, 5]) output_size torch.Size([30, 2]) In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2]) In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2]) Outside: input size torch.Size([30, 5]) output_size torch.Size([30, 2]) In Model: input size torch.Size([5, 5]) output size torch.Size([5, 2]) In Model: input size torch.Size([5, 5]) output size torch.Size([5, 2]) Outside: input size torch.Size([10, 5]) output_size torch.Size([10, 2])  ","date":1563851454,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563851454,"objectID":"fd12a9a34b4094baa2c954d904afa3f2","permalink":"https://YuxinZhaozyx.github.io/post/pytorch-learning/note-5/","publishdate":"2019-07-23T11:10:54+08:00","relpermalink":"/post/pytorch-learning/note-5/","section":"post","summary":"[DEEP LEARNING WITH PYTORCH: A 60 MINUTE BLITZ] Data Parallelism","tags":["pytorch","deep learning"],"title":"PyTorch Learning Note-5","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["deep-learning"],"content":" 一般情况下处理图像、文本、音频和视频数据时，可以使用标准的Python包来加载数据到一个numpy数组中。 然后把这个数组转换成 torch.*Tensor。\n 图像可以使用 Pillow, OpenCV 音频可以使用 scipy, librosa 文本可以使用原始Python和Cython来加载，或者使用 NLTK或 SpaCy 处理  特别的，对于图像任务，torchvision 包 包含了处理一些基本图像数据集的方法。这些数据集包括 Imagenet, CIFAR10, MNIST 等。除了数据加载以外，torchvision 还包含了图像转换器， torchvision.datasets 和 torch.utils.data.DataLoader。\ntorchvision包不仅提供了巨大的便利，也避免了代码的重复。\n以下使用的案例中，将使用CIFAR10数据集，它有如下10个类别 ：‘airplane’, ‘automobile’, ‘bird’, ‘cat’, ‘deer’, ‘dog’, ‘frog’, ‘horse’, ‘ship’, ‘truck’。CIFAR-10的图像都是 3x32x32大小的，即，3颜色通道，32x32像素。\n训练一个图像分类器 依次按照下列顺序进行：\n 使用torchvision加载和归一化CIFAR10训练集和测试集 定义一个卷积神经网络 定义损失函数 在训练集上训练网络 在测试集上测试网络  读取和归一化 CIFAR10 使用torchvision可以非常容易地加载CIFAR10。\nimport torch import torchvision import torchvision.transforms as transforms  torchvision的输出是[0,1]的PILImage图像，我们把它转换为归一化范围为[-1, 1]的张量。\ntransform = transforms.Compose( [transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))]) trainset = torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=transform) trainloader = torch.utils.data.DataLoader(trainset, batch_size=4, shuffle=True, num_workers=2) testset = torchvision.datasets.CIFAR10(root='./data', train=False, download=True, transform=transform) testloader = torch.utils.data.DataLoader(testset, batch_size=4, shuffle=False, num_workers=2) classes = ('plane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck')  展示一些训练图像 import matplotlib.pyplot as plt import numpy as np # 展示图像的函数 def imshow(img): img = img / 2 + 0.5 # unnormalize npimg = img.numpy() plt.imshow(np.transpose(npimg, (1, 2, 0))) plt.show() # 获取随机数据 dataiter = iter(trainloader) images, labels = dataiter.next() # 展示图像 imshow(torchvision.utils.make_grid(images)) # 显示图像标签 print(\u0026quot; \u0026quot;.join(\u0026quot;%5s\u0026quot; % classes[labels[j]] for j in range(4)))  truck horse dog frog  定义一个卷积神经网络 import torch.nn as nn import torch.nn.functional as F class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(3, 6, 5) # 3 input channels, 6 output channels, 5x5 convolutional kernel self.pool = nn.MaxPool2d(2, 2) # 池化层可以共用 self.conv2 = nn.Conv2d(6, 16, 5) self.fc1 = nn.Linear(16 * 5 * 5, 120) self.fc2 = nn.Linear(120, 84) self.fc3 = nn.Linear(84, 10) def forward(self, x): x = self.pool(F.relu(self.conv1(x))) x = self.pool(F.relu(self.conv2(x))) x = x.view(-1, 16 * 5 * 5) x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = self.fc3(x) return x net = Net()  定义损失函数和优化器 import torch.optim as optim criterion = nn.CrossEntropyLoss() optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)  训练网络 我们只需在数据迭代器上循环，将数据输入给网络，并优化。\nfor epoch in range(2): # 多批次循环 running_loss = 0.0 for i, data in enumerate(trainloader, 0): # 获取输入 inputs, labels = data # 梯度置0 optimizer.zero_grad() # 正向传播，反向传播，优化 outputs = net(inputs) loss = criterion(outputs, labels) loss.backward() optimizer.step() # 打印状态信息 running_loss += loss.item() if i % 2000 == 1999: # 每2000批次打印一次 print('[%d, %5d] loss: %.3f' % (epoch + 1, i + 1, running_loss / 2000)) running_loss = 0.0 print(\u0026quot;Finished Training\u0026quot;)  在测试集上测试网络 我们在整个训练集上进行了2次训练，但是我们需要检查网络是否从数据集中学习到有用的东西。 通过预测神经网络输出的类别标签与实际情况标签进行对比来进行检测。 如果预测正确，我们把该样本添加到正确预测列表。 第一步，显示测试集中的图片并熟悉图片内容。然后用\ndataiter = iter(testloader) images, labels = dataiter.next() # 输出是10个标签的能量。 一个类别的能量越大，神经网络越认为它是这个类别。所以让我们得到最高能量的标签。 outputs = net(images) _, predicted = torch.max(outputs, 1) # (maxvalues, indices) is returned # 显示图片 imshow(torchvision.utils.make_grid(images)) print('GroundTruth: ', ' '.join('%5s' % classes[labels[j]] for j in range(4))) print('Predicted: ', ' '.join('%5s' % classes[predicted[j]] for j in range(4)))  GroundTruth: cat ship ship plane Predicted: bird plane plane dog  接下来让看看网络在整个测试集上的结果如何。\ncorrect = 0 total = 0 with torch.no_grad(): for data in testloader: images, labels = data outputs = net(images) _, predicted = torch.max(outputs.data, 1) total += labels.size(0) correct += (predicted == labels).sum().item() print('Accuracy of the network on the 10000 test images: %d %%' % (100 * correct / total))  Accuracy of the network on the 10000 test images: 49 %  在识别哪一类的时候好，哪一类不好呢？\nclass_correct = list(0. for i in range(10)) class_total = list(0. for i in range(10)) with torch.no_grad(): for data in testloader: images, labels = data outputs = net(images) _, predicted = torch.max(outputs, 1) c = (predicted == labels).squeeze() for i in range(4): label = labels[i] class_correct[label] += c[i].item() class_total[label] += 1 for i in range(10): print('Accuracy of %5s : %2d %%' % (classes[i], 100 * class_correct[i] / class_total[i]))  Accuracy of plane : 69 % Accuracy of car : 69 % Accuracy of bird : 15 % Accuracy of cat : 43 % Accuracy of deer : 44 % Accuracy of dog : 22 % Accuracy of frog : 72 % Accuracy of horse : 58 % Accuracy of ship : 41 % Accuracy of truck : 58 %  在GPU上训练 把一个神经网络移动到GPU上训练就像把一个Tensor转换GPU上一样简单。并且这个操作会递归遍历有所模块，并将其参数和缓冲区转换为CUDA张量。\ndevice = torch.device(\u0026quot;cuda:0\u0026quot; if torch.cuda.is_available() else \u0026quot;cpu\u0026quot;) # 确认我们的电脑支持CUDA，然后显示CUDA信息 print(device) # 将递归遍历所有模块并将模块的参数和缓冲区 转换成CUDA张量 net.to(device)  记住: inputs 和 labels 也要转换。\ninputs, labels = inputs.to(device), labels.to(device)  ","date":1563846002,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563846002,"objectID":"8075514c4bd5fb90db94d2f5d06c07ee","permalink":"https://YuxinZhaozyx.github.io/post/pytorch-learning/note-4/","publishdate":"2019-07-23T09:40:02+08:00","relpermalink":"/post/pytorch-learning/note-4/","section":"post","summary":"[DEEP LEARNING WITH PYTORCH: A 60 MINUTE BLITZ] Training A Classifier","tags":["pytorch","deep learning"],"title":"PyTorch Learning Note-4","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["deep-learning"],"content":" 使用torch.nn包来构建神经网络。\nnn包依赖autograd包来定义模型并求导。 一个nn.Module包含各个层和一个forward(input)方法，该方法返回output。\n它是一个简单的前馈神经网络，它接受一个输入，然后一层接着一层地传递，最后输出计算的结果。\n神经网络的典型训练过程如下：\n 定义包含一些可学习的参数(或者叫权重)神经网络模型； 在数据集上迭代； 通过神经网络处理输入； 计算损失(输出结果和正确值的差值大小)； 将梯度反向传播回网络的参数； 更新网络的参数，主要使用如下简单的更新原则： weight = weight - learning_rate * gradient  定义网络 import torch import torch.nn as nn import torch.nn.functional as F class Net(nn.Module): def __init__(self): super(Net, self).__init__() # 1 input image channel # 6 output image channel # 5x5 square convolution kernel self.conv1 = nn.Conv2d(1, 6, 5) self.conv2 = nn.Conv2d(6, 16, 5) # an affine operation: y = Wx + b self.fc1 = nn.Linear(16 * 5 * 5, 120) self.fc2 = nn.Linear(120, 84) self.fc3 = nn.Linear(84, 10) def forward(self, x): # Max pooling over a (2, 2) window x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2)) # if the size is a square you can only specify a single number x = F.max_pool2d(F.relu(self.conv2(x)), 2) x = x.view(-1, self.num_flat_features(x)) x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = self.fc3(x) return x def num_flat_features(self, x): size = x.size()[1:] # all dimensions except the batch dimension num_features = 1 for s in size: num_features *= s return num_features net = Net() print(net)  Net( (conv1): Conv2d(1, 6, kernel_size=(5, 5), stride=(1, 1)) (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1)) (fc1): Linear(in_features=400, out_features=120, bias=True) (fc2): Linear(in_features=120, out_features=84, bias=True) (fc3): Linear(in_features=84, out_features=10, bias=True) )  在模型中必须要定义 forward 函数，backward 函数（用来计算梯度）会被autograd自动创建。 可以在 forward 函数中使用任何针对 Tensor 的操作。\nnet.parameters()返回可被学习的参数（权重）列表和值\nparams = list(net.parameters()) print(len(params)) print(params[0].size()) # params[0] == net.conv1.weight  10 torch.Size([6, 1, 5, 5]  测试随机输入32×32。 注：这个网络（LeNet）期望的输入大小是32×32，如果使用MNIST数据集来训练这个网络，请把图片大小重新调整到32×32。\ninput = torch.randn(1, 1, 32, 32) out = net(input) print(out)  tensor([[ 0.1052, -0.0361, 0.1122, 0.1072, 0.0887, 0.0477, 0.0916, -0.0594, -0.1450, 0.0574]], grad_fn=\u0026lt;AddmmBackward\u0026gt;)  将所有参数的梯度缓存清零，然后进行随机梯度的的反向传播：\nnet.zero_grad() out.backward(torch.randn(1, 10))   torch.nn 只支持小批量输入。整个 torch.nn 包都只支持小批量样本，而不支持单个样本。 例如，nn.Conv2d 接受一个4维的张量， 每一维分别是sSamples * nChannels * Height * Width（样本数*通道数*高*宽）。 如果你有单个样本，只需使用 input.unsqueeze(0) 来添加其它的维数   我们回顾一下到目前为止用到的类。\n回顾:\n torch.Tensor：一个用过自动调用 backward()实现支持自动梯度计算的 多维数组 ， 并且保存关于这个向量的梯度 nn.Module：神经网络模块。封装参数、移动到GPU上运行、导出、加载等。 nn.Parameter：一种变量，当把它赋值给一个Module时，被 自动地注册为一个参数。 autograd.Function：实现一个自动求导操作的前向和反向定义，每个变量操作至少创建一个函数节点，每一个Tensor的操作都h会创建一个接到创建Tensor和 编码其历史 的函数的Function节点。  损失函数 一个损失函数接受一对 (output, target) 作为输入，计算一个值来估计网络的输出和目标值相差多少。\nnn包中有很多不同的损失函数。 nn.MSELoss是一个比较简单的损失函数，它计算输出和目标间的均方误差， 例如：\ninput = torch.randn(1, 1, 32, 32) output = net(input) target = torch.randn(10) # 随机值作为样例 target = target.view(1, -1) # 使target和output的shape相同 criterion = nn.MSELoss() loss = criterion(output, target) print(loss)  tensor(1.1509, grad_fn=\u0026lt;MseLossBackward\u0026gt;)  反向传播 调用loss.backward()获得反向传播的误差。\n但是在调用前需要清除已存在的梯度，否则梯度将被累加到已存在的梯度。\n现在，我们将调用loss.backward()，并查看conv1层的偏差（bias）项在反向传播前后的梯度。\nnet.zero_grad() # 清除梯度 print('conv1.bias.grad before backward') print(net.conv1.bias.grad) loss.backward() print('conv1.bias.grad after backward') print(net.conv1.bias.grad)  conv1.bias.grad before backward None conv1.bias.grad after backward tensor([ 0.0027, -0.0142, 0.0197, 0.0021, -0.0018, 0.0001])  更新权重 在实践中最简单的权重更新规则是随机梯度下降（SGD）：\nweight = weight - learning_rate * gradient  我们可以使用简单的Python代码实现这个规则：\nlearning_rate = 0.01 for f in net.parameters(): f.data.sub_(f.grad.data * learning_rate)  但是当使用神经网络是想要使用各种不同的更新规则时，比如SGD、Nesterov-SGD、Adam、RMSPROP等，PyTorch中构建了一个包torch.optim实现了所有的这些规则。 使用它们非常简单：\nimport torch.optim as optim # create your optimizer optimizer = optim.SGD(net.parameters(), lr=0.01) criterion = nn.MSELoss() # in your training loop optimizer.zero_grad() # zero the gradient buffers output = net(input) loss = criterion(output, target) loss.backward() optimizer.step() # Does the update  ","date":1563799736,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563799736,"objectID":"57721738c96734bd345acc3a060fa776","permalink":"https://YuxinZhaozyx.github.io/post/pytorch-learning/note-3/","publishdate":"2019-07-22T20:48:56+08:00","relpermalink":"/post/pytorch-learning/note-3/","section":"post","summary":"[DEEP LEARNING WITH PYTORCH: A 60 MINUTE BLITZ] Neural Networks","tags":["pytorch","deep learning"],"title":"PyTorch Learning Note-3","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["deep-learning"],"content":" Autograd: 自动求导机制 PyTorch 中所有神经网络的核心是 autograd 包。 我们先简单介绍一下这个包，然后训练第一个简单的神经网络。\nautograd包为张量上的所有操作提供了自动求导。 它是一个在运行时定义的框架，这意味着反向传播是根据你的代码来确定如何运行，并且每次迭代可以是不同的。\n张量 Tensor torch.Tensor是这个包的核心类。如果设置 .requires_grad 为 True，那么将会追踪所有对于该张量的操作。 当完成计算后通过调用 .backward()，自动计算所有的梯度， 这个张量的所有梯度将会自动积累到 .grad 属性。\n要阻止张量跟踪历史记录，可以调用.detach()方法将其与计算历史记录分离，并禁止跟踪它将来的计算记录。\n为了防止跟踪历史记录（和使用内存），可以将代码块包装在with torch.no_grad()：中。 在评估模型时特别有用，因为模型可能具有requires_grad = True的可训练参数，但是我们不需要梯度计算。\n在自动梯度计算中还有另外一个重要的类Function.\nTensor 和 Function互相连接并生成一个非循环图，它表示和存储了完整的计算历史。 每个张量都有一个.grad_fn属性，这个属性引用了一个创建了Tensor的Function（除非这个张量是用户手动创建的，即，这个张量的 grad_fn 是 None）。\n如果需要计算导数，你可以在Tensor上调用.backward()。 如果Tensor是一个标量（即它包含一个元素数据）则不需要为backward()指定任何参数， 但是如果它有更多的元素，你需要指定一个gradient 参数来匹配张量的形状。\n 在其他的文章中你可能会看到说将Tensor包裹到Variable中提供自动梯度计算，Variable 这个在0.41版中已经被标注为过期了，现在可以直接使用Tensor，官方文档在这里   创建一个张量并设置 requires_grad=True 用来追踪他的计算历史\nx = torch.ones(2, 2, requires_grad=True) print(x) y = x + 2 # 对x进行操作 print(y) print(\u0026quot;y.grad_fn: \u0026quot;, y.grad_fn) # 结果y已经被计算出来了，所以，grad_fn已经被自动生成了 z = y * y * 3 # 对y进行操作 out = z.mean() print(z) print(out)  tensor([[1., 1.], [1., 1.]], requires_grad=True) tensor([[3., 3.], [3., 3.]], grad_fn=\u0026lt;AddBackward0\u0026gt;) y.grad_fn: \u0026lt;AddBackward0 object at 0x00000202022DAE48\u0026gt; tensor([[27., 27.], [27., 27.]], grad_fn=\u0026lt;MulBackward0\u0026gt;) tensor(27., grad_fn=\u0026lt;MeanBackward0\u0026gt;)  .requires_grad_( ... ) 可以改变现有张量的 requires_grad属性。 如果没有指定的话，默认输入的flag是 False。\na = torch.ones(2, 2) a = (a * 3) / (a - 1) print(a.requires_grad) a.requires_grad_(True) print(a.requires_grad) b = (a * a).sum() print(b.grad_fn)  False True \u0026lt;SumBackward0 object at 0x0000028141CBADA0\u0026gt;  梯度 反向传播 因为 out是一个纯量（scalar），out.backward() 等于out.backward(torch.tensor(1))。\nout.backward()  print gradients $\\frac{d(out)}{dx}$\nx = torch.ones(2, 2, requires_grad=True) y = x + 2 z = y * y * 3 out = z.mean() out.backward() print(x.grad)  tensor([[4.5000, 4.5000], [4.5000, 4.5000]])  可以用自动求导做更多操作\nx = torch.randn(3, requires_grad=True) y = x * 2 while y.data.norm() \u0026lt; 1000: y = y * 2 print(y) gradients = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float) y.backward(gradients) print(x.grad)  tensor([-790.8533, 793.1236, 307.1018], grad_fn=\u0026lt;MulBackward0\u0026gt;) tensor([5.1200e+01, 5.1200e+02, 5.1200e-02])  如果.requires_grad=True但是你又不希望进行autograd的计算， 那么可以将变量包裹在 with torch.no_grad()中:\nprint(x.requires_grad) print((x ** 2).requires_grad) with torch.no_grad(): print(x.requires_grad) print((x ** 2).requires_grad)  True True True False   更多阅读： autograd 和 Function 的官方文档   ","date":1563794428,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563794428,"objectID":"00ccd313b556c9c6807824e9a761980c","permalink":"https://YuxinZhaozyx.github.io/post/pytorch-learning/note-2/","publishdate":"2019-07-22T19:20:28+08:00","relpermalink":"/post/pytorch-learning/note-2/","section":"post","summary":"[DEEP LEARNING WITH PYTORCH: A 60 MINUTE BLITZ] AUTOGRAD: Automatic Differentiation","tags":["pytorch","deep learning"],"title":"PyTorch Learning Note-2","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["deep-learning"],"content":" PyTorch 是什么? 基于Python的科学计算包，服务于以下两种场景:\n 作为NumPy的替代品，可以使用GPU的强大计算能力 提供最大的灵活性和高速的深度学习研究平台  Tensor 张量 Tensors与Numpy中的 ndarrays类似，但是在PyTorch中 Tensors 可以使用GPU进行计算.\nfrom __future__ import print_function import torch  创建一个 5x5 的矩阵，但未初始化:\nx = torch.empty(5, 3) print(x)  tensor([[9.5511e-39, 1.0102e-38, 4.6837e-39], [4.9592e-39, 5.0510e-39, 9.9184e-39], [9.0000e-39, 1.0561e-38, 1.0653e-38], [4.1327e-39, 8.9082e-39, 9.8265e-39], [9.4592e-39, 1.0561e-38, 1.0653e-38]])  创建一个随机初始化的矩阵:\nx = torch.rand(5, 3) print(x)  tensor([[0.6004, 0.9095, 0.5525], [0.2870, 0.2680, 0.1937], [0.9153, 0.0150, 0.5165], [0.7875, 0.7397, 0.9305], [0.8575, 0.1453, 0.2655]])  创建一个0填充的矩阵，数据类型为long:\nx = torch.zeros(5, 3, dtype=torch.long) print(x)  tensor([[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]])  创建tensor并使用现有数据初始化:\nx = torch.tensor([5.5, 3]) print(x)  tensor([5.5000, 3.0000])  根据现有的张量创建张量。 这些方法将重用输入张量的属性，例如， dtype，除非设置新的值进行覆盖\nx = torch.tensor([5.5, 3]) print(x) x = x.new_ones(5, 3, dtype=torch.double) # new_* 方法来创建对象 print(x) x = torch.randn_like(x, dtype=torch.float) # 覆盖 dtype! print(x) # 对象的size 是相同的，只是值和类型发生了变化  tensor([5.5000, 3.0000]) tensor([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]], dtype=torch.float64) tensor([[-0.5648, 1.4639, -0.1247], [ 0.4187, 0.0255, -0.0938], [-1.2237, 0.3889, 0.9847], [-0.2423, -3.3706, -0.3511], [-1.1498, -1.1044, 0.4582]])  获取 size  使用size方法与Numpy的shape属性返回的相同，张量也支持shape属性   x = torch.ones(5, 3) print(x) print(\u0026quot;x.size(): \u0026quot;, x.size()) print(\u0026quot;x.shape: \u0026quot;, x.shape)  tensor([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]) x.size(): torch.Size([5, 3]) x.shape: torch.Size([5, 3])   torch.Size()返回值是tuple类型，所以它支持tuple类型的所有操作   Operation 操作 加法 x = torch.rand(5, 3) y = torch.rand(5, 3) sum = x + y # 加法1，操作符 sum = torch.add(x, y) # 加法2，函数 torch.add(x, y, out=sum) # 加法3，提供输出张量sum作为参数  替换 # add x to y y.add_(x)   任何 以_ 结尾的操作都会用结果替换原变量. 例如: x.copy_(y), x.t_(), 都会改变 x.   截取 print(x[:, 1])  view / reshape torch.view 可以改变张量的维度和大小，与numpy的reshape类似\nx = torch.randn(4, 4) y = x.view(16) z = x.view(-1, 8) # size -1 从其他维度推断 print(x.size(), y.size(), z.size())  torch.Size([4, 4]) torch.Size([16]) torch.Size([2, 8])  只有一个元素的张量取值 如果你有只有一个元素的张量，使用.item()来得到Python数据类型的数值\nx = torch.randn(1) print(x) print(x.item())  tensor([-0.2036]) -0.203627809882164   更多操作点击此处   Numpy 转换 Torch Tensor与NumPy数组共享底层内存地址，修改一个会导致另一个的变化。\nTorch Tensor 转换成 NumPy数组 a = torch.ones(5) print(a) b = a.numpy() print(b) a.add_(1) print(a) print(b)  tensor([1., 1., 1., 1., 1.]) [1. 1. 1. 1. 1.] tensor([2., 2., 2., 2., 2.]) [2. 2. 2. 2. 2.]  NumPy数组 转换成 Torch Tensor a = np.ones(5) b = torch.from_numpy(a) print(a) print(b) np.add(a, 1, out=a) print(a) print(b)  [1. 1. 1. 1. 1.] tensor([1., 1., 1., 1., 1.], dtype=torch.float64) [2. 2. 2. 2. 2.] tensor([2., 2., 2., 2., 2.], dtype=torch.float64)   所有的 Tensor 类型默认都是基于CPU， CharTensor 类型不支持到 NumPy 的转换.   CUDA 张量 使用.to 方法 可以将Tensor移动到任何设备中\nx = torch.rand(1) # is_available 函数判断是否有cuda可以使用 # torch.device 将张量移动到指定的设备中 if torch.cuda.is_available(): device = torch.device(\u0026quot;cuda\u0026quot;) # a CUDA 设备对象 y = torch.ones_like(x, device=device) # 直接从GPU创建张量 x = x.to(device) # 或者直接使用 .to(\u0026quot;cuda\u0026quot;) 将张量移动到cuda中 z = x + y print(z) print(z.to(\u0026quot;cpu\u0026quot;, torch.double)) # .to 也会对变量的类型做更改  tensor([1.2840], device='cuda:0') tensor([1.2840], dtype=torch.float64)  ","date":1563790312,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563790312,"objectID":"9b809d4fa5c0d7ba68ab06ed30acecfa","permalink":"https://YuxinZhaozyx.github.io/post/pytorch-learning/note-1/","publishdate":"2019-07-22T18:11:52+08:00","relpermalink":"/post/pytorch-learning/note-1/","section":"post","summary":"[DEEP LEARNING WITH PYTORCH: A 60 MINUTE BLITZ] What is PyTorch?","tags":["pytorch","deep learning"],"title":"PyTorch Learning Note-1","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["deep-learning"],"content":" This project is to record my learning road of pytorch framework.\nTutorial  官方教程 PyTorch中文手册  ","date":1563788273,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563788273,"objectID":"82e9657a087bc6720107f6f1aac419ea","permalink":"https://YuxinZhaozyx.github.io/project/pytorch-learning/","publishdate":"2019-07-22T17:37:53+08:00","relpermalink":"/project/pytorch-learning/","section":"project","summary":"My Learning road of pytorch","tags":["pytorch","deep learning"],"title":"PyTorch Learning","type":"project"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["system"],"content":" 最近使用windows安装一些软件的过程中，出现了环境变量PATH最长限制2047个字符的问题。所幸我习惯下载软件的zip包，自己解压后再将其添加到环境变量中，因此才能及时发现这个问题。用安装包安装可能还不会提示这个问题，出情况也就比较难去定位问题了。\nProblem 问题  环境变量PATH (或者是Path，windows的环境变量不区分大小写) 最大长度为2047个字符，要添加新的位置到环境变量中就超出了限制。  Solution 解决方法 用一个新的环境变量PATH2来拓展PATH，具体步骤如下：\n 打开 计算机 \u0026gt;\u0026gt; 属性 \u0026gt;\u0026gt; 高级系统设置 \u0026gt;\u0026gt; 环境变量 在系统变量中找到 PATH (不区分大小写)， 将其名称改成 PATH2。 新建一环境变量 PATH，在其中添加一个值%PATH2% 用于将 PATH2 包含进来。  完成。\n由于新的 PATH 的只有 %PATH2% 一个值，后续要添加到环境变量中的位置都可以添加到 PATH 中，相当于扩容了 PATH，而 PATH2 是透明的，对以后的操作并不会有什么影响。\n","date":1563587639,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563587639,"objectID":"6c60a7ee38a05eb20cffc3664253cb51","permalink":"https://YuxinZhaozyx.github.io/post/windows-path-limited-length/","publishdate":"2019-07-20T09:53:59+08:00","relpermalink":"/post/windows-path-limited-length/","section":"post","summary":"最近使用windows安装一些软件的过程中，出现了环境变量PATH最长限制2047个字符的问题。","tags":["windows","path"],"title":"Windows PATH 长度限制最多2047个字符","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["paper-note"],"content":" 作者提出了R-C3D模型用于连续视频的行为检测(Activity Detection in Continuous Videos)。连续视频的行为检测需要完成两个目标：\n 识别出行为的类别 定位行为发生的时间范围  这两个问题正是R-C3D着力解决的。\n术语缩写    缩写 全称     R-C3D Region Convolutional 3D Network   RoI Region of Interest   RPN Region Proposal Network    R-C3D 的特点  端到端的训练方式； 可以检测出任意时长的行为； 检测速度快，一次性能计算的帧仅受限于GPU内存； 推广Faster-RCNN的Region Proposal Network到时域； 推广Faster-RCNN的RoI Pooling算法到时域，提出3D RoI Pooling。 有监督学习(特别之处是允许一个视频中包含多种行为，且行为的时间范围有重叠)  R-C3D 的网络结构  上图为本人理解后绘制的网络结构图，如有错误，欢迎批评指正。   作者提出的 R-C3D 网络包含3个组件：\n a shared 3D ConvNet feature extractor a temporal proposal stage an activity classification and refinement stage  3D Convolutional Feature Hierarchies Input: sequence of RGB video frames with dimension $\\mathbb{R}^{3 \\times L \\times H \\times W}$.\n The input to the model is of variable length ($L$ can be arbitrary and is only limited by memory) Adopt the convolutional layers (conv1a to conv5b) of C3D 本例中，$H=W=112$  Output: a feature map $C_{conv5b} \\in \\mathbb{R}^{512 \\times \\frac{L}8 \\times \\frac{H}{16} \\times \\frac{W}{16} }$ (512 is the channel dimension of the layer conv5b) (activations)\n $C_{conv5b}$ activations are the shared input to the proposal and classification subnets.  Temporal Proposal Subnet Function: predicts potential proposal segments with respect to anchor segments and a binary label indicating whether the predicted proposal contains an activity or not.\n The anchor segments are pre-defined multi-scale windows centered at $L/8$ uniformly distributed temporal locations. Each temporal locaiton specifies $K$ anchor segments, each at a different fixed scale. Thus, the total number of anchor segments is $(L/8) * K$ . a 3D convolutional filter with kernel size $3 \\times 3 \\times 3$ on top of $C_{conv5b}$ to extend the temporal proposal subnet. a 3D max-pooling filter with kernel size $1 \\times \\frac{H}{16} \\times \\frac{W}{16}$ to downsample the spatial dimensions (from $\\frac{H}{16} \\times \\frac{W}{16}$ to $1 \\times 1$) to a temporal only feature map $C_{tpn} \\in \\mathbb{R}^{512 \\times \\frac{L}8 \\times 1 \\times 1}$. The 512-dimensional feature vector at each temporal location ($512 \\times 1 \\times 1 \\times 1$) in $C_{tpn}$ is used to predict :  a relative offset $\\{ \\delta c_i, \\delta l_i \\}$ to the center location the length of each anchor segment $\\{ c_i, l_i \\},\\, i \\in \\{ 1, \\cdots, K \\}$ the binary scores for each proposal being an activity or background  two $1 \\times 1 \\times 1$ convolutional layers on top of $C_{tpn}$ to predict proposal offsets and scores.  Training Temporal Proposal Subnet  Positive Label:  if the anchor segment overlaps with some ground-truth activity with IoU \u0026gt; 0.7. or if the anchor segment has the highest IoU overlap with some ground-truth activity.  Negative Label:  if the anchor has IoU overlap lower than 0.3 with all ground-truth activities  All others are held out from training sample balanced batches with a positive/negative ratio of 1:1  Activity Classification Subnet Functions:\n selecting proposal segments from the previous stage. three-dimensional region of interest (3D RoI) pooling to extract fixed-size features for selected proposals. activity classification and boundary regression for the selected proposals based on the pooled features.\n greedy Non-Maximum Suppression (NMS, threshold=0.7) to eliminate highly overlapping and low confidence proposals.\n  3D RoI Pooling  对于一个 $l \\times h \\times w$ 的不定输入张量（每次输入的张量的尺寸可以不一样），3D RoI Pooling 将其规约到固定的大小 $l_s \\times h_s \\times w_s$ .  $l \\times h \\times w$ 先被分成 $l_s \\times h_s \\times w_s$ 个大小约为 $\\frac{l}{l_s} \\times \\frac{h}{h_s} \\times \\frac{w}{w_s}$ 的小张量，每个张量内做max pooling 得到 $l_s \\times h_s \\times w_s$ 的张量。  在本例中，由于$H=W=112$，$C_{conv5b} \\in \\mathbb{R}^{512 \\times \\frac{L}8 \\times 7 \\times 7}$，将 $512 \\times \\frac{L}8 \\times 7 \\times 7$ 的张量固定为 $512 \\times 1 \\times 4 \\times 4$. The output of the 3D RoI pooling is fed to a series of two fully connected layers. 3D RoI pooling 的两层 fully connected layers 之后是 classification layer 和 regression layer.  classification layer 和 regression layer 是两个独立的双层 fully connected layers, 它们的输入都是 3D RoI pooling 后 fully connected layers 的输出。   Training Classification Subnet  Positive Label:  if the proposal has the highest IoU overlap with a ground-truth activity and IoU \u0026gt; 0.5.  Negative Label:  proposals with IoU overlap lower than 0.5 with all grouth-truth activities.  Positive : Negative = 1 : 3  Optimization Loss Function: $$ Loss = \\frac1{N_{cls}} \\sum_i L_{cls}(a_i, a_i^*) + \\lambda \\frac1{N_{reg}} a_i^* L_{reg}(t_i, t_i^*) $$\nwhere,\n $L_{cls}$ is softmax loss function $L_{reg}$ is smooth L1 loss function $N_{cls}$ is batch size $N_{reg}$ is the number of anchor/proposal segments $\\lambda$ is the loss trade-off parameter and is set to 1. $i$ is the anchor/proposal segments index in a batch $a_i$ is the predicted probability of the proposal or activities $a_i^*$ is the ground truth $t_i = \\{ \\delta \\hat{ c_i} , \\delta \\hat{ l_i} \\}$ represents predicted relative offset to anchor segments or proposals. $t_i^* = \\{ \\delta c_i , \\delta l_i \\}$ represents the coordinate transformation of ground truth segments to anchor segments or proposals.  $$ \\begin{cases} \\delta c_i = (c_i^* - c_i) / l_i \\\\\n\\delta l_i = \\log (l_i^* / l_i) \\end{cases} $$\nwhere $c_i$ and $l_i$ are the center location and the length of anchor segments or proposals while $c_i^*$ and $l_i^*$ denote the same for the ground truth activity segment.\n The above loss function is applied for both the temporal proposal subnet and the activity classification subnet. In proposal subnet,  $L_{cls}$ predicts whether the proposal contains an activity or not. $L_{reg}$ optimizes the relative displacement between proposals and ground truths.\n  In classification subnet,  $L_{cls}$ predicts the specific activity class for the proposal. (The number of classes are the number of activities + one for background) $L_{reg}$ optimizes the relative displacement between activities and ground truths.   Prediction  预测出$t_i$后需要逆变换把相对坐标变成绝对坐标。 为了充分利用向量化实现的优势，用最后一帧去填充视频较短不足的部分。 NMS at a lower threshold (0.1 less than the mAP evalution threshold) is appled to the predicted activities to get the final activity predictions.  Experiments Experiments on THUMOS\u0026rsquo;14  divide 200 untrimmed videos from the validation set into 180 training and 20 held out videos to get the best hyperparameter setting. Since the GPU memory is limited, the authors first create a buffer of 768 frames at 25 fps which means approximately 30 seconds of video. The authors create the buffer by sliding from the beginning of the video to the end, denoted as the \u0026ldquo;one-way buffer\u0026rdquo;. An additional pass from the end of the video to the beginning is used to increase the amount of training data, denoted as \u0026ldquo;two-way buffer\u0026rdquo;. initialize the 3D ConvNet part of our model with C3D weights trained on Sports-1M and finetuned on UCF101. allow all the layers of R-C3D to be trained on THUMOS\u0026rsquo;14 with a fixed learning rate of 0.0001. K = 10, with scale values [2, 4, 5, 6, 8, 9, 10, 12, 14, 16]  Experiments on ActivityNet  sample frames at 3 fps input buffer: 768 K=20, with scale values [1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64]  Experiments on Charades  sample frames at 5 fps input buffer: 768 K=18, with scale values [1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48]  ","date":1563360243,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563360243,"objectID":"2eb3e415091a8531c5415bbd81bbd5eb","permalink":"https://YuxinZhaozyx.github.io/paper-note/r-c3d-region-convolutional-3d-network-for-temporal-activity-detection/","publishdate":"2019-07-17T18:44:03+08:00","relpermalink":"/paper-note/r-c3d-region-convolutional-3d-network-for-temporal-activity-detection/","section":"paper-note","summary":"作者提出了R-C3D模型用于连续视频的行为检测(Activity Detection in Continuous Videos)。连续视频的行为检测需要完成两个目标： 识别出行为的类别 定","tags":["R-C3D","C3D","Activity Detection","deep learning"],"title":"[论文笔记] R-C3D: Region Convolutional 3D Network for Temporal Activity Detection","type":"paper-note"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["computer vision"],"content":" 目标检测算法包含了三个要素：Backbone + Head + Postprocess，对于Postprocess部分，最早用的是NMS，后面出现了Soft NMS和Softer NMS，本文将分别解释它们的动机和原理。\nNMS NMS，它的全称为“non-maximum supression”，中文名“非极大值抑制”。为什么要使用NMS呢？因为在目标检测任务中，不管是one-stage还是two-stage的算法，最终算法都会预测出多个proposals。在后处理部分中，需要对这些proposals做筛选。\n动机  优先选择分类score较高的proposal； 跟分类score重叠较多的proposals，可以视为冗余的预测框；  步骤  将算法预测出的所有proposals，按照不同的类别标签分组； 对于每一个类别的所有proposals，记作$B$，筛选后的proposals集合记作$D$，执行如下操作，  a. 选择score最高的proposal，记作$M$，加入到$M$中； b. 计算剩余的proposals与$M$之间的IoU，若大于阈值$N_t$ ，则舍弃，否则保留； c. 若步骤b中得到的所有proposals为空，则跳回步骤b，否则执行步骤a。  经过后处理之后，所有类别保留的有效proposals集合为 $S={D_1, D_2, …, D_c}$ ，其中$c$表示目标类别的数量；  伪代码 Soft-NMS 动机 由上可见，NMS算法保留score最高的预测框，并将与当前预测框重叠较多的proposals视作冗余，显然，在实际的检测任务中，这种思路有明显的缺点，比如对于稠密物体检测，当同类的两个目标距离较近时，如果使用原生的NMS，就会导致其中一个目标不能被召回，为了提高这种情况下目标检测的召回率，Soft-NMS应运而生。对于Faster-RCNN在MS-COCO数据集上的结果，将NMS改成Soft-NMS，mAP提升了1.1%。\n算法思想 Soft-NMS，原文的标题为“Improving Object Detection With One Line of Code”。NMS采用“一刀切”的思想，将重叠较多的proposals全部视作冗余，而Soft-NMS，采用了“迂回”战术，它认为重叠较多的proposals也有可能包含有效目标，只不过重叠区域越大可能性越小。参见下图，NMS会将绿色框的score置0，而Soft-NMS会将绿色框的score由0.8下降到0.4，显然Soft-NMS更加合理。\n那么问题来了，怎么建立IoU和score之间的联系呢，文章中给出的公式如下:\n$$ s_i = s_i e^{-\\frac{\\text{iou}(M, b_i)^2}{\\sigma}}, \\forall b_i \\notin D $$\n其中$D$表示所有保留的有效框集合, $b_i$表示待过滤的第$i$个预测框，$s_i$为第$i$个预测框对应的分类score。这里使用了高斯函数作为惩罚项，当$iou=0$时，分类score不变，当$0\u0026lt;iou\u0026lt;1$时，分类score会做衰减。以上图为例，绿色框$b_i$和红色框$M$的iou大于0，经过Soft-NMS后该绿色框的分类score由0.8衰减到0.4，可以推断出，如果图中有第2个绿色框，且其与红色框的重叠区域更大时，那么这个新的绿色框的分类score可能由0.8衰减到0.01。\n步骤 伪代码 Softer-NMS 动机 现有方法的问题 作者使用VGG-16 faster R-CNN测试了MS-COCO数据集中的图片，论文中贴了两张检测失败的代表图片，如下图\n左图存在的问题：检测出来的2个proposals，沿着y坐标轴方向的定位均不准确；\n结论：检测算法预测出来的proposals的坐标不一定准确；\n右图存在的问题：检测出来的2个proposals，右边的框分类score较高，但是却沿着x坐标轴方向的定位不准确；\n结论：分类score高不一定定位score高，也即classification confidence和 localization confidence不具有一致性。\n本文解决方法 针对上面的问题， 1. 既然proposals的坐标不准确，那么即便NMS也无能为力了，所以需要重新设计坐标回归的方式)； 2. 既然分类score高不一定定位score高，那么NMS和Soft-NMS的做法（只基于分类score对proposals做排序）是不准确的，所以需要同时预测出检测框的定位score。\n算法 Softer-NMS的算法框架如下图，可以看出，它跟fast R-CNN是非常相似的，区别在于回归任务中多了一个Box std分支，这里需要解释一下，比如预测出的bounding box的坐标为$x_1, y_1, x_2, y_2$，该分支会预测出每个坐标的标准差，显然，当坐标的标准差越小时，表明预测得到的坐标值越可信，也即Box std分支用于表征定位任务的置信度。\n\r\rfast R-CNN\r\r\r\r\rfaster-NMS\r\r\r定位任务 在fast R-CNN中，作者使用的是均方误差函数作为定位损失，总的目的是让定位出的坐标点尽可能逼近groundtruth box。本文中为了在定位坐标同时输出定位score，使用了高斯函数建模坐标点的位置分布，公式如下，\n$$ P_\\Theta(x) = \\frac1{2\\pi \\sigma^2} e^{-\\frac{(x-x_e)^2}{2\\sigma^2}} $$\n其中，$x_e$为预测的box位置，$\\sigma$表示box位置的标准差，衡量了box位置的不确定性。因为groundtruth位置是确定的，所以groundtruth box的坐标为标准差为0的高斯分布，也即Dirac delta函数，公式如下，\n$$ P_D(x) = \\delta (x-x_g) $$\n其中，$x_g$ 为groundtruth box的坐标。\n定位损失 回归任务的目的是让预测框尽可能逼近真实框，也即$P_\\theta(x)$和$P_D(x)$为同一分布，衡量概率分布的相似性，自然而然会想到KL散度，关于KL散度的概念，大家可以参见维基百科，值得一提的是，KL散度本身具有不对称性，通常，在实际应用中为了使用对称性，使用的是KL散度的变形形式，但本文中没有这么做。对公式做化简后，最终的简化形式如下，\n$$ L_{reg} = \\alpha \\left( \\left( x_g - x_e \\right) - \\frac12 \\right) - \\frac12 \\log \\left( \\alpha + \\epsilon \\right) $$\n后处理 经过上面的网络部分，Class分支会输出类别score，Box分支会输出box的4个坐标和这4个坐标对应的标准差（定位score），符号表示如下，\n$$ \\{ x1_i, y1_i, x2_i, y2_i, s_i, \\sigma_{x1, i}, \\sigma_{y1, i}, \\sigma_{x2, i}, \\sigma_{y2, i} \\} $$\n基于这些信息，新的后处理算法如下图，\n显然，softer-NMS基于回归出的定位confidence，对所有与$M$的IoU超过阈值$N_t$的proposals，使用加权平均更新其位置坐标，从而达到提高定位精度的目的。因为softer-NMS关注的是单个框的定位精度，而NMS和soft-NMS关注的是单个框的冗余性，显然关注点不同，所以softer-NMS可以和soft-NMS组合使用，此时效果更佳。\n总结 NMS：只适用于图片中目标比较稀疏的场景，即目标之间的间距较大；\nsoft-NMS：可以部分解决出现稠密目标的情况；\nsofter-NMS：该后处理方法采用\u0026rdquo;bagging\u0026rdquo;的思想，通过后处理提高定位精度，可以和soft-NMS组合使用。\n参考资料 [1] 目标检测后处理：从nms到softer nms\n[2] Improving Object Detection With One Line of Code\n[3] Bounding Box Regression with Uncertainty for Accurate Object Detection\n","date":1563343928,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563343928,"objectID":"a52ed5faf653819189652db8e9fd65f2","permalink":"https://YuxinZhaozyx.github.io/post/nms/","publishdate":"2019-07-17T14:12:08+08:00","relpermalink":"/post/nms/","section":"post","summary":"目标检测算法包含了三个要素：Backbone + Head + Postprocess，对于Postprocess部分，最早用的是NMS，后面出现了Soft NMS和Softer NMS，本文将分别解释它们的动机和原理。","tags":["NMS","soft-NMS","softer-NMS","computer vision"],"title":"NMS / soft-NMS / softer-NMS","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["hugo"],"content":"Hugo Academic主题自带的表格样式个人感觉不是特别美观，我更喜欢GitHub的表格样式，因此我花了点时间将Hugo Academic主题的表格样式改成GitHub的样式。\n在hugo建立的根目录下创建目录assets/css/，再在新创建的目录下创建custom.css。\n$ cd \u0026lt;your-hugo-website\u0026gt; $ mkdir -p assets/css/ $ vi assets/css/custom.css  在custom.css中添加以下样式代码。\ntable { display: block; overflow: auto; width: 100%; } table tr { background-color: #fff; border-top: 1px solid #c6cbd1; } table tr:nth-child(even) { background-color: #f6f8fa; } table tr:nth-child(odd) { background-color: #fff; } table\u0026gt;tbody\u0026gt;tr:nth-child(odd)\u0026gt;td, table\u0026gt;tbody\u0026gt;tr:nth-child(odd)\u0026gt;th { background-color: #fff; } table\u0026gt;thead\u0026gt;tr\u0026gt;th, table\u0026gt;tbody\u0026gt;tr\u0026gt;th, table\u0026gt;tfoot\u0026gt;tr\u0026gt;th, table\u0026gt;thead\u0026gt;tr\u0026gt;td, table\u0026gt;tbody\u0026gt;tr\u0026gt;td, table\u0026gt;tfoot\u0026gt;tr\u0026gt;td { padding: 6px 13px; } table th { font-weight: 600; } table th, td { vertical-align: middle !important; text-align: center; border: 1px solid #dfe2e5; padding: 6px 13px; } table img { background-color: transparent; }  将config/_default/params.toml中的plugins_css设置为[\u0026quot;custom\u0026quot;]，即\nplugins_css = [\u0026quot;custom\u0026quot;]  表格样式修改完成。\n该表格样式会将内容水平和垂直居中，并且单双行不同色。\n附带表格样式的效果图：\n","date":1563266388,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563266388,"objectID":"fd5701456e12d63bceab3da2762723b6","permalink":"https://YuxinZhaozyx.github.io/post/table-style-of-hugo-academic/","publishdate":"2019-07-16T16:39:48+08:00","relpermalink":"/post/table-style-of-hugo-academic/","section":"post","summary":"Hugo Academic主题自带的表格样式个人感觉不是特别美观，我更喜欢GitHub的表格样式，因此我花了点时间将Hugo Academic主题的表格样式改成GitHub的样式。","tags":["hugo","academic","github","table","style"],"title":"Hugo Academic 自定义表格样式","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["computer vision"],"content":" 在分类模型的评价标准中，PR曲线和ROC曲线被广泛应用于模型的性能评估。本文对PR曲线和ROC曲线及其相关的性能指标AUC, EER, AP, mAP, F1-measure进行介绍。\n混淆矩阵 Confusion Matrix   Truth $\\sum$    1 0   Estimate   1  TP   FP   TP+FP     0   FN   TN   FN+TN    $\\sum$   TP+FN   FP+TN   TP+TN+FP+FN     真正例 (True Positive, TP): 预测值和真实值都为1 假正例 (False Positive, FP): 预测值为1，真实值都为0 真反例 (True Negative, TN): 预测值和真实值都为0 假反例 (False Negative, FN): 预测值为0，真实值都为1  由这四个指标衍生出的指标：\n 查准率/准确率: $ \\text{Precision} = \\frac{TP}{TP+FP} $ 查全率/召回率: $\\text{Recall} = \\frac{TP}{TP+FN}$ 真阳率(True Positive Rate): $\\text{TPR} = \\frac{TP}{TP+FN}$ 假阳率(False Positive Rate): $\\text{FPR} = \\frac{FP}{FP+TN}$  ROC曲线 ROC定义 ROC曲线(Receiver Operating Characteristic Curve, 受试者工作特征曲线)是比较分类模型好坏的可视化工具。\n以FPR为x轴，TPR为y轴绘制图。如下图所示。\nROC曲线的衍生指标  EER(equal error rate): TPR=FPR时的值。 AUC(area under curve): ROC曲线下的面积  PR曲线 PR定义 PR曲线中P是Precision, R是Recall。\n以Recall为x轴，Precision为y轴。\n 假设一次Object Detection的结果为：（对于目标检测任务，当预测框与真实框IoU大于一定阈值时标记为TP；当预测框与真实框IoU小于一定阈值时标记为FP；一个真实框没有一个任何预测框与其重叠的为FN）  对其confidence进行排序:  根据上表的顺序绘制PR曲线：   至此我们得到了一张PR图。\nPR图的衍生指标  AP (Average Precision) mAP (mean Average Precision) F1-measure 综合评价指标  下面给出AP, mAP和F-measure的计算方法\n计算AP AP 是针对某一类别进行计算的。\n下面我们先从图的角度来理解AP。\n在2010年前，AP的计算方法是用11点插值法(11-point interpolation)：\n分别取 recall = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0] 十一个点插值，对每一个插值recall取 recall\u0026rsquo; \u0026gt;= recall 的点中precision最大的值作为该插值recall对应的precision。\n计算公式为: $$ P_{\\text{interpolation}} (r) = \\max_{r\u0026rsquo; \\ge r}\\left(P(r\u0026rsquo;)\\right) $$\n计算这11个插值recall对应precision的均值即是AP。 $$ \\begin{align} AP \u0026amp;= \\frac1{11} \\sum_{r \\in \\{0,0.1,\u0026hellip;,1\\}} P_{\\text{interpolation}} (r) \\\\\n\u0026amp;= \\frac1{11} \\left( 1 + 0.6666 + 0.4285 + 0.4285 + 0.4285 + 0 + 0 + 0 + 0 + 0 + 0 \\right) \\\\\n\u0026amp;= 26.84\\% \\end{align} $$ 2010年后，AP的计算方法不再使用11点插值法，而是考虑所有的点:\n对所有Recall值，将Recall大于等于该Recall值的所有点中的最大precision作为该recall值对应的precision。公式仍是 $$ P_{\\text{interpolation}} (r) = \\max_{r\u0026rsquo; \\ge r}\\left(P(r\u0026rsquo;)\\right) $$ 不同点在于AP的计算公式: $$ AP = \\int_0^1 P_{\\text{interpolation}}(r) \\, dr $$ 可以画出图帮助理解：\n按照上面的计算公式，则AP为： $$ \\begin{align} A1 \u0026amp;= (0.0666 - 0) \\times 1 = 0.0666 \\\\\nA2 \u0026amp;= (0.1333-0.0666) \\times 0.6666 = 0.04446222 \\\\\nA3 \u0026amp;= (0.4-0.1333) \\times 0.4285 = 0.11428095 \\\\\nA4 \u0026amp;= (0.4666 - 0.4) \\times 0.3043 = 0.02026638 \\\\\n\\\\\nAP \u0026amp;= A1+A2+A3+A4 \\\\\n\u0026amp;= 0.0666 + 0.04446222 + 0.11428095 + 0.02026638 \\\\\n\u0026amp;= 0.24560955 \\\\\n\u0026amp;= 24.56\\% \\end{align} $$ 以后的AP计算我会以2010年后的版本为准。\n接下来我将演示用表格来计算AP，而不使用绘图的方式：\n按Confidence置信度来降序做出表格:\n  Detection Precision Recall Max Precision for Any Recall $r' \\ge r$ Average Precision   R 1 0.0666 1 24.56%   Y 0.5   J 0.6666 0.1333 0.6666   A 0.5   U 0.4   C 0.3333   M 0.2857   F 0.25   D 0.2222   B 0.3 0.2 0.4285   H 0.2727   P 0.3333 0.2666   E 0.3846 0.3333   X 0.4285 0.4   N 0.4   T 0.375   K 0.3529   Q 0.3333   V 0.3157   I 0.3   L 0.2857   S 0.2727   G 0.3043 0.4666 0.3043   O 0.2916   计算方法和原理同上，但画出表格可以直接计算AP: $$ \\begin{align} AP \u0026amp;= 1 \\times 0.0666 + 0.6666 \\times (0.1333-0.0666) + 0.4285 \\times(0.4-0.1333) + 0.3043 \\times(0.4666 - 0.4) \\\\\n\u0026amp;= 0.24560955 \\end{align} $$\n计算mAP mAP的全程是mean Average Precision，即是所有AP的均值。因为AP只是正对一类的准确率进行评估，而在多类别检测/分类任务中就需要一个指标来对整个多分类任务的性能进行评估，这就是mAP。\n计算公式: $$ mAP = \\frac{\\sum_c AP_c}{N_{class}} $$\n计算F1-measure综合评价指标 F-measure又称F-Score，是Precision和Recall的加权调和平均，常用于评价分类模型的好坏。\n计算公式: $$ F_\\alpha = \\frac{(\\alpha^2+1)\\text{Precision}\\times\\text{Recall}}{\\alpha^2 \\text{Precision} + \\text{Recall}} $$\n常见的F$_1$-measure即为F-measure中$\\alpha=1$的特例: $$ F_1 = \\frac{2 \\times \\text{Precision}\\times\\text{Recall}}{\\text{Precision} + \\text{Recall}} $$\n该公式的另外一种形式可以帮助记忆: $$ \\frac2{F_1} = \\frac1{\\text{Precision}} + \\frac1{\\text{Recall}} $$\n参考资料 [1] rafaelpadilla/Object-Detection-Metrics\n[2] 目标检测中的mAP是什么含义?\n[3] 多标签图像分类任务的评价方法-mAP\n","date":1563195958,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563195958,"objectID":"ec006f8f4d9076bbfa3fa64f50d519dd","permalink":"https://YuxinZhaozyx.github.io/post/pr-roc/","publishdate":"2019-07-15T21:05:58+08:00","relpermalink":"/post/pr-roc/","section":"post","summary":"在分类模型的评价标准中，PR曲线和ROC曲线被广泛应用于模型的性能评估。本文对PR曲线和ROC曲线及其相关的性能指标AUC, EER, AP, mAP, F1-measure进行介绍。","tags":["PR","ROC","AUC","EER","AP","mAP","F1-measure","computer vision"],"title":"PR/ROC曲线及其相关性能评价指标","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["computer vision"],"content":"在目标检测任务中常常用IoU来计算预测窗口与真实窗口的交叠率。本文介绍IoU的概念。\nIoU (Intersection over Union, 交并比) 是两个窗口的交集与并集面积之比。\n 区域 Region-1 与 Region-2 的交集如上图黄色区域 区域 Region-1 与 Region-2 的并集如上图绿色区域  IoU计算公式: $$ IoU = \\frac{\\text{Region-1} \\cap \\text{Region-2}}{\\text{Region-1} \\cup \\text{Region-2}} $$\n","date":1563193232,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563193232,"objectID":"837bfe4450ba6b15bd8ce790ea5dbc0c","permalink":"https://YuxinZhaozyx.github.io/post/what-is-iou/","publishdate":"2019-07-15T20:20:32+08:00","relpermalink":"/post/what-is-iou/","section":"post","summary":"在目标检测任务中常常用IoU来计算预测窗口与真实窗口的交叠率。本文介绍IoU的概念。 IoU (Intersection over Union, 交并比) 是两个窗口的交集与并集面积之比。 区域 Region-1 与","tags":["IoU","computer vision"],"title":"What is IoU?","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["computer vision"],"content":" 上文讲了什么是RoI(Region of Interest, 感兴趣区域)，本文讲述RoI Pooling的概念。\nRoI Pooling 的作用 RoI Pooling是Pooling(池化)的一种，而且是针对RoI的池化。它的作用是输入尺寸不固定的特征图，输出尺寸固定的特征图。\nRoI Pooling 的输入  特征图 feature map：由原图像通过CNN计算得到的特征图 感兴趣区域 RoI: 许多候选框，形状为$1 \\times 5 \\times 1$ (4 个坐标[x,y,w,h] + 索引[index])   RoI的坐标的参考系是原图(CNN的输入)，而不是feature map。   RoI Pooling 的输出 输出batch个张量，其中batch的值等于RoI的个数，张量大小为(channel, w, h)， w和h人为指定。RoI Pooling的过程就是将一个个尺寸不同的RoI都映射成大小固定的(w, h)的RoI。\n图解 RoI Pooling 考虑一个 $8 \\times 8$ 大小的feature map，一个RoI，以及输出大小为 $2 \\times 2$.\n 输入固定大小的feature map  region proposal 投影后的位置  将其划分为 $(2 \\times 2)$ 个sections (因为输出大小为$2 \\times 2$)  对每个section做max pooling，可以得到:   参考引用 [1] Region of interest pooling explained\n[2] ROI Pooling层解析\n","date":1563162733,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563162733,"objectID":"f600ce5a8c70f01932d8ad25f8bc7be0","permalink":"https://YuxinZhaozyx.github.io/post/what-is-roi-pooling/","publishdate":"2019-07-15T11:52:13+08:00","relpermalink":"/post/what-is-roi-pooling/","section":"post","summary":"上文讲了什么是RoI(Region of Interest, 感兴趣区域)，本文讲述RoI Pooling的概念。 RoI Pooling 的作用 RoI Pooling是Pooling(池化)的","tags":["RoI","pooling","computer vision"],"title":"What is RoI Pooling?","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["computer vision"],"content":" RoI概念 RoI的全称是Region of Interest，中文名称是\u0026rdquo;感兴趣区域\u0026rdquo;。\nRoI是从图像中选择的一个图像区域，这个区域是你进行图像分析的重点。圈出这块区域可以得到一个子图像(subimage)，之后就可以在这个区域内使用进行进一步处理。\n目的：\n 减少处理时间 增加精度  ","date":1563160046,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563160046,"objectID":"a4032f773f82dc4f7c26ddf23b18b4d2","permalink":"https://YuxinZhaozyx.github.io/post/what-is-roi/","publishdate":"2019-07-15T11:07:26+08:00","relpermalink":"/post/what-is-roi/","section":"post","summary":"本文解释RoI(Region of Interest)的概念","tags":["RoI","computer vision"],"title":"What is RoI?","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["paper-note"],"content":" Faster R-CNN在Fast R-CNN的基础上做改进，提出用RPN（Region Proposal Network, 一种全卷积神经网络）代替Selective Search，降低检测耗时。Faster R-CNN由RPN和Fast R-CNN构成，RPN和Fast R-CNN共享卷积计算得到的特征图，以此降低计算量，使得Faster R-CNN可以在单GPU上以5fps的速度运行，且精度达到SOTA。\n术语缩写    缩写 全称     R-CNN Region Convolution Neural Network   RPN Region Proposal Network   FCN Fully Convolutional Network   SS Selective Search   ZF Zeiler and Fergus model   IoU Intersection-over-Union   RoI Region of Interest    Faster R-CNN \rFaster R-CNN is a single, unified network for object detection. The RPN module serves as the \u0026lsquo;attention\u0026rsquo; of the unified network.\r\r\rFaster R-CNN 由以下两个部分组成:\n Deep fully convolutional network that proposes regions Fast R-CNN detector that uses the proposed regions   The RPN module tells the Fast R-CNN module where to look.   Region Proposal Network \rRegion Proposal Network\r\r\rA Region Proposal Network (RPN) takes an image (of any size) as input and outputs a set of rectangular object proposals, each with an objectness score.\nThe authors model this process with a fully convolutional network.\n To generate region proposals, the authors slide a small network($n \\times n$ spatial window, $n=3$) over the convolutional feature map output by the last shared convolution layer.\n Each sliding window is mapped to a lower-dimensional feature (256-d for ZF and 512-d for VGG, with ReLU following).\n This feature is fed into two sibling fully-connected layers \u0026ndash; a box-regression layer ($reg$) and a box-classification layer ($cls$). This architecture is naturally implemented with and $n \\times n$ convolutional layer followed by two sibling $1 \\times 1$ convolutional layers (for $reg$ and $cls$ respectively).\n  Anchor the number of maximum possible proposals for each location is denoted as $k$.\n $reg$ layer has $4k$ outputs $(x, y, w, h)$ encoding the coordinates of $k$ boxes $cls$ layer has $2k$ outputs scores that estimate probability of object or not object for each proposal. (implemented as a two-class softmax layer)  The $k$ proposals are parameterized relative to $k$ reference boxes, which we call anchors.\n An anchor is centered at the sliding window in question, and is associated with a scale and aspect ratio (宽高比). For a convolutional feature map of a size $W \\times H $ , there are $WHk$ anchors in total.  use 3 scales with box areas of $128^2$, $256^2$, $512^2$ pixels, and 3 aspect ratios of 1:1, 1:2, 2:1.\nMulti-Scale Anchors as Regression Reference \rDifferent schemes for addressing multiple scales and sizes.\r\r\r作者采取b)和c)变化窗口形状和大小的方法，而不使用a)变换图片大小的方法。\nLost Function Positive anchor:\n the anchor/anchors with the highest Intersection-over-Union(IoU) overlap with a ground-truth box (作者采用). an anchor that has an IoU overlap \u0026gt; 0.7 with any grouth-truth box (作者不采用).  Negative anchor:\n non-positive anchor if its IoU \u0026lt; 0.3 for all grouth-truth boxes.  lost function for an image $$ L(\\{p_i\\}, \\{t_i\\}) = \\frac1{N_{cls}} \\sum_i{L_{cls}} (p_i, p_i^*) + \\lambda \\frac{1}{N_{reg}} \\sum_i {L_{reg}(t_i, t_i^*)} $$\n $L_{cls}$ is log loss over two classes (object $vs.$ not object) $L_{reg}(t_i, t_i^*) = R(t_i - t_i^*)$ where $R$ is the robust loss function (smooth $L_1$) $N_{cls}$ is the mini-batch size (i.e., $N_{cls}=256$) $N_{reg}$ is the number of anchor locations (i.e., $N_{reg} \\approx 2400$) $\\lambda = 10$ and thus both $cls$ and $reg$ terms are roughly equally weighted.   The normalization as above is not required and could be simplified.   $$ \\begin{align} \u0026amp;t_x = (x-x_a)/w_a, \u0026amp; t_y = (y-y_a)/h_a, \\\\\n\u0026amp;t_w = \\log(w/w_a), \u0026amp; t_h = log(h/h_a), \\\\\n\u0026amp;t^*_x = (x-x^*_a)/w_a, \u0026amp; t^*_y = (y^*-y_a)/h_a, \\\\\n\u0026amp;t^*_w = \\log(w^*/w_a), \u0026amp; t^*_h = log(h^*/h_a), \\\\\n\\end{align} $$\nTraining RPNs The RPN can be trained end-to-end by back-propagation and stochastic gradient descent (SGD).\n 一张图片包含多个正样本和负样本(正样本少于负样本) 随机采样256个样本用于计算loss of a mini-batch 初始化: Gaussian distribution (mean=0, standard deviation=0.01) momentum: 0.9, weight decay: 0.0005  Sharing Features for RPN and Fast R-CNN 4 - Step Alternating Training  Train the RPN as described previously. Train a separated detection network (ImageNet-pre-trained) by Fast R-CNN using the proposals generated by step-1 RPN. Use the detector network to initialize RPN training, but fix the shared convolutional layers and only fine-tune the layers unique to RPN. keeping the shared convolutional layers fixed, fine-tune the unique layers of Fast R-CNN.  ","date":1563082812,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1563082812,"objectID":"59e2d51c373420c0b0e8de84ec77a4d5","permalink":"https://YuxinZhaozyx.github.io/paper-note/faster-r-cnn-towards-real-time-object-detection-with-region-proposal-networks/","publishdate":"2019-07-14T13:40:12+08:00","relpermalink":"/paper-note/faster-r-cnn-towards-real-time-object-detection-with-region-proposal-networks/","section":"paper-note","summary":"Faster R-CNN在Fast R-CNN的基础上做改进，提出用RPN（Region Proposal Network, 一种全卷积神经网络）代替Selective Search，降低检","tags":["R-CNN","VGG","Faster R-CNN","RPN","object detection","deep learning"],"title":"[论文笔记] Faster R-CNN: Towards Real-Time Object Detection With Region Proposal Networks","type":"paper-note"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["hugo"],"content":" Academic主题可以使用Font Awesome和Academicons的各种图标。但是Academic本身支持的版本不一定是最新的，部分图标因此不会显示。因此本文将介绍如何更换成最新的、速度更快的源。\nicon包简要介绍 icon包fab包括以下品牌图标：\n twitter，weixin，weibo，linkedin，github，facebook，pinterest，twitch，youtube，instagram，soundcloud 查看所有图标  icon包fas和far包括以下常规图标：\n 传真，信封（电子邮件），评论（论坛） 查看所有图标  icon包ai包括以下学术图标：\n cv，google-scholar，arxiv，orcid，researchgate，mendeley 查看所有图标  在Hugo-Academic中使用图标 以python图标为例，在Font Awesome中找到python的编号为“fab fa-python\u0026rdquo;。\n在skills面板中使用图标： /content/home/skills.md\n[[feature]] icon=\u0026quot;python\u0026quot; icon_pack=\u0026quot;fab\u0026quot; name=\u0026quot;Python\u0026quot; description=\u0026quot;80%\u0026quot;  在about面板中使用图标： /content/authors/\u0026lt;author-name\u0026gt;/_index.md\nsocial: - icon: python icon_pack: fab link: \u0026quot;...\u0026quot;   注意: icon的值不是完整的编号，要去除fa-前缀。   更换Hugo-Academic主题使用的Font Awesome源 我们将使用Font Awesome的最新版本5.9.0(截至至2019年7月10日)来代替Academic默认使用的5.6.0版本。\n我使用cdnjs提供的CDN源，点击此处查看当前最新版本。\n分别复制url和sri。\n修改到themes/academic/data/assets.toml中。\n[css.fontAwesome] version = \u0026quot;5.9.0\u0026quot; sri = \u0026quot;sha256-PF6MatZtiJ8/c9O9HQ8uSUXr++R9KBYu4gbNG5511WE=\u0026quot; url = \u0026quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/%s/css/all.css\u0026quot;  更新完成。\n","date":1562903133,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1562903133,"objectID":"37b25fadef073ca7b942263b93d52fb8","permalink":"https://YuxinZhaozyx.github.io/post/icons-of-hugo-academic/","publishdate":"2019-07-12T11:45:33+08:00","relpermalink":"/post/icons-of-hugo-academic/","section":"post","summary":"Academic主题可以使用Font Awesome和Academicons的各种图标。但是Academic本身支持的版本不一定是最新的，部分图标因此不会显示。因此本文将介绍如何更换成最新的、速度更快的源。","tags":["hugo","academic","icon","cdnjs"],"title":"Hugo Academic Icon配置","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["hugo"],"content":" 前言 在先前的文章中，我使用Gitment来作为我的博客的评论模块，但使用一段时间后发现了Gitment的一些缺点，针对这些缺点，我找到了比Gitment功能上更完善的Gitalk。\n我为什么选择Gitalk? 在这之前我先说一下我为什么弃坑Gitment，Gitment本身的想法很好，使用github的issue来存储评论，避免了使用第三方的服务而第三方停止提供服务的风险(比如多说和网易云跟帖)。但它也有以下缺点：\n 不兼容移动端 不支持多语言 不支持免打扰模式 不支持快捷键提交  上述问题中对我来说最重要并最终让我决定更换评论模块的是Gitment不兼容移动端的缺点。\n而Gitalk没有以上的缺点。\nGitalk评论模块介绍  Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。\n  项目地址 官方示例  特性  使用 GitHub 登录 支持多语言 [en, zh-CN, zh-TW, es-ES, fr, ru] 支持个人或组织 免干扰模式（设置 distractionFreeMode 为 true 开启） 快捷键提交评论 （ctrl + enter） 支持移动端 自动初始化评论  基本使用 注册OAuth Application 需要先在github上注册一个OAuth Application，点击此处注册。\nCallback URL 填写评论页面对应的域名，如https://YuxinZhaozyx.github.io。\n 其他内容可以随便写，但Callback URL一定要填写正确。   注册成功后会得到一个Client ID和Client Secret，这将被用于之后的用户登录认证。\n引入Gitalk 将以下代码添加到你的页面：\n\u0026lt;section id=\u0026quot;comments\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;gitalkContainer\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\u0026quot;\u0026gt; \u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var gitalk = new Gitalk({ clientID: 'GitHub Application Client ID', clientSecret: 'GitHub Application Client Secret', repo: 'GitHub repo', owner: 'GitHub repo owner', admin: ['GitHub repo owner and collaborators, only these guys can initialize github issues'], id: location.pathname, // Ensure uniqueness and length less than 50 distractionFreeMode: false // Facebook-like distraction free mode }); gitalk.render('gitalkContainer'); \u0026lt;/script\u0026gt; \u0026lt;/section\u0026gt;   id的长度要限制在50个字符内，但也不可为空字符串。   参数说明 table.tableizer-table { font-size: 12px; table-layout: fixed; width: 100%; border-collapse: collapse; }   参数 类型 可选 说明 默认值     clientID String no GitHub Application Client ID null   clientSecret String no GitHub Application Client Secret null   repo String no 存放评论的gitHub仓库 null   owner String no 存放评论的gitHub仓库的所有者 null   admin Array no 允许初始化评论的用户（repo的所有者和合作者） [ owner ]   id String yes 页面的唯一标识，长度必须小于50 location.href   number Number yes 页面的issueID标识，若未定义number属性则使用id进行定位 -1   labels Array yes GitHub issue的标签 ['Gitalk']   title String yes GitHub issue的标题 document.title   body String yes GitHub issue的内容 location.href + header.meta[description]   language String yes 语言，支持[en, zh-CN, zh-TW] navigator.language || navigator.userLanguage   perPage Number yes 每次加载的评论数，最多100 10   distractionFreeMode Boolean yes 类似Facebook评论框的全屏遮罩效果. false   pagerDirection String yes 评论排序方式， last为按评论创建时间倒叙，first为按创建时间正序。 'last'   createIssueManually Boolean yes 如果当前页面没有相应的 issue 且登录的用户属于 admin，则会自动创建 issue。如果设置为 true，则显示一个初始化页面，创建 issue 需要点击 init 按钮。 false   proxy String yes GitHub oauth请求到反向代理，为了支持CORS https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token   flipMoveOptions Object yes 评论的参考动画   { \u0026emsp; staggerDelayBy: 150, \u0026emsp; appearAnimation: \u0026lsquo;accordionVertical\u0026rsquo;, \u0026emsp; enterAnimation: \u0026lsquo;accordionVertical\u0026rsquo;, \u0026emsp; leaveAnimation: \u0026lsquo;accordionVertical\u0026rsquo;, }     enableHotKey Boolean yes 启用快捷键(cmd|ctrl + enter) 提交评论 true   \n初始化评论 Gitalk不需要像Gitment一样点初始化按钮初始化(除非将createIssueManually选项设置为true)，只需要admin中的任何一名管理员登录账号即可自动初始化。\nGitalk在Hugo Academic主题下的配置 在hugo建立的根目录下创建目录layouts/partials/，再在新创建的目录下创建comments.html用于覆盖Academic主题的comments.html。\n$ cd \u0026lt;your-hugo-website-root\u0026gt; $ mkdir -p layouts/partials/ $ vi layouts/partials/comments.html   注意是在hugo建立的根目录而不是修改themes/academic/主题下的文件。   在layouts/partials/comments.html中输入以下代码：\n{{ if eq .Site.Params.gitalk.on true }} \u0026lt;section id=\u0026quot;comments\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;gitalkContainer\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\u0026quot;\u0026gt; \u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var gitalk = new Gitalk({ clientID: {{ .Site.Params.gitalk.clientID }}, clientSecret: {{ .Site.Params.gitalk.clientSecret }}, repo: {{ .Site.Params.gitalk.repo }}, owner: {{ .Site.Params.gitalk.owner }}, admin: {{ .Site.Params.gitalk.admin }}, id: '{{ .Params.Date }}', // Ensure uniqueness and length less than 50 labels: {{ .Site.Params.gitalk.labels }}, distractionFreeMode: {{ .Site.Params.gitalk.distractionFreeMode }}, // Facebook-like distraction free mode pagerDirection: {{ .Site.Params.gitalk.pagerDirection }}, createIssueManually: {{ .Site.Params.gitalk.createIssueManually }}, enableHotKey: {{ .Site.Params.gitalk.enableHotKey }}, flipMoveOptions: { staggerDelayBy: {{ .Site.Params.gitalk.flipMoveOptions.staggerDelayBy }}, appearAnimation: {{ .Site.Params.gitalk.flipMoveOptions.appearAnimation }}, enterAnimation: {{ .Site.Params.gitalk.flipMoveOptions.enterAnimation }}, leaveAnimation: {{ .Site.Params.gitalk.flipMoveOptions.leaveAnimation }}, }, }); gitalk.render('gitalkContainer'); \u0026lt;/script\u0026gt; \u0026lt;/section\u0026gt; {{ end }}  在 config/_default/params.toml末尾添加以下配置。\n# Config comments of gitalk [gitalk] on = true clientID = \u0026quot;ec5806c0144b70a1b32e\u0026quot; clientSecret = \u0026quot;aadae41a3747ffa5b36fd0e13c7e84026db07e0c\u0026quot; repo = \u0026quot;YuxinZhaozyx.github.io\u0026quot; owner = \u0026quot;YuxinZhaozyx\u0026quot; admin = [\u0026quot;YuxinZhaozyx\u0026quot;] labels = [\u0026quot;Comments\u0026quot;] # default to [\u0026quot;Gitalk\u0026quot;] distractionFreeMode = false pagerDirection = 'last' # set to 'last' or 'first' createIssueManually = false enableHotKey = true # cmd | ctrl + enter to commit comment [gitalk.flipMoveOptions] staggerDelayBy = 150 appearAnimation = 'elevator' enterAnimation = 'elevator' leaveAnimation = 'elevator'  至此，评论功能配置完成。\n","date":1562661632,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1562661632,"objectID":"1249ac900a72f9737e859b54e2d4e4c6","permalink":"https://YuxinZhaozyx.github.io/post/gitalk-in-hugo/","publishdate":"2019-07-09T16:40:32+08:00","relpermalink":"/post/gitalk-in-hugo/","section":"post","summary":"从使用Gitment到转用Gitalk作为评论模块的历程","tags":["hugo","academic","gitalk","comments","github"],"title":"Hugo博客集成Gitalk评论模块","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["git"],"content":" 假定我有两个分支master和dev。当前处在dev分支。\n$ git merge master Already up to date.  Cause of Errors 错误原因 Already up to date意味着已经是最新的了，即dev是在master的基础上修改的，而master自分出dev分支后就没修改过，因此dev分支是最新的，不需要于master合并，因为合并完的仓库和当前的dev分支是一模一样的。\n其git分支图如下：\nE -- F -- G(dev) / A -- B -- C -- D(master)  其等同于:\nA -- B -- C -- D(master) -- E -- F -- G(dev)  我们想要做的合并实际上是将master指向dev而已。\nSolution 解决方法 多提交一个空的commit，使两条分支叉开，再合并。\nE -- F -- G(dev) / A -- B -- C -- D -- H(master)  E -- F -- G(dev) / \\ A -- B -- C -- D -- H ------ I(master)  上图中H是一个不做任何修改的提交，其作用是将master和dev分到两个叉开的分支上，使得master不再是dev的父节点。\n具体命令:\n# 移动到master分支下 $ git checkout master # 在master提交一个空内容 $ git commit --allow-empty -m \u0026quot;ready for merging\u0026quot; # 合并master和dev分支 $ git merge dev # 移除dev指针(可选) $ git branch --delete dev  ","date":1562654733,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1562654733,"objectID":"7419595eed4de2ff1980b793a9c64c78","permalink":"https://YuxinZhaozyx.github.io/post/git-merge-already-up-to-date/","publishdate":"2019-07-09T14:45:33+08:00","relpermalink":"/post/git-merge-already-up-to-date/","section":"post","summary":"`master`分支没有变化导致的分支无法合并错误","tags":["git"],"title":"git merge命令提示Already up to date","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["hugo"],"content":" 前言 我使用的Hugo主题Academic自带Disqus评论模块支持，但由于国内无法访问Disqus，因此我开始寻找其他评论模块，最终选择了Gitment评论模块。\n我为什么选择Gitment？ 在选择之前我们先看一下有哪些选项可以选择。\n Disqus: 国外使用较多的评论组件，但国内需要代理才能访问。\n 多说: 国内最多用户使用的评论系统，但已于2017年6月停止提供服务。\n 网易云跟帖: 网易提供的评论系统，但也于2017月8月停止提供服务。\n 畅言: 搜狐提供的评论组件，功能丰富，体验优异；但必须进行域名备案。只要域名备过案就可以通过审核，简单问题复杂化。\n Gitment: 国人I\u0026rsquo;m Sun编写的开源评论模块，创新性地将评论放置在github的issue中，作者目前已不再维护。\n CommentHub: 受Gitment启发也是将评论存储在github issue中的评论系统，解决Gitment会在前端暴露Client ID和Client Secret可能造成的安全问题，改进成在后端服务处理业务和存储证书，通过iframe实现评论功能。\n  已停止服务的多说、网易云跟帖和国内无法访问的Disqus无法使用，故排除在选择范围之外。畅言由于需要备案，步骤繁琐不想用。剩下的Gitment和ComementHub实际上很像，CommentHub看上去会更安全一些，因为它不会像Gitment一样暴露Client ID和Client Secret，但其实即便别人获取了我们的Client ID和Client Secret，没有我的github账号依然无法使用，而且只能在我指定的网址才能用，故Gitment还是比较安全的。\n最终我在两者中选择了Gitment (因为CommentHub有点难看)。\nGitment评论模块介绍  Gitment is a comment system based on GitHub Issues, which can be used in the frontend without any server-side implementation.\nGitment 是一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。\n  项目地址\n 官方示例\n  基本使用 1. 注册OAuth Application 需要先在github上注册一个OAuth Application，点击此处注册。\nCallback URL 填写评论页面对应的域名，如https://YuxinZhaozyx.github.io。\n 其他内容可以随便写，但Callback URL一定要填写正确。   注册成功后会得到一个Client ID和Client Secret，这将被用于之后的用户登录认证。\n2. 引入Gitment 将以下代码添加到你的页面：\n\u0026lt;div id=\u0026quot;container\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://imsun.github.io/gitment/style/default.css\u0026quot;\u0026gt; \u0026lt;script src=\u0026quot;https://imsun.github.io/gitment/dist/gitment.browser.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var gitment = new Gitment({ id: '页面 ID', // 可选。默认为 location.href owner: '你的 GitHub ID', repo: '存储评论的 repo', oauth: { client_id: '你的 client ID', client_secret: '你的 client secret', }, }) gitment.render('container') \u0026lt;/script\u0026gt;   id的长度要限制在50个字符内，但也不可为空字符串。详情见此处。    上述代码为gitment作者的示例代码，但作者已停止维护，网址已不可用，可用以下代码代替。\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://www.wenjunjiang.win/css/gitment.css\u0026quot;\u0026gt; \u0026lt;script src=\u0026quot;https://www.wenjunjiang.win/js/gitment.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;  或者\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css\u0026quot;\u0026gt; \u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;  目前来看后者更稳定一点。\n   以上方式会使用最新版本的Gitment，若希望引用确定版本的Gitment，需要使用npm进行安装。\n$ npm install --save gitment  使用操作详见Gitment Option。\n  3. 初始化评论 页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。\n之后其他用户即可在该页面发表评论。\n 要先登录才能初始化，未登录初始化前可能会显示Error: Comments Not initialized错误，属正常现象。   问题汇总 1. Error: Not Found  owner或者repo配置错误，注意名字和参考名字的大小写。\n 注意不可设置 id : \u0026quot;\u0026quot;。\n  2. Error: Comments Not initialized  还没有登录，登录之后初始化就可以了。 注册OAuth Application时Authorization Callback URL指定地址错误。  3. Error: Validation Failed  id太长，导致初始化失败。解决方案见问题4。  id`的长度要限制在50个字符内，但也不可为空字符串 github issue的标签label有长度限制，label的最大长度为50个字符 id的作用是唯一标识每一篇文章。 在gitment创建的issue里，每个issue有两个label，其中一个是gitment，另一个是id指定的值。因此id受到label的限制。   4. 在一篇文章下看到另一篇文章的issue  两篇文章的id重复  解决方案 将文章的id设置为文章的创建时间，即可保证id长度不超过50个字符且文章评论不重复。\nid: {{ .Params.Date }}   不要复制前面的某一篇论文而忘记修改时间，否则评论还是会交错的。  \nGitment的汉化版本 只需到模板里将原来定义CSS和JS的那两行改成：\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://billts.site/extra_css/gitment.css\u0026quot;\u0026gt; \u0026lt;script src=\u0026quot;https://billts.site/js/gitment.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;  Gitment在Hugo Academic主题下的配置 在hugo建立的根目录下创建目录layouts/partials/，再在新创建的目录下创建comments.html用于覆盖Academic主题的comments.html。\n$ cd \u0026lt;your-hugo-website-root\u0026gt; $ mkdir -p layouts/partials/ $ vi layouts/partials/comments.html   注意是在hugo建立的根目录而不是修改themes/academic/主题下的文件。   在layouts/partials/comments.html中输入以下代码：\n{{ if .Site.Params.gitment.language }} \u0026lt;section id=\u0026quot;comments\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;gitmentContainer\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; {{ if eq .Site.Params.gitment.language \u0026quot;zh\u0026quot; }} \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://billts.site/extra_css/gitment.css\u0026quot;\u0026gt; \u0026lt;script src=\u0026quot;https://billts.site/js/gitment.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; {{ else }} \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css\u0026quot;\u0026gt; \u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} \u0026lt;script\u0026gt; var gitment = new Gitment({ id: '{{ .Params.Date }}', owner: {{ .Site.Params.gitment.owner }}, repo: {{ .Site.Params.gitment.repo }}, oauth: { client_id: {{ .Site.Params.gitment.clientID }}, client_secret: {{ .Site.Params.gitment.clientSecret }}, }, }); gitment.render('gitmentContainer'); \u0026lt;/script\u0026gt; \u0026lt;/section\u0026gt; {{ end }}  在 config/_default/params.toml末尾添加以下配置。\n# Config comments of gitment [gitment] language = \u0026quot;en\u0026quot; # set \u0026quot;\u0026quot; to disable comment, \u0026quot;zh\u0026quot; to Chinese, \u0026quot;en\u0026quot; to English owner = \u0026quot;\u0026lt;your-github-name\u0026gt;\u0026quot; repo = \u0026quot;\u0026lt;the-repo-to-store-comments\u0026gt;\u0026quot; clientID = \u0026quot;\u0026lt;your-client-ID\u0026gt;\u0026quot; clientSecret = \u0026quot;\u0026lt;your-client-secret\u0026gt;\u0026quot;  至此，评论功能配置完成。\n参考引用 [1] Gitment：使用 GitHub Issues 搭建评论系统 \n[2] Gitment评论功能接入踩坑教程\n[3] Error: Comments Not Initialized # 95\n[4] Validation Failed ID长度问题建议 #116\n[5] [object ProgressEvent] #170\n[6] 网站无法访问了？ #102\n","date":1562318459,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1562318459,"objectID":"5912ebcf469a2e35d974f7d7811b81e7","permalink":"https://YuxinZhaozyx.github.io/post/gitment-in-hugo/","publishdate":"2019-07-05T17:20:59+08:00","relpermalink":"/post/gitment-in-hugo/","section":"post","summary":"由于国内无法访问Disqus，hugo-academic主题自带的disqus评论功能无法使用，故而寻求其他评论方法，最后找到了gitment，但也踩了很多的坑。","tags":["hugo","academic","gitment","comments","github"],"title":"Hugo博客集成Gitment评论模块","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["project-note"],"content":" 第一章 用户服务 本章节我们实现用户服务，用户服务分为两层，web层（user-web）与服务层（user-srv），前者提供http接口，后者向web提供RPC服务。\n user-web 以下简称web user-srv 以下简称service  web服务主要向用户提供如下接口\n 登录与token颁发 鉴权  我们不提供注册接口，一来增加不必要的代码量，我们的核心还是介绍如何使用Micro组件。\nserver服务主要向所有内部服务提供用户查询接口：\n 根据userName用户名查询用户  在开发应用之前，我们要先定义好命名空间。\n   服务 命名空间 说明     接入层API mu.micro.book.web 负责代理所有mu.micro.book.web下游的web应用，比如mu.micro.book.web.user等   用户web mu.micro.book.web.user 接收API下放的路由为/user请求   用户服务 mu.micro.book.srv.user 对架构内应用提供user查询服务    user-srv user-srv的各组件如下表所示\n   启动顺序 组件 作用     1 basic 初始化配置与解析配置文件，初始化数据库等基础组件   2 model 模型层，提供业务数据   3 handler 接入层，提供对外接口，并向model层调用请求数据    Micro有提供代码生成器指令new，它可以新建服务模板代码，把基本所需的目录结构建好，省去大家挖坑的时间。\n新建模板 micro new --namespace=mu.micro.book --type=srv --alias=user github.com/YuxinZhaozyx/GoMicroBookshop/user-srv  模板生成在user-srv目录，其结构如下\n. ├── main.go ├── plugin.go ├── handler │ └── user.go ├── subscriber │ └── user.go ├── proto/user │ └── user.proto ├── Dockerfile ├── Makefile └── README.md  修改后\n. ├── main.go ├── plugin.go ├── basic │ └── config * 配置类 │ │ └── config.go * 初始化配置类 │ │ └── consul.go * consul配置结构体 │ │ └── mysql.go * mysql配置结构体 │ │ └── profiles.go * 配置文件树辅助类 │ └── db * 数据库相关 │ │ └── db.go * 初始化数据库 │ │ └── mysql.go * mysql数据库相关 │ └── basic.go * 初始化基础组件 ├── conf * 配置文件目录 ├── handler │ └── user.go * 将名称改为user ├── model * 增加模型层，用于与数据库交换数据 │ └── user * 用户模型类 │ │ └── user.go * 初始化用户模型类 │ │ └── user_get.go * 封装获取用户数据类业务 │ └── model.go * 初始化模型层 ├── proto/user │ └── user.proto * 将名称改为user ├── Dockerfile ├── Makefile └── README.md  目录解释：basic, model, conf\nbasic, model 目录与micro无关，只是为了实现MVC架构。\n basic 负责初始化基础组件，比如数据库、配置等 model 负责封装业务逻辑 conf 配置文件目录，现在我们还没用配置中心，暂先用文件的方式  定义User原型 在user.proto中定义User原型，暂且定义以下字段，足够登录，显示用户基本信息、异常信息即可\nsyntax = \u0026quot;proto3\u0026quot;; package mu.micro.book.srv.user; service User { rpc QueryUserByName(Request) returns (Response) {} } message user { int64 id = 1; string name = 2; string pwd = 3; uint64 createTime = 4; uint64 updateTime = 5; } message Error { int32 code = 1; string detail = 2; } message Request { string userID = 1; string userName = 2; string userPwd = 3; } message Response { bool success = 1; Error error = 2; user user = 3; }  上面定义了User服务的基本原型结构，包含用户User，请求Request与响应结构Response，还定义了查询用户的方法QueryUserByName。\n下面我们生成类型与服务方法：\nprotoc --proto_path=. --go_out=. --micro_out=. proto/user/user.proto  执行后会生成 proto/user/user.micro.go 和 proto/user/user.pb.go 两个文件。\n数据库与配置 创建User表 选用MySQL作为数据库，以下是建表语句\nCREATE DATABASE `micro_book_mall` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_bin */; USE `micro_book_mall`; CREATE TABLE `user` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键', `user_id` int(10) unsigned DEFAULT NULL COMMENT '用户id', `user_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户名', `pwd` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '密码', `created_time` timestamp(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3), `updated_time` timestamp(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3), PRIMARY KEY (`id`), UNIQUE KEY `user_user_name_uindex` (`user_name`), UNIQUE KEY `user_user_id_uindex` (`user_id`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_bin COMMENT ='用户表'; INSERT INTO user (user_id, user_name, pwd) VALUE (10001, 'micro', '1234');  基本组件配置 基础组件(basic)目前主要的功能是初始化配置与数据库。它的入口代码(basic/basic.go)是一个Init初始化方法，负责初始化其下所有组件。\npackage basic import ( \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/basic/config\u0026quot; \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/basic/db\u0026quot; ) func Init() { config.Init() db.Init() }  配置config 加载配置我们会使用到go-config里面的本地文件配置。相关示例可以参考go-config示例。\n配置文件在 conf/ 文件夹下。\napplication.yml # 根配置文件 application-db.yml # 数据库配置文件 application-consul.yml # consul服务发现配置文件  根配置文件application.yml如下\napp: profiles: include: consul, db  起名为application.yml是参考了Spring-boot风格。我们把consul和db配置分到独立的文件中。\n通过解析app.profiles.include来加载指定的配置文件。当然也可以全部写在application.yml中，只是我觉得挤在一起的配置不优雅。\n初始化配置的过程大致如下：\n   顺序 过程 说明     1 加载application.yml 读取conf目录下application.yml文件   2 解析profiles属性 如果有该属性则找到include值，该值就是指定需要引入的conf下的配置文件   3 解析include 解析出include配置【值】，并组合成文件名，文件名规则为[application-值.yml]   4 读取include声明文件 读取配置文件值   5 解析配置 将配置文件中的值解析到配置对象中    以下是它的核心代码(basic/config/config.go)\n// Init 初始化配置 func Init() { m.Lock() defer m.Unlock() if inited { log.Logf(\u0026quot;[Init] 配置已经初始化过\u0026quot;) return } // 加载yml配置 // 先加载基础配置 appPath, _ := filepath.Abs(filepath.Dir(filepath.Join(\u0026quot;.\u0026quot;+sp, sp))) pt := filepath.Join(appPath, \u0026quot;conf\u0026quot;) os.Chdir(appPath) // 找到application.yml文件 if err = config.Load(file.NewSource(file.WithPath(pt + sp + \u0026quot;application.yml\u0026quot;))); err != nil { panic(err) } // 找到需要引入的新配置文件 if err = config.Get(defaultRootPath, \u0026quot;profiles\u0026quot;).Scan(\u0026amp;profiles); err != nil { panic(err) } log.Logf(\u0026quot;[Init] 加载配置文件：path: %s, %+v\\n\u0026quot;, pt+sp+\u0026quot;application.yml\u0026quot;, profiles) // 开始导入新文件 if len(profiles.GetInclude()) \u0026gt; 0 { include := strings.Split(profiles.GetInclude(), \u0026quot;,\u0026quot;) sources := make([]source.Source, len(include)) for i := 0; i \u0026lt; len(include); i++ { filePath := pt + string(filepath.Separator) + defaultConfigFilePrefix + strings.TrimSpace(include[i]) + \u0026quot;.yml\u0026quot; log.Logf(\u0026quot;[Init] 加载配置文件：path: %s\\n\u0026quot;, filePath) sources[i] = file.NewSource(file.WithPath(filePath)) } // 加载include的文件 if err = config.Load(sources...); err != nil { panic(err) } } // 赋值 config.Get(defaultRootPath, \u0026quot;consul\u0026quot;).Scan(\u0026amp;consulConfig) config.Get(defaultRootPath, \u0026quot;mysql\u0026quot;).Scan(\u0026amp;mysqlConfig) // 标记已经初始化 inited = true }  我们目前定义了三个配置结构，它们在basic的config目录下\n profiles consul mysql：\n// defaultProfiles 属性配置文件 type defaultProfiles struct { Include string `json:\u0026quot;include\u0026quot;` } // defaultConsulConfig 默认consul 配置 type defaultConsulConfig struct { Enabled bool `json:\u0026quot;enabled\u0026quot;` Host string `json:\u0026quot;host\u0026quot;` Port int `json:\u0026quot;port\u0026quot;` } // defaultMysqlConfig mysql 配置 type defaultMysqlConfig struct { URL string `json:\u0026quot;url\u0026quot;` Enable bool `json:\u0026quot;enabled\u0026quot;` MaxIdleConnection int `json:\u0026quot;maxIdleConnection\u0026quot;` MaxOpenConnection int `json:\u0026quot;maxOpenConnection\u0026quot;` }   数据库初始化 // user-srv/basic/db/db.go package db import ( \u0026quot;database/sql\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/basic/config\u0026quot; \u0026quot;github.com/micro/go-micro/util/log\u0026quot; ) var ( inited bool mysqlDB *sql.DB m sync.RWMutex ) // Init 初始化数据库 func Init() { m.Lock() defer m.Unlock() var err error if inited{ err = fmt.Errorf(\u0026quot;[Init] db 已经初始化过了\u0026quot;) log.Logf(err.Error()) return } // 如果配置声明使用mysql if config.GetMysqlConfig().GetEnabled(){ initMysql() } inited = true } // GetDB 获取数据库 func GetDB() *sql.DB { return mysqlDB } // user-srv/basic/db/mysql.go package db import ( \u0026quot;database/sql\u0026quot; \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/basic/config\u0026quot; \u0026quot;github.com/micro/go-micro/util/log\u0026quot; _ \u0026quot;github.com/go-sql-driver/mysql\u0026quot; ) func initMysql() { var err error // 创建连接 mysqlDB, err = sql.Open(\u0026quot;mysql\u0026quot;, config.GetMysqlConfig().GetURL()) if err != nil { log.Fatal(err) panic(err) } // 最大连接数 mysqlDB.SetMaxOpenConns(config.GetMysqlConfig().GetMaxOpenConnection()) // 最大闲置数 mysqlDB.SetMaxIdleConns(config.GetMysqlConfig().GetMaxIdleConnection()) // 激活链接 if err = mysqlDB.Ping(); err != nil { log.Fatal(err) } }  用户模型服务 /user-srv/model/user/user.go\npackage user import ( \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; proto \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/proto/user\u0026quot; ) var ( s *service m sync.RWMutex ) // service 服务 type service struct { } // Service 用户服务类 type Service interface { // QueryUserByName 根据用户名获取用户 QueryUserByName(userName string) (ret *proto.User, err error) } // GetService 获取服务类 func GetService() (Service, error) { if s == nil { return nil, fmt.Errorf(\u0026quot;[GetService] GetService 未初始化\u0026quot;) } return s, nil } // Init 初始化用户服务层 func Init() { m.Lock() defer m.Unlock() if s != nil { return } s = \u0026amp;service{} }  /user-srv/model/user/user_get.go\npackage user import ( \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/basic/db\u0026quot; proto \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/proto/user\u0026quot; \u0026quot;github.com/micro/go-micro/util/log\u0026quot; ) func (s *service) QueryUserByName(userName string) (ret *proto.User, err error) { queryString := `SELECT user_id, user_name, pwd FROM user WHERE user_name = ?` // 获取数据库 o := db.GetDB() ret = \u0026amp;proto.User{} // 查询 err = o.QueryRow(queryString, userName).Scan(\u0026amp;ret.Id, \u0026amp;ret.Name, \u0026amp;ret.Pwd) if err != nil { log.Logf(\u0026quot;[QueryUserByName] 查询数据失败， err: %s\u0026quot;, err) return } return }  /user-srv/model/model.go\npackage model import \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/model/user\u0026quot; // Init 初始化模型层 func Init() { user.Init() }  Handler /user-srv/handler/user.go\npackage handler import ( \u0026quot;context\u0026quot; \u0026quot;github.com/micro/go-micro/util/log\u0026quot; model \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/model/user\u0026quot; proto \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/proto/user\u0026quot; ) type Service struct{} var ( userService model.Service ) // Init 初始化handler func Init() { var err error userService, err = model.GetService() if err != nil { log.Fatal(\u0026quot;[Init] 初始化Handler错误\u0026quot;) return } } // QueryUserByName 通过参数中的名字返回用户 func (e *Service) QueryUserByName(ctx context.Context, req *proto.Request, rsp *proto.Response) error { user, err := userService.QueryUserByName(req.UserName) if err != nil { rsp.Success = false rsp.Error = \u0026amp;proto.Error{ Code: 500, Detail: err.Error(), } return err } rsp.User = user rsp.Success = true return nil }  handler直接调用模型层方法获取数据并回传给rsp结构。\nmain main.go\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; \u0026quot;github.com/micro/cli\u0026quot; \u0026quot;github.com/micro/go-micro\u0026quot; \u0026quot;github.com/micro/go-micro/registry\u0026quot; \u0026quot;github.com/micro/go-micro/registry/consul\u0026quot; \u0026quot;github.com/micro/go-micro/util/log\u0026quot; \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/basic\u0026quot; \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/basic/config\u0026quot; \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/handler\u0026quot; \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/model\u0026quot; user \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/proto/user\u0026quot; ) func main() { // 初始化配置、数据库等信息 basic.Init() // 使用consul注册 micReg := consul.NewRegistry(registryOptions) // New Service 新建服务 service := micro.NewService( micro.Name(\u0026quot;mu.micro.book.srv.user\u0026quot;), micro.Registry(micReg), micro.Version(\u0026quot;latest\u0026quot;), ) // Initialise service 初始化服务 service.Init( micro.Action(func(c *cli.Context) { // 初始化模型层 model.Init() // 初始化handler handler.Init() }), ) // Register Handler 注册服务 user.RegisterUserHandler(service.Server(), new(handler.Service)) // Run service 启动服务 if err := service.Run(); err != nil { log.Fatal(err) } } func registryOptions(ops *registry.Options) { consulCfg := config.GetConsulConfig() ops.Timeout = time.Second * 5 ops.Addrs = []string{fmt.Sprintf(\u0026quot;%s:%d\u0026quot;, consulCfg.GetHost(), consulCfg.GetPort())} }  代码中我们默认使用consul作为注册中心，被在Action中初始化基础组件与模型层。\n 因为handler依赖model，所以初始化handler要在初始化模型层之后执行。   启动 启动consul\nconsul agent -dev  启动user-srv\ngo run main.go plugin.go  输出:\n2019/06/29 22:26:48 [Init] 加载配置文件：path: e:\\go\\src\\github.com\\YuxinZhaozyx\\GoMicroBookshop\\user-srv\\conf\\application.yml, {Include:consul, db} 2019/06/29 22:26:48 [Init] 加载配置文件：path: e:\\go\\src\\github.com\\YuxinZhaozyx\\GoMicroBookshop\\user-srv\\conf\\application-consul.yml 2019/06/29 22:26:48 [Init] 加载配置文件：path: e:\\go\\src\\github.com\\YuxinZhaozyx\\GoMicroBookshop\\user-srv\\conf\\application-db.yml 2019/06/29 22:26:48 Transport [http] Listening on [::]:56789 2019/06/29 22:26:48 Broker [http] Connected to [::]:56790 2019/06/29 22:26:48 Registry [consul] Registering node: mu.micro.book.srv.user-f51e60e1-cebf-4599-874c-8230d3113300  测试 micro --registry=consul call mu.micro.book.srv.user User.QueryUserByName \u0026quot;{\\\u0026quot;userName\\\u0026quot;: \\\u0026quot;micro\\\u0026quot;}\u0026quot;  输出:\n{ \u0026quot;success\u0026quot;: true, \u0026quot;user\u0026quot;: { \u0026quot;id\u0026quot;: 10001, \u0026quot;name\u0026quot;: \u0026quot;micro\u0026quot;, \u0026quot;pwd\u0026quot;: \u0026quot;1234\u0026quot; } }  user-srv服务搭建完成。\nuser-web web服务负责暴露接口给用户，用户请求登录，web通过用户名userName向service获取用户信息，再比对密码，正确则登录成功，反之返回错误。\n请求链如下图\n\n新建模板 micro new --namespace=mu.micro.book --type=web --alias=user github.com/YuxinZhaozyx/GoMicroBookshop/user-web  目录树\n生成的目录树\n. ├── main.go ├── plugin.go ├── handler │ └── handler.go ├── html │ └── index.html ├── Dockerfile ├── Makefile └── README.md  修改后：\n. ├── main.go ├── plugin.go ├── basic │ └── config │ │ └── config.go │ │ └── consul.go │ │ └── profiles.go │ └── basic.go ├── conf │ └── application.yml │ └── application-consul.yml ├── handler │ └── handler.go ├── Dockerfile ├── Makefile └── README.md  go-web是一个很简单的web开发库，它不像其它go语言的web框架有那么多工具集，它核心在两个方面\n 让程序支持http请求 天生属于Micro生态  它不需要额外的代码就可以注册到Micro生态中，和其它类型的服务一样。\nweb核心有三个地方\n config.go 负责加载配置 handler.go 负责处理请求 main.go 程序运行入口  config 设置类似user-srv的设置，但去除mysql的配置。\nuser-web/basic/config/config.go\npackage config import ( \u0026quot;os\u0026quot; \u0026quot;path/filepath\u0026quot; \u0026quot;strings\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;github.com/micro/go-micro/config\u0026quot; \u0026quot;github.com/micro/go-micro/config/source\u0026quot; \u0026quot;github.com/micro/go-micro/config/source/file\u0026quot; \u0026quot;github.com/micro/go-micro/util/log\u0026quot; ) var ( err error ) var ( defaultRootPath = \u0026quot;app\u0026quot; defaultConfigFilePrefix = \u0026quot;application-\u0026quot; consulConfig defaultConsulConfig profiles defaultProfiles m sync.RWMutex inited bool ) // Init 初始化配置 func Init() { m.Lock() defer m.Unlock() if inited { log.Logf(\u0026quot;[Init] 配置已经初始化过\u0026quot;) return } // 加载yml配置 // 先加载基础配置 appPath, _ := filepath.Abs(filepath.Dir(filepath.Join(\u0026quot;./\u0026quot;, string(filepath.Separator)))) pt := filepath.Join(appPath, \u0026quot;conf\u0026quot;) os.Chdir(appPath) // 找到application.yml文件 if err = config.Load(file.NewSource(file.WithPath(pt + \u0026quot;/application.yml\u0026quot;))); err != nil { panic(err) } // 找到需要引入的新配置文件 if err = config.Get(defaultRootPath, \u0026quot;profiles\u0026quot;).Scan(\u0026amp;profiles); err != nil { panic(err) } log.Logf(\u0026quot;[Init] 加载配置文件：path: %s, %+v\\n\u0026quot;, pt+\u0026quot;/application.yml\u0026quot;, profiles) // 开始导入新文件 if len(profiles.GetInclude()) \u0026gt; 0 { include := strings.Split(profiles.GetInclude(), \u0026quot;,\u0026quot;) sources := make([]source.Source, len(include)) for i := 0; i \u0026lt; len(include); i++ { filePath := pt + string(filepath.Separator) + defaultConfigFilePrefix + strings.TrimSpace(include[i]) + \u0026quot;.yml\u0026quot; log.Logf(\u0026quot;[Init] 加载配置文件：path: %s\\n\u0026quot;, filePath) sources[i] = file.NewSource(file.WithPath(filePath)) } // 加载include的文件 if err = config.Load(sources...); err != nil { panic(err) } } // 赋值 config.Get(defaultRootPath, \u0026quot;consul\u0026quot;).Scan(\u0026amp;consulConfig) // 标记已经初始化 inited = true } // GetConsulConfig 获取Consul配置 func GetConsulConfig() (ret ConsulConfig) { return consulConfig }  user-web/basic/config/consul.go\npackage config // ConsulConfig consul 配置 type ConsulConfig interface { GetEnabled() bool GetPort() int GetHost() string } // defaultConsulConfig 默认consul 配置 type defaultConsulConfig struct { Enabled bool `json:\u0026quot;enabled\u0026quot;` Host string `json:\u0026quot;host\u0026quot;` Port int `json:\u0026quot;port\u0026quot;` } // GetPort consul 端口 func (c defaultConsulConfig) GetPort() int { return c.Port } // GetEnabled consul 激活 func (c defaultConsulConfig) GetEnabled() bool { return c.Enabled } // GetHost consul 主机地址 func (c defaultConsulConfig) GetHost() string { return c.Host }  user-web/basic/config/profiles.go\npackage config // Profiles 属性配置文件 type Profiles interface { GetInclude() string } // defaultProfiles 属性配置文件 type defaultProfiles struct { Include string `json:\u0026quot;include\u0026quot;` } // Include 包含的配置文件 // 名称前缀为\u0026quot;application-\u0026quot;，格式为yml，如：\u0026quot;application-xxx.yml\u0026quot; // 多个文件名以逗号隔开，并省略掉前缀\u0026quot;application-\u0026quot;，如：dn, jpush, mysql func (p defaultProfiles) GetInclude() string { return p.Include }  handler user-web/handler/handler.go\npackage handler import ( \u0026quot;context\u0026quot; \u0026quot;encoding/json\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;time\u0026quot; user \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-srv/proto/user\u0026quot; \u0026quot;github.com/micro/go-micro/client\u0026quot; \u0026quot;github.com/micro/go-micro/util/log\u0026quot; ) var ( serviceClient user.UserService ) // Error 错误结构体 type Error struct { Code string `json:\u0026quot;code\u0026quot;` Detail string `json:\u0026quot;detail\u0026quot;` } func Init() { serviceClient = user.NewUserService(\u0026quot;mu.micro.book.srv.user\u0026quot;, client.DefaultClient) } // Login 登录入口 func Login(w http.ResponseWriter, r *http.Request) { // 只接受POST请求 if r.Method != \u0026quot;POST\u0026quot; { log.Logf(\u0026quot;非法请求\u0026quot;) http.Error(w, \u0026quot;非法请求\u0026quot;, 400) return } r.ParseForm() // 调用后台服务 rsp, err := serviceClient.QueryUserByName(context.TODO(), \u0026amp;user.Request{ UserName: r.Form.Get(\u0026quot;userName\u0026quot;), }) if err != nil { http.Error(w, err.Error(), 500) return } // 返回结果 response := map[string]interface{}{ \u0026quot;ref\u0026quot;: time.Now().UnixNano(), } if rsp.User.Pwd == r.Form.Get(\u0026quot;pwd\u0026quot;) { response[\u0026quot;success\u0026quot;] = rsp.Success // 干掉密码返回 rsp.User.Pwd = \u0026quot;\u0026quot; response[\u0026quot;data\u0026quot;] = rsp.User } else { response[\u0026quot;success\u0026quot;] = false response[\u0026quot;error\u0026quot;] = \u0026amp;Error{ Detail: \u0026quot;密码错误\u0026quot;, } } w.Header().Add(\u0026quot;Content-Type\u0026quot;, \u0026quot;application/json; charset=utf-8\u0026quot;) // encode and write the response as json 返回json结构 if err := json.NewEncoder(w).Encode(response); err != nil { http.Error(w, err.Error(), 500) return } }  main user-web/main.go\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; \u0026quot;github.com/micro/go-micro/util/log\u0026quot; \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-web/basic\u0026quot; \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-web/basic/config\u0026quot; \u0026quot;github.com/YuxinZhaozyx/GoMicroBookshop/user-web/handler\u0026quot; \u0026quot;github.com/micro/cli\u0026quot; \u0026quot;github.com/micro/go-micro/registry\u0026quot; \u0026quot;github.com/micro/go-micro/registry/consul\u0026quot; \u0026quot;github.com/micro/go-micro/web\u0026quot; ) func main() { // 初始化配置 basic.Init() // 使用consul注册 micReg := consul.NewRegistry(registryOptions) // create new web service 创建新服务 service := web.NewService( web.Name(\u0026quot;mu.micro.book.web.user\u0026quot;), web.Version(\u0026quot;latest\u0026quot;), web.Registry(micReg), web.Address(\u0026quot;:8088\u0026quot;), ) // initialise service 初始化服务 if err := service.Init( web.Action(func(c *cli.Context) { // 初始化handler handler.Init() }), ); err != nil { log.Fatal(err) } // register call handler 注册登录接口 service.HandleFunc(\u0026quot;/user/login\u0026quot;, handler.Login) // run service 运行服务 if err := service.Run(); err != nil { log.Fatal(err) } } func registryOptions(ops *registry.Options) { consulCfg := config.GetConsulConfig() ops.Timeout = time.Second * 5 ops.Addrs = []string{fmt.Sprintf(\u0026quot;%s:%d\u0026quot;, consulCfg.GetHost(), consulCfg.GetPort())} }  handler里定义了错误结构体Error、Init、Login方法。\n Init 用来初始化handler需要用到的服务客户端 Login 处理登录请求  Login在解析完参数后，通过RPC调用service的QueryUserByName方法。查出的结果后再进行密码匹配。\n匹配成功后便返回用户信息。\n启动 启动consul\nconsul agent -dev  运行api\nmicro --registry=consul --api_namespace=mu.micro.book.web api --handler=web  运行user-srv\ncd user-srv go run main.go plugin.go  运行user-web\ncd user-web go run main.go  测试 curl --request POST --url http://127.0.0.1:8088/user/login --header \u0026quot;Content-Type:application/x-www-form-urlencoded\u0026quot; --data \u0026quot;userName=micro\u0026amp;pwd=1234\u0026quot;  错误输出：\n{\u0026quot;id\u0026quot;:\u0026quot;go.micro.client\u0026quot;,\u0026quot;code\u0026quot;:500,\u0026quot;detail\u0026quot;:\u0026quot;connection error: dial tcp: address fdf5:da13:de04::e58:59504: too many colons in address\u0026quot;,\u0026quot;status\u0026quot;:\u0026quot;Internal Server Error\u0026quot;}  go-micro暂不支持ipv6，待解决。\n正确输出：\n{\u0026quot;data\u0026quot;:{\u0026quot;id\u0026quot;:10001,\u0026quot;name\u0026quot;:\u0026quot;micro\u0026quot;},\u0026quot;ref\u0026quot;:1561869942897349500,\u0026quot;success\u0026quot;:true}  隔日重启后各服务分配到的是ipv4而不是ipv6地址，程序正常执行，未找到原因，待解决。\n","date":1562253783,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1562253783,"objectID":"4709d58cfea87aa750d92b63a913a2d1","permalink":"https://YuxinZhaozyx.github.io/post/gomicrobookshop-project/dev-note-1/","publishdate":"2019-07-04T23:23:03+08:00","relpermalink":"/post/gomicrobookshop-project/dev-note-1/","section":"post","summary":"实现用户服务的 web 和 service 微服务","tags":["golang","micro","go-micro","micro service"],"title":"GoMicroBookshop项目开发笔记-1","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["project-note"],"content":" 项目简介 业务模块  用户，users 库存，inventory 权限，auth 订单，orders 支付，payment  服务抽象结构 用户、订单、支付服务都会有对外暴露接口，故而它们各自有web层。web层app之间不会互相调用，它们只会与非web层的应用交互。\n准备工作  Golang环境 安装 gRPC 安装 Consul Micro  ## 安装go-micro go get github.com/micro/go-micro ## 安装micro go get github.com/micro/micro   mysql  还有其它一些会用到的库或组件，但不是基础依赖，需要时再安装。\n涉及技术与库 Golang，gRPC，Mysql，Redis，Docker，K8s，Go-micro/Micro\n搭建平台 win10\n","date":1562252574,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1562252574,"objectID":"3b7ed416a512f2a7475612cc7c4c4079","permalink":"https://YuxinZhaozyx.github.io/post/gomicrobookshop-project/dev-note-0/","publishdate":"2019-07-04T23:02:54+08:00","relpermalink":"/post/gomicrobookshop-project/dev-note-0/","section":"post","summary":"GoMicroBookshop项目是我学习micro编写的练手项目-准备开发环境","tags":["golang","micro","go-micro","micro service"],"title":"GoMicroBookshop项目开发笔记-0","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["math"],"content":" Summary of LaTeX Math Symbols\n$\\LaTeX$数学符号汇总\nFunction, symbol and special characters 函数、符号及特殊字符 Tone 声调    Syntax 语法 Effect 效果     \\bar{x} $$\\bar{x}$$   \\acute{\\eta} $$\\acute{\\eta}$$   \\check{\\alpha} $$\\check{\\alpha}$$   \\grave{\\eta} $$\\grave{\\eta}$$   \\breve{a} $$\\breve{a}$$   \\ddot{y} $$\\ddot{y}$$   \\dot{x} $$\\dot{x}$$   \\hat{\\alpha} $$\\hat{\\alpha}$$   \\tilde{\\iota} $$\\tilde{\\iota} $$    Function 函数    Syntax 语法 Effect 效果     \\sin\\theta $$\\sin\\theta$$   \\cos\\theta $$\\cos\\theta$$   \\tan\\theta $$\\tan\\theta$$   \\arcsin\\frac{L}{r} $$\\arcsin\\frac{L}{r}$$   \\arccos\\frac{T}{r} $$\\arccos\\frac{T}{r}$$   \\arctan\\frac{L}{T} $$\\arctan\\frac{L}{T}$$   \\sinh g $$\\sinh g$$   \\cosh h $$\\cosh h$$   \\tanh i $$\\tanh i$$   \\operatorname{sh}j $$\\operatorname{sh}j$$   \\operatorname{argsh}k $$\\operatorname{argsh}k$$   \\operatorname{ch}h $$\\operatorname{ch}h$$   \\operatorname{argch}l $$\\operatorname{argch}l$$   \\operatorname{th}i $$\\operatorname{th}i$$   \\operatorname{argth}m $$\\operatorname{argth}m$$   k'(x)=\\lim_{\\Delta x\\to 0}\\frac{k(x)-k(x-\\Delta x)}{\\Deltax} $$k\u0026rsquo;(x)=\\lim_{\\Delta x\\to 0}\\frac{k(x)-k(x-\\Delta x)}{\\Delta}$$   \\limsup S $$\\limsup S$$   \\liminf I $$\\liminf I$$   \\max H $$\\max H$$   \\min L $$\\min L$$   \\inf s $$\\inf s$$   \\sup t $$\\sup t$$   \\exp t $$\\exp t$$   \\ln X $$\\ln X$$   \\lg X $$\\lg X$$   \\log X $$\\log X$$   \\log_\\alpha X $$\\log_\\alpha X$$   \\ker x $$\\ker x$$   \\deg x $$\\deg x$$   \\gcd(T,U,V,W,X) $$\\gcd(T,U,V,W,X)$$   \\Pr x $$\\Pr x$$   \\det x $$\\det x$$   \\hom x $$\\hom x$$   \\arg x $$\\arg x$$   \\dim x $$\\dim x$$   \\lim_{t\\to n}T $$\\lim_{t\\to n}T$$    Congruent 同余    Syntax 语法 Effect 效果     \\pmod{m} $$\\pmod{m}$$   a \\bmod b $$a \\bmod b$$    Differential 微分    Syntax 语法 Effect 效果     \\nabla $$\\nabla$$   \\partial x $$\\partial x$$   \\mathrm{d}x $$\\mathrm{d}x$$   \\dot x $$\\dot x$$   \\ddot x $$\\ddot x$$    Set 集合    Syntax 语法 Effect 效果     \\forall $$\\forall$$   \\exists $$\\exists$$   \\emptyset $$\\emptyset$$   \\varnothing $$\\varnothing$$   \\ni $$\\ni$$   \\not\\in $$\\not\\in$$   \\notin $$\\notin$$   \\subset $$\\subset$$   \\supset $$\\supset$$   \\supseteq $$\\supseteq$$   \\cap $$\\cap$$   \\bigcap $$\\bigcap$$   \\bigcap $$\\bigcap$$   \\biguplus $$\\biguplus$$   \\sqsubset $$\\sqsubset$$   \\sqsubseteq $$\\sqsubseteq$$   \\sqsupseteq $$\\sqsupseteq$$   \\sqcap $$\\sqcap$$   \\sqcup $$\\sqcup$$   \\bigsqcup $$\\bigsqcup$$    Logic 逻辑    Syntax 语法 Effect 效果     p $$p$$   \\land $$\\land$$   \\wedge $$\\wedge$$   \\bigwedge $$\\bigwedge$$   \\bar{q} \\to p $$\\bar{q} \\to p$$   \\lor $$\\lor$$   \\vee $$\\vee$$   \\bigvee $$\\bigvee$$   \\lnot $$\\lnot$$   \\neg q $$\\neg q$$   \\setminus $$\\setminus$$   \\smallsetminus $$\\smallsetminus$$    Radication 开方    Syntax 语法 Effect 效果     \\sqrt{3} $$\\sqrt{3}$$   \\sqrt[n]{3} $$\\sqrt[n]{3}$$    Relation 关系    Syntax 语法 Effect 效果     \\Delta ABC\\sim\\Delta XYZ $$\\Delta ABC\\sim\\Delta XYZ$$   \\sqrt{3}\\approx1.732050808\\ldots $$\\sqrt{3}\\approx1.732050808\\ldots$$   \\simeq $$\\simeq$$   \\cong $$\\cong$$   \\dot= $$\\dot=$$   \\ggg $$\\ggg$$   \\gg $$\\gg$$   \u0026gt; $$\u0026gt;$$   \\ge $$\\ge$$   \\geqq $$\\geqq$$   = $$=$$   \\leq $$\\leq$$   \\leqq $$\\leqq$$   \u0026lt; $$\u0026lt;$$   \\ll $$\\ll$$   \\lll $$\\lll$$   (x-y)^2\\equiv(-x+y)^2\\equiv x^2-2xy+y^2 $$(x-y)^2\\equiv(-x+y)^2\\equiv x^2-2xy+y^2$$   x\\not\\equiv N $$x\\not\\equiv N$$   x\\ne A $$x\\ne A$$   x\\neq C $$x\\neq C$$   t\\propto v $$t\\propto v$$   \\pm $$\\pm$$   \\mp $$\\mp$$     To be continue 未完待续   ","date":1562241860,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1562241860,"objectID":"cfa7719454352fdcd4c8a02ca6f786e1","permalink":"https://YuxinZhaozyx.github.io/post/latex-math-symbols/","publishdate":"2019-07-04T20:04:20+08:00","relpermalink":"/post/latex-math-symbols/","section":"post","summary":"Summary of LaTeX Math Symbols","tags":["LaTeX","math","markdown"],"title":"$\\LaTeX$ Math Symbols","type":"post"},{"authors":["Yuxin Zhao 赵煜新"],"categories":["project"],"content":" A bookshop project for my go-micro and micro service learning.\n本项目依据项目 microservice-in-cn 学习micro工具链以及微服务。\n项目简介 本项目为一个网上书店。\n业务模块  用户，users 库存，inventory 权限，auth 订单，orders 支付，payment  服务抽象结构 \n用户、订单、支付服务都会有对外暴露接口，故而它们各自有web层。web层app之间不会互相调用，它们只会与非web层的应用交互。\n","date":1562214423,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1562214423,"objectID":"a890eba53401208c6c266e5fec44d193","permalink":"https://YuxinZhaozyx.github.io/project/gomicrobookshop/","publishdate":"2019-07-04T12:27:03+08:00","relpermalink":"/project/gomicrobookshop/","section":"project","summary":"A bookshop project for my go-micro and micro service learning","tags":["golang","micro","go-micro","micro service"],"title":"GoMicroBookshop","type":"project"}]